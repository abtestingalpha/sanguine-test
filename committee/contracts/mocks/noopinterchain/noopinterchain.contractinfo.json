{"solidity/NoOpInterchain.sol:IInterchainDB":{"code":"0x","runtime-code":"0x","info":{"source":"pragma solidity 0.8.20;\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the entry on the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the local Interchain DataBase.\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    struct LocalEntry {\n        address writer;\n        bytes32 dataHash;\n    }\n\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param entryValue   The value of the entry: writer + dataHash hashed together\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 entryValue;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingEntryValue, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(uint256 dbNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the written entry on this chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(uint256 destChainId, uint256 dbNonce, address[] memory srcModules) external payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`\n    /// by providing the returned `dbNonce`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param dbNonce      The database nonce of the written entry on this chain\n    function getEntry(uint256 dbNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the database.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\ncontract NoOpInterchain is IInterchainDB {\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce The writer-specific nonce of the written entry\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce) {\n        return 0;\n    }\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the written entry on this chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(uint256 destChainId, uint256 dbNonce, address[] memory srcModules) external payable {\n\n    }\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce The writer-specific nonce of the written entry\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n    external\n    payable\n    returns (uint256 dbNonce) {\n        return 0;\n    }\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external {\n\n    }\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256) {\n        return 0;\n    }\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param dbNonce      The database nonce of the written entry on this chain\n    function getEntry(uint256 dbNonce) external view returns (InterchainEntry memory) {\n        return InterchainEntry(0, 0, 0, 0);\n    }\n\n    /// @notice Get the nonce of the database.\n    function getDBNonce() external view returns (uint256)  {\n        return 0;\n    }\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n    external\n    view\n    returns (uint256 moduleVerifiedAt) {\n        return 0;\n    }\n\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"bytes32","name":"existingEntryValue","type":"bytes32"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"newEntry","type":"tuple"}],"name":"InterchainDB__ConflictingEntries","type":"error"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"name":"InterchainDB__EntryDoesNotExist","type":"error"},{"inputs":[{"internalType":"uint256","name":"actualFee","type":"uint256"},{"internalType":"uint256","name":"expectedFee","type":"uint256"}],"name":"InterchainDB__IncorrectFeeAmount","type":"error"},{"inputs":[],"name":"InterchainDB__NoModulesSpecified","type":"error"},{"inputs":[],"name":"InterchainDB__SameChainId","type":"error"},{"inputs":[],"name":"getDBNonce","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"name":"getEntry","outputs":[{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"getInterchainFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"dstModule","type":"address"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"entry","type":"tuple"}],"name":"readEntry","outputs":[{"internalType":"uint256","name":"moduleVerifiedAt","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"requestVerification","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"entry","type":"tuple"}],"name":"verifyEntry","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"name":"writeEntry","outputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"writeEntryWithVerification","outputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"stateMutability":"payable","type":"function"}],"userDoc":{"kind":"user","methods":{"getDBNonce()":{"notice":"Get the nonce of the database."},"getEntry(uint256)":{"notice":"Get the Interchain Entry by the writer and the writer nonce."},"getInterchainFee(uint256,address[])":{"notice":"Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain using the provided Interchain Modules."},"readEntry(address,(uint256,uint256,bytes32,bytes32))":{"notice":"Read the data written on specific source chain by a specific writer, and verify it on the destination chain using the provided Interchain Module. Note: returned zero value indicates that the module has not verified the entry."},"requestVerification(uint256,uint256,address[])":{"notice":"Request the given Interchain Modules to verify the already written entry on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: this method is permissionless, and anyone can request verification for any entry."},"verifyEntry((uint256,uint256,bytes32,bytes32))":{"notice":"Allows the Interchain Module to verify the entry coming from a remote source chain."},"writeEntry(bytes32)":{"notice":"Write data to the Interchain DataBase as a new entry. Note: there are no guarantees that this entry will be available for reading on any of the remote chains. Use `verifyEntry` to ensure that the entry is available for reading on the destination chain."},"writeEntryWithVerification(uint256,bytes32,address[])":{"notice":"Write data to the Interchain DataBase, and request the given Interchain Modules to verify it on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: additional verification for the same entry could be later done using `requestVerification` by providing the returned `dbNonce`."}},"version":1},"developerDoc":{"kind":"dev","methods":{"getEntry(uint256)":{"details":"Will revert if the entry with the given nonce does not exist.","params":{"dbNonce":"The database nonce of the written entry on this chain"}},"getInterchainFee(uint256,address[])":{"details":"Will revert if the empty array of modules is provided.","params":{"destChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"}},"readEntry(address,(uint256,uint256,bytes32,bytes32))":{"params":{"dstModule":"The destination chain addresses of the Interchain Modules to use for verification","entry":"The Interchain Entry to read"},"returns":{"moduleVerifiedAt":"  The block timestamp at which the entry was verified by the module,                             or zero if the module has not verified the entry."}},"requestVerification(uint256,uint256,address[])":{"details":"Will revert if the entry with the given nonce does not exist.","params":{"dbNonce":"The database nonce of the written entry on this chain","destChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"}},"verifyEntry((uint256,uint256,bytes32,bytes32))":{"params":{"entry":"The Interchain Entry to confirm"}},"writeEntry(bytes32)":{"params":{"dataHash":"The hash of the data to be written to the Interchain DataBase as a new entry"},"returns":{"dbNonce":"    The database nonce of the written entry on this chain"}},"writeEntryWithVerification(uint256,bytes32,address[])":{"details":"Will revert if the empty array of modules is provided.","params":{"dataHash":"The hash of the data to be written to the Interchain DataBase as a new entry","destChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"},"returns":{"dbNonce":"    The database nonce of the written entry on this chain"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"existingEntryValue\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"newEntry\",\"type\":\"tuple\"}],\"name\":\"InterchainDB__ConflictingEntries\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__EntryDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actualFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedFee\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__IncorrectFeeAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainDB__NoModulesSpecified\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainDB__SameChainId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"getDBNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"name\":\"getEntry\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"getInterchainFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dstModule\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"entry\",\"type\":\"tuple\"}],\"name\":\"readEntry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"moduleVerifiedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"requestVerification\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"entry\",\"type\":\"tuple\"}],\"name\":\"verifyEntry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"writeEntry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"writeEntryWithVerification\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getEntry(uint256)\":{\"details\":\"Will revert if the entry with the given nonce does not exist.\",\"params\":{\"dbNonce\":\"The database nonce of the written entry on this chain\"}},\"getInterchainFee(uint256,address[])\":{\"details\":\"Will revert if the empty array of modules is provided.\",\"params\":{\"destChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"}},\"readEntry(address,(uint256,uint256,bytes32,bytes32))\":{\"params\":{\"dstModule\":\"The destination chain addresses of the Interchain Modules to use for verification\",\"entry\":\"The Interchain Entry to read\"},\"returns\":{\"moduleVerifiedAt\":\"  The block timestamp at which the entry was verified by the module,                             or zero if the module has not verified the entry.\"}},\"requestVerification(uint256,uint256,address[])\":{\"details\":\"Will revert if the entry with the given nonce does not exist.\",\"params\":{\"dbNonce\":\"The database nonce of the written entry on this chain\",\"destChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"}},\"verifyEntry((uint256,uint256,bytes32,bytes32))\":{\"params\":{\"entry\":\"The Interchain Entry to confirm\"}},\"writeEntry(bytes32)\":{\"params\":{\"dataHash\":\"The hash of the data to be written to the Interchain DataBase as a new entry\"},\"returns\":{\"dbNonce\":\"    The database nonce of the written entry on this chain\"}},\"writeEntryWithVerification(uint256,bytes32,address[])\":{\"details\":\"Will revert if the empty array of modules is provided.\",\"params\":{\"dataHash\":\"The hash of the data to be written to the Interchain DataBase as a new entry\",\"destChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"},\"returns\":{\"dbNonce\":\"    The database nonce of the written entry on this chain\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getDBNonce()\":{\"notice\":\"Get the nonce of the database.\"},\"getEntry(uint256)\":{\"notice\":\"Get the Interchain Entry by the writer and the writer nonce.\"},\"getInterchainFee(uint256,address[])\":{\"notice\":\"Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain using the provided Interchain Modules.\"},\"readEntry(address,(uint256,uint256,bytes32,bytes32))\":{\"notice\":\"Read the data written on specific source chain by a specific writer, and verify it on the destination chain using the provided Interchain Module. Note: returned zero value indicates that the module has not verified the entry.\"},\"requestVerification(uint256,uint256,address[])\":{\"notice\":\"Request the given Interchain Modules to verify the already written entry on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: this method is permissionless, and anyone can request verification for any entry.\"},\"verifyEntry((uint256,uint256,bytes32,bytes32))\":{\"notice\":\"Allows the Interchain Module to verify the entry coming from a remote source chain.\"},\"writeEntry(bytes32)\":{\"notice\":\"Write data to the Interchain DataBase as a new entry. Note: there are no guarantees that this entry will be available for reading on any of the remote chains. Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\"},\"writeEntryWithVerification(uint256,bytes32,address[])\":{\"notice\":\"Write data to the Interchain DataBase, and request the given Interchain Modules to verify it on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: additional verification for the same entry could be later done using `requestVerification` by providing the returned `dbNonce`.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/NoOpInterchain.sol\":\"IInterchainDB\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/NoOpInterchain.sol\":{\"keccak256\":\"0x949c0f3545639d9bbca6d682b29b96f770022ec05194ede8fc49957b52ea6964\",\"urls\":[\"bzz-raw://107ebbbc9a9adac5b49f92408764a7d25a609e30cb20d46ce18763c998e41bc5\",\"dweb:/ipfs/QmU5EabVAPFQLsEMvW5MxaGVNTFoStVjj8LWKVfQKKYD8y\"]}},\"version\":1}"},"hashes":{"getDBNonce()":"f338140e","getEntry(uint256)":"bae78d7b","getInterchainFee(uint256,address[])":"fc7686ec","readEntry(address,(uint256,uint256,bytes32,bytes32))":"a9c9cff1","requestVerification(uint256,uint256,address[])":"81ab5b5a","verifyEntry((uint256,uint256,bytes32,bytes32))":"54941dfa","writeEntry(bytes32)":"2ad8c706","writeEntryWithVerification(uint256,bytes32,address[])":"67c769af"}},"solidity/NoOpInterchain.sol:InterchainEntryLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212208e638d17a5a8a006b2c8e388c0f8c9829dc9d2790d9e9c2b1a77197bd35ac41364736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212208e638d17a5a8a006b2c8e388c0f8c9829dc9d2790d9e9c2b1a77197bd35ac41364736f6c63430008140033","info":{"source":"pragma solidity 0.8.20;\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the entry on the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the local Interchain DataBase.\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    struct LocalEntry {\n        address writer;\n        bytes32 dataHash;\n    }\n\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param entryValue   The value of the entry: writer + dataHash hashed together\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 entryValue;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingEntryValue, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(uint256 dbNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the written entry on this chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(uint256 destChainId, uint256 dbNonce, address[] memory srcModules) external payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`\n    /// by providing the returned `dbNonce`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param dbNonce      The database nonce of the written entry on this chain\n    function getEntry(uint256 dbNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the database.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\ncontract NoOpInterchain is IInterchainDB {\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce The writer-specific nonce of the written entry\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce) {\n        return 0;\n    }\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the written entry on this chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(uint256 destChainId, uint256 dbNonce, address[] memory srcModules) external payable {\n\n    }\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce The writer-specific nonce of the written entry\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n    external\n    payable\n    returns (uint256 dbNonce) {\n        return 0;\n    }\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external {\n\n    }\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256) {\n        return 0;\n    }\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param dbNonce      The database nonce of the written entry on this chain\n    function getEntry(uint256 dbNonce) external view returns (InterchainEntry memory) {\n        return InterchainEntry(0, 0, 0, 0);\n    }\n\n    /// @notice Get the nonce of the database.\n    function getDBNonce() external view returns (uint256)  {\n        return 0;\n    }\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n    external\n    view\n    returns (uint256 moduleVerifiedAt) {\n        return 0;\n    }\n\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"898:1299:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;898:1299:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"898:1299:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/NoOpInterchain.sol\":\"InterchainEntryLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/NoOpInterchain.sol\":{\"keccak256\":\"0x949c0f3545639d9bbca6d682b29b96f770022ec05194ede8fc49957b52ea6964\",\"urls\":[\"bzz-raw://107ebbbc9a9adac5b49f92408764a7d25a609e30cb20d46ce18763c998e41bc5\",\"dweb:/ipfs/QmU5EabVAPFQLsEMvW5MxaGVNTFoStVjj8LWKVfQKKYD8y\"]}},\"version\":1}"},"hashes":{}},"solidity/NoOpInterchain.sol:NoOpInterchain":{"code":"0x608060405234801561001057600080fd5b5061049f806100206000396000f3fe60806040526004361061007b5760003560e01c8063a9c9cff11161004e578063a9c9cff1146100fe578063bae78d7b14610121578063f338140e146101b5578063fc7686ec146101c957600080fd5b80632ad8c7061461008057806354941dfa146100b457806367c769af146100d457806381ab5b5a146100eb575b600080fd5b34801561008c57600080fd5b506100a161009b3660046101e4565b50600090565b6040519081526020015b60405180910390f35b3480156100c057600080fd5b506100d26100cf366004610292565b50565b005b6100a16100e236600461039e565b60009392505050565b6100d26100f936600461039e565b505050565b34801561010a57600080fd5b506100a16101193660046103ee565b600092915050565b34801561012d57600080fd5b5061018261013c3660046101e4565b5060408051608080820183526000808352602080840182905283850182905260609384018290528451928301855281835282018190529281018390529081019190915290565b6040516100ab91908151815260208083015190820152604080830151908201526060918201519181019190915260800190565b3480156101c157600080fd5b5060006100a1565b3480156101d557600080fd5b506100a1610119366004610422565b6000602082840312156101f657600080fd5b5035919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60006080828403121561023e57600080fd5b6040516080810181811067ffffffffffffffff82111715610261576102616101fd565b8060405250809150823581526020830135602082015260408301356040820152606083013560608201525092915050565b6000608082840312156102a457600080fd5b6102ae838361022c565b9392505050565b803573ffffffffffffffffffffffffffffffffffffffff811681146102d957600080fd5b919050565b600082601f8301126102ef57600080fd5b8135602067ffffffffffffffff8083111561030c5761030c6101fd565b8260051b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0603f8301168101818110848211171561034f5761034f6101fd565b60405293845285810183019383810192508785111561036d57600080fd5b83870191505b8482101561039357610384826102b5565b83529183019190830190610373565b979650505050505050565b6000806000606084860312156103b357600080fd5b8335925060208401359150604084013567ffffffffffffffff8111156103d857600080fd5b6103e4868287016102de565b9150509250925092565b60008060a0838503121561040157600080fd5b61040a836102b5565b9150610419846020850161022c565b90509250929050565b6000806040838503121561043557600080fd5b82359150602083013567ffffffffffffffff81111561045357600080fd5b61045f858286016102de565b915050925092905056fea2646970667358221220f018f918ad1aaf1505831b155da3492b908bff7a8ab648b3deaf3525dd2d679964736f6c63430008140033","runtime-code":"0x60806040526004361061007b5760003560e01c8063a9c9cff11161004e578063a9c9cff1146100fe578063bae78d7b14610121578063f338140e146101b5578063fc7686ec146101c957600080fd5b80632ad8c7061461008057806354941dfa146100b457806367c769af146100d457806381ab5b5a146100eb575b600080fd5b34801561008c57600080fd5b506100a161009b3660046101e4565b50600090565b6040519081526020015b60405180910390f35b3480156100c057600080fd5b506100d26100cf366004610292565b50565b005b6100a16100e236600461039e565b60009392505050565b6100d26100f936600461039e565b505050565b34801561010a57600080fd5b506100a16101193660046103ee565b600092915050565b34801561012d57600080fd5b5061018261013c3660046101e4565b5060408051608080820183526000808352602080840182905283850182905260609384018290528451928301855281835282018190529281018390529081019190915290565b6040516100ab91908151815260208083015190820152604080830151908201526060918201519181019190915260800190565b3480156101c157600080fd5b5060006100a1565b3480156101d557600080fd5b506100a1610119366004610422565b6000602082840312156101f657600080fd5b5035919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60006080828403121561023e57600080fd5b6040516080810181811067ffffffffffffffff82111715610261576102616101fd565b8060405250809150823581526020830135602082015260408301356040820152606083013560608201525092915050565b6000608082840312156102a457600080fd5b6102ae838361022c565b9392505050565b803573ffffffffffffffffffffffffffffffffffffffff811681146102d957600080fd5b919050565b600082601f8301126102ef57600080fd5b8135602067ffffffffffffffff8083111561030c5761030c6101fd565b8260051b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0603f8301168101818110848211171561034f5761034f6101fd565b60405293845285810183019383810192508785111561036d57600080fd5b83870191505b8482101561039357610384826102b5565b83529183019190830190610373565b979650505050505050565b6000806000606084860312156103b357600080fd5b8335925060208401359150604084013567ffffffffffffffff8111156103d857600080fd5b6103e4868287016102de565b9150509250925092565b60008060a0838503121561040157600080fd5b61040a836102b5565b9150610419846020850161022c565b90509250929050565b6000806040838503121561043557600080fd5b82359150602083013567ffffffffffffffff81111561045357600080fd5b61045f858286016102de565b915050925092905056fea2646970667358221220f018f918ad1aaf1505831b155da3492b908bff7a8ab648b3deaf3525dd2d679964736f6c63430008140033","info":{"source":"pragma solidity 0.8.20;\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the entry on the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the local Interchain DataBase.\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    struct LocalEntry {\n        address writer;\n        bytes32 dataHash;\n    }\n\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param entryValue   The value of the entry: writer + dataHash hashed together\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 entryValue;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingEntryValue, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(uint256 dbNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the written entry on this chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(uint256 destChainId, uint256 dbNonce, address[] memory srcModules) external payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`\n    /// by providing the returned `dbNonce`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param dbNonce      The database nonce of the written entry on this chain\n    function getEntry(uint256 dbNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the database.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\ncontract NoOpInterchain is IInterchainDB {\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce The writer-specific nonce of the written entry\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce) {\n        return 0;\n    }\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the written entry on this chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(uint256 destChainId, uint256 dbNonce, address[] memory srcModules) external payable {\n\n    }\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce The writer-specific nonce of the written entry\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n    external\n    payable\n    returns (uint256 dbNonce) {\n        return 0;\n    }\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external {\n\n    }\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256) {\n        return 0;\n    }\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param dbNonce      The database nonce of the written entry on this chain\n    function getEntry(uint256 dbNonce) external view returns (InterchainEntry memory) {\n        return InterchainEntry(0, 0, 0, 0);\n    }\n\n    /// @notice Get the nonce of the database.\n    function getDBNonce() external view returns (uint256)  {\n        return 0;\n    }\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n    external\n    view\n    returns (uint256 moduleVerifiedAt) {\n        return 0;\n    }\n\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"7655:4554:0:-:0;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"7655:4554:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8164:98;;;;;;;;;;-1:-1:-1;8164:98:0;;;;;:::i;:::-;-1:-1:-1;8220:15:0;;8164:98;;;;345:25:1;;;333:2;318:18;8164:98:0;;;;;;;;10297:68;;;;;;;;;;-1:-1:-1;10297:68:0;;;;;:::i;:::-;;;;;9917:214;;;;;;:::i;:::-;10089:15;9917:214;;;;;;8968:121;;;;;;:::i;:::-;;;;;12030:176;;;;;;;;;;-1:-1:-1;12030:176:0;;;;;:::i;:::-;12155:24;12030:176;;;;;11145:133;;;;;;;;;;-1:-1:-1;11145:133:0;;;;;:::i;:::-;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;11244:27:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;11145:133;;;;;;;4318:13:1;;4300:32;;4388:4;4376:17;;;4370:24;4348:20;;;4341:54;4451:4;4439:17;;;4433:24;4411:20;;;4404:54;4514:4;4502:17;;;4496:24;4474:20;;;4467:54;;;;4287:3;4272:19;;4091:436;11331:80:0;;;;;;;;;;-1:-1:-1;11376:7:0;11331:80;;10772:133;;;;;;;;;;-1:-1:-1;10772:133:0;;;;;:::i;14:180:1:-;73:6;126:2;114:9;105:7;101:23;97:32;94:52;;;142:1;139;132:12;94:52;-1:-1:-1;165:23:1;;14:180;-1:-1:-1;14:180:1:o;381:184::-;433:77;430:1;423:88;530:4;527:1;520:15;554:4;551:1;544:15;570:612;632:5;680:4;668:9;663:3;659:19;655:30;652:50;;;698:1;695;688:12;652:50;731:2;725:9;773:4;765:6;761:17;844:6;832:10;829:22;808:18;796:10;793:34;790:62;787:88;;;855:18;;:::i;:::-;895:10;891:2;884:22;;924:6;915:15;;967:9;954:23;946:6;939:39;1039:2;1028:9;1024:18;1011:32;1006:2;998:6;994:15;987:57;1105:2;1094:9;1090:18;1077:32;1072:2;1064:6;1060:15;1053:57;1171:2;1160:9;1156:18;1143:32;1138:2;1130:6;1126:15;1119:57;;570:612;;;;:::o;1187:242::-;1277:6;1330:3;1318:9;1309:7;1305:23;1301:33;1298:53;;;1347:1;1344;1337:12;1298:53;1370;1415:7;1404:9;1370:53;:::i;:::-;1360:63;1187:242;-1:-1:-1;;;1187:242:1:o;1434:196::-;1502:20;;1562:42;1551:54;;1541:65;;1531:93;;1620:1;1617;1610:12;1531:93;1434:196;;;:::o;1635:967::-;1689:5;1742:3;1735:4;1727:6;1723:17;1719:27;1709:55;;1760:1;1757;1750:12;1709:55;1796:6;1783:20;1822:4;1845:18;1882:2;1878;1875:10;1872:36;;;1888:18;;:::i;:::-;1934:2;1931:1;1927:10;1966:2;1960:9;2025:66;2020:2;2016;2012:11;2008:84;2000:6;1996:97;2143:6;2131:10;2128:22;2123:2;2111:10;2108:18;2105:46;2102:72;;;2154:18;;:::i;:::-;2190:2;2183:22;2240:18;;;2316:15;;;2312:24;;;2274:15;;;;-1:-1:-1;2348:15:1;;;2345:35;;;2376:1;2373;2366:12;2345:35;2412:2;2404:6;2400:15;2389:26;;2424:148;2440:6;2435:3;2432:15;2424:148;;;2506:23;2525:3;2506:23;:::i;:::-;2494:36;;2550:12;;;;2457;;;;2424:148;;;2590:6;1635:967;-1:-1:-1;;;;;;;1635:967:1:o;2607:484::-;2709:6;2717;2725;2778:2;2766:9;2757:7;2753:23;2749:32;2746:52;;;2794:1;2791;2784:12;2746:52;2830:9;2817:23;2807:33;;2887:2;2876:9;2872:18;2859:32;2849:42;;2942:2;2931:9;2927:18;2914:32;2969:18;2961:6;2958:30;2955:50;;;3001:1;2998;2991:12;2955:50;3024:61;3077:7;3068:6;3057:9;3053:22;3024:61;:::i;:::-;3014:71;;;2607:484;;;;;:::o;3585:316::-;3684:6;3692;3745:3;3733:9;3724:7;3720:23;3716:33;3713:53;;;3762:1;3759;3752:12;3713:53;3785:29;3804:9;3785:29;:::i;:::-;3775:39;;3833:62;3887:7;3882:2;3871:9;3867:18;3833:62;:::i;:::-;3823:72;;3585:316;;;;;:::o;4532:416::-;4625:6;4633;4686:2;4674:9;4665:7;4661:23;4657:32;4654:52;;;4702:1;4699;4692:12;4654:52;4738:9;4725:23;4715:33;;4799:2;4788:9;4784:18;4771:32;4826:18;4818:6;4815:30;4812:50;;;4858:1;4855;4848:12;4812:50;4881:61;4934:7;4925:6;4914:9;4910:22;4881:61;:::i;:::-;4871:71;;;4532:416;;;;;:::o","abiDefinition":[{"inputs":[{"internalType":"bytes32","name":"existingEntryValue","type":"bytes32"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"newEntry","type":"tuple"}],"name":"InterchainDB__ConflictingEntries","type":"error"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"name":"InterchainDB__EntryDoesNotExist","type":"error"},{"inputs":[{"internalType":"uint256","name":"actualFee","type":"uint256"},{"internalType":"uint256","name":"expectedFee","type":"uint256"}],"name":"InterchainDB__IncorrectFeeAmount","type":"error"},{"inputs":[],"name":"InterchainDB__NoModulesSpecified","type":"error"},{"inputs":[],"name":"InterchainDB__SameChainId","type":"error"},{"inputs":[],"name":"getDBNonce","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"name":"getEntry","outputs":[{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"getInterchainFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"dstModule","type":"address"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"entry","type":"tuple"}],"name":"readEntry","outputs":[{"internalType":"uint256","name":"moduleVerifiedAt","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"requestVerification","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"entry","type":"tuple"}],"name":"verifyEntry","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"name":"writeEntry","outputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"writeEntryWithVerification","outputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"stateMutability":"payable","type":"function"}],"userDoc":{"kind":"user","methods":{"getDBNonce()":{"notice":"Get the nonce of the database."},"getEntry(uint256)":{"notice":"Get the Interchain Entry by the writer and the writer nonce."},"getInterchainFee(uint256,address[])":{"notice":"Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain using the provided Interchain Modules."},"readEntry(address,(uint256,uint256,bytes32,bytes32))":{"notice":"Read the data written on specific source chain by a specific writer, and verify it on the destination chain using the provided Interchain Module. Note: returned zero value indicates that the module has not verified the entry."},"requestVerification(uint256,uint256,address[])":{"notice":"Request the given Interchain Modules to verify the already written entry on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: this method is permissionless, and anyone can request verification for any entry."},"verifyEntry((uint256,uint256,bytes32,bytes32))":{"notice":"Allows the Interchain Module to verify the entry coming from a remote source chain."},"writeEntry(bytes32)":{"notice":"Write data to the Interchain DataBase as a new entry. Note: there are no guarantees that this entry will be available for reading on any of the remote chains. Use `verifyEntry` to ensure that the entry is available for reading on the destination chain."},"writeEntryWithVerification(uint256,bytes32,address[])":{"notice":"Write data to the Interchain DataBase, and request the given Interchain Modules to verify it on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: additional verification for the same entry could be later done using `requestVerification`."}},"version":1},"developerDoc":{"kind":"dev","methods":{"getEntry(uint256)":{"details":"Will revert if the entry with the given nonce does not exist.","params":{"dbNonce":"The database nonce of the written entry on this chain"}},"getInterchainFee(uint256,address[])":{"details":"Will revert if the empty array of modules is provided.","params":{"destChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"}},"readEntry(address,(uint256,uint256,bytes32,bytes32))":{"params":{"dstModule":"The destination chain addresses of the Interchain Modules to use for verification","entry":"The Interchain Entry to read"},"returns":{"moduleVerifiedAt":"  The block timestamp at which the entry was verified by the module,                             or zero if the module has not verified the entry."}},"requestVerification(uint256,uint256,address[])":{"details":"Will revert if the entry with the given nonce does not exist.","params":{"dbNonce":"The database nonce of the written entry on this chain","destChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"}},"verifyEntry((uint256,uint256,bytes32,bytes32))":{"params":{"entry":"The Interchain Entry to confirm"}},"writeEntry(bytes32)":{"params":{"dataHash":"The hash of the data to be written to the Interchain DataBase as a new entry"},"returns":{"dbNonce":"The writer-specific nonce of the written entry"}},"writeEntryWithVerification(uint256,bytes32,address[])":{"details":"Will revert if the empty array of modules is provided.","params":{"dataHash":"The hash of the data to be written to the Interchain DataBase as a new entry","destChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"},"returns":{"dbNonce":"The writer-specific nonce of the written entry"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"existingEntryValue\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"newEntry\",\"type\":\"tuple\"}],\"name\":\"InterchainDB__ConflictingEntries\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__EntryDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actualFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedFee\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__IncorrectFeeAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainDB__NoModulesSpecified\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainDB__SameChainId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"getDBNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"name\":\"getEntry\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"getInterchainFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dstModule\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"entry\",\"type\":\"tuple\"}],\"name\":\"readEntry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"moduleVerifiedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"requestVerification\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"entry\",\"type\":\"tuple\"}],\"name\":\"verifyEntry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"writeEntry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"writeEntryWithVerification\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getEntry(uint256)\":{\"details\":\"Will revert if the entry with the given nonce does not exist.\",\"params\":{\"dbNonce\":\"The database nonce of the written entry on this chain\"}},\"getInterchainFee(uint256,address[])\":{\"details\":\"Will revert if the empty array of modules is provided.\",\"params\":{\"destChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"}},\"readEntry(address,(uint256,uint256,bytes32,bytes32))\":{\"params\":{\"dstModule\":\"The destination chain addresses of the Interchain Modules to use for verification\",\"entry\":\"The Interchain Entry to read\"},\"returns\":{\"moduleVerifiedAt\":\"  The block timestamp at which the entry was verified by the module,                             or zero if the module has not verified the entry.\"}},\"requestVerification(uint256,uint256,address[])\":{\"details\":\"Will revert if the entry with the given nonce does not exist.\",\"params\":{\"dbNonce\":\"The database nonce of the written entry on this chain\",\"destChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"}},\"verifyEntry((uint256,uint256,bytes32,bytes32))\":{\"params\":{\"entry\":\"The Interchain Entry to confirm\"}},\"writeEntry(bytes32)\":{\"params\":{\"dataHash\":\"The hash of the data to be written to the Interchain DataBase as a new entry\"},\"returns\":{\"dbNonce\":\"The writer-specific nonce of the written entry\"}},\"writeEntryWithVerification(uint256,bytes32,address[])\":{\"details\":\"Will revert if the empty array of modules is provided.\",\"params\":{\"dataHash\":\"The hash of the data to be written to the Interchain DataBase as a new entry\",\"destChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"},\"returns\":{\"dbNonce\":\"The writer-specific nonce of the written entry\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getDBNonce()\":{\"notice\":\"Get the nonce of the database.\"},\"getEntry(uint256)\":{\"notice\":\"Get the Interchain Entry by the writer and the writer nonce.\"},\"getInterchainFee(uint256,address[])\":{\"notice\":\"Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain using the provided Interchain Modules.\"},\"readEntry(address,(uint256,uint256,bytes32,bytes32))\":{\"notice\":\"Read the data written on specific source chain by a specific writer, and verify it on the destination chain using the provided Interchain Module. Note: returned zero value indicates that the module has not verified the entry.\"},\"requestVerification(uint256,uint256,address[])\":{\"notice\":\"Request the given Interchain Modules to verify the already written entry on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: this method is permissionless, and anyone can request verification for any entry.\"},\"verifyEntry((uint256,uint256,bytes32,bytes32))\":{\"notice\":\"Allows the Interchain Module to verify the entry coming from a remote source chain.\"},\"writeEntry(bytes32)\":{\"notice\":\"Write data to the Interchain DataBase as a new entry. Note: there are no guarantees that this entry will be available for reading on any of the remote chains. Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\"},\"writeEntryWithVerification(uint256,bytes32,address[])\":{\"notice\":\"Write data to the Interchain DataBase, and request the given Interchain Modules to verify it on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: additional verification for the same entry could be later done using `requestVerification`.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/NoOpInterchain.sol\":\"NoOpInterchain\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/NoOpInterchain.sol\":{\"keccak256\":\"0x949c0f3545639d9bbca6d682b29b96f770022ec05194ede8fc49957b52ea6964\",\"urls\":[\"bzz-raw://107ebbbc9a9adac5b49f92408764a7d25a609e30cb20d46ce18763c998e41bc5\",\"dweb:/ipfs/QmU5EabVAPFQLsEMvW5MxaGVNTFoStVjj8LWKVfQKKYD8y\"]}},\"version\":1}"},"hashes":{"getDBNonce()":"f338140e","getEntry(uint256)":"bae78d7b","getInterchainFee(uint256,address[])":"fc7686ec","readEntry(address,(uint256,uint256,bytes32,bytes32))":"a9c9cff1","requestVerification(uint256,uint256,address[])":"81ab5b5a","verifyEntry((uint256,uint256,bytes32,bytes32))":"54941dfa","writeEntry(bytes32)":"2ad8c706","writeEntryWithVerification(uint256,bytes32,address[])":"67c769af"}},"solidity/NoOpInterchain.sol:TypeCasts":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122097f8e918be3ef79d895c08e2e35743a44467807458d405f6740c23aa68cbbb7564736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122097f8e918be3ef79d895c08e2e35743a44467807458d405f6740c23aa68cbbb7564736f6c63430008140033","info":{"source":"pragma solidity 0.8.20;\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the entry on the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the local Interchain DataBase.\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    struct LocalEntry {\n        address writer;\n        bytes32 dataHash;\n    }\n\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param entryValue   The value of the entry: writer + dataHash hashed together\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 entryValue;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingEntryValue, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(uint256 dbNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the written entry on this chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(uint256 destChainId, uint256 dbNonce, address[] memory srcModules) external payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`\n    /// by providing the returned `dbNonce`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param dbNonce      The database nonce of the written entry on this chain\n    function getEntry(uint256 dbNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the database.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\ncontract NoOpInterchain is IInterchainDB {\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce The writer-specific nonce of the written entry\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce) {\n        return 0;\n    }\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the written entry on this chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(uint256 destChainId, uint256 dbNonce, address[] memory srcModules) external payable {\n\n    }\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce The writer-specific nonce of the written entry\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n    external\n    payable\n    returns (uint256 dbNonce) {\n        return 0;\n    }\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external {\n\n    }\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256) {\n        return 0;\n    }\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param dbNonce      The database nonce of the written entry on this chain\n    function getEntry(uint256 dbNonce) external view returns (InterchainEntry memory) {\n        return InterchainEntry(0, 0, 0, 0);\n    }\n\n    /// @notice Get the nonce of the database.\n    function getDBNonce() external view returns (uint256)  {\n        return 0;\n    }\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n    external\n    view\n    returns (uint256 moduleVerifiedAt) {\n        return 0;\n    }\n\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"25:280:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;25:280:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"25:280:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/NoOpInterchain.sol\":\"TypeCasts\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/NoOpInterchain.sol\":{\"keccak256\":\"0x949c0f3545639d9bbca6d682b29b96f770022ec05194ede8fc49957b52ea6964\",\"urls\":[\"bzz-raw://107ebbbc9a9adac5b49f92408764a7d25a609e30cb20d46ce18763c998e41bc5\",\"dweb:/ipfs/QmU5EabVAPFQLsEMvW5MxaGVNTFoStVjj8LWKVfQKKYD8y\"]}},\"version\":1}"},"hashes":{}}}