{"solidity/InterchainClientV1.sol:Context":{"code":"0x","runtime-code":"0x","info":{"source":"pragma solidity =0.8.20 ^0.8.0 ^0.8.20;\n\n// contracts/interfaces/IInterchainApp.sol\n\ninterface IInterchainApp {\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory sendingModules,\n        address[] memory receivingModules,\n        uint256 requiredResponses,\n        uint64 optimisticTimePeriod\n    )\n        external;\n\n    function getLinkedIApp(uint64 chainID) external view returns (address);\n\n    function getSendingModules() external view returns (address[] memory);\n\n    function getReceivingModules() external view returns (address[] memory);\n\n    function getRequiredResponses() external view returns (uint256);\n\n    function getOptimisticTimePeriod() external view returns (uint64);\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable;\n\n    function appReceive() external;\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sets the address of the InterchainDB contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param _interchainDB The address of the InterchainDB contract.\n     */\n    function setInterchainDB(address _interchainDB) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param message The message being sent.\n     * @param srcModules The source modules involved in the message sending.\n     */\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        address[] calldata srcModules\n    )\n        external\n        payable;\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * @param transactionID The ID of the transaction being executed.\n     * @param transaction The transaction data.\n     */\n    function interchainExecute(bytes32 transactionID, bytes calldata transaction) external;\n\n    /**\n     * @notice Converts a bytes32 value to an address.\n     * @dev Useful for converting blockchain-specific identifiers to Ethereum addresses.\n     * @param _bytes32 The bytes32 value to convert.\n     * @return address The address obtained from the bytes32 value.\n     */\n    function convertBytes32ToAddress(bytes32 _bytes32) external pure returns (address);\n\n    /**\n     * @notice Converts an address to a bytes32 value.\n     * @dev Useful for converting Ethereum addresses to blockchain-specific identifiers.\n     * @param _address The address to convert.\n     * @return bytes32 The bytes32 representation of the address.\n     */\n    function convertAddressToBytes32(address _address) external pure returns (bytes32);\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase\n/// @param srcChainId   The chain id of the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param writerNonce  The nonce of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    bytes32 srcWriter;\n    uint256 writerNonce;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param srcWriter    The address of the writer on the local chain\n    /// @param writerNonce  The nonce of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        address srcWriter,\n        uint256 writerNonce,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            srcWriter: TypeCasts.addressToBytes32(srcWriter),\n            writerNonce: writerNonce,\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryId(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.srcWriter, entry.writerNonce));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param dataHash     The hash of the data written on the source chain\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 dataHash;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingDataHash, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(address writer, uint256 writerNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntry(bytes32 dataHash) external returns (uint256 writerNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param writer        The address of the writer on the source chain\n    /// @param writerNonce   The nonce of the writer on the source chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(\n        uint256 destChainId,\n        address writer,\n        uint256 writerNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 writerNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param writer       The address of the writer on this chain\n    /// @param writerNonce  The nonce of the writer's entry on this chain\n    function getEntry(address writer, uint256 writerNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the writer on this chain.\n    /// @param writer       The address of the writer on this chain\n    function getWriterNonce(address writer) external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, IInterchainClientV1 {\n    uint64 public clientNonce;\n    address public interchainDB;\n\n    // Chain ID =\u003e Bytes32 Address of src clients\n    mapping(uint256 =\u003e bytes32) linkedClients;\n\n    // TODO: Add permissioning\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint256 chainId, bytes32 client) public {\n        linkedClients[chainId] = client;\n    }\n\n    constructor() Ownable(msg.sender) {}\n\n    // @inheritdoc IInterchainClientV1\n    function setInterchainDB(address _interchainDB) public onlyOwner {\n        interchainDB = _interchainDB;\n    }\n\n    /**\n     * @notice Emitted when an interchain transaction is sent.\n     */\n    event InterchainTransactionSent(\n        bytes32 srcSender,\n        uint256 srcChainId,\n        bytes32 indexed dstReceiver,\n        uint256 indexed dstChainId,\n        bytes message,\n        uint64 nonce,\n        bytes32 indexed transactionId,\n        uint256 dbWriterNonce\n    );\n\n    /**\n     * @dev Represents an interchain transaction.\n     */\n    struct InterchainTransaction {\n        bytes32 srcSender;\n        uint256 srcChainId;\n        bytes32 dstReceiver;\n        uint256 dstChainId;\n        bytes message;\n        uint64 nonce;\n        bytes32 transactionId;\n        uint256 dbWriterNonce;\n    }\n\n    // TODO: Calculate Gas Pricing per module and charge fees\n    // TODO: Customizable Gas Limit for Execution\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        address[] calldata srcModules\n    )\n        public\n        payable\n    {\n        uint256 totalModuleFees = msg.value;\n        bytes32 sender = convertAddressToBytes32(msg.sender);\n        bytes32 transactionID = keccak256(abi.encode(sender, block.chainid, receiver, dstChainId, message, clientNonce));\n\n        uint256 dbWriterNonce = IInterchainDB(interchainDB).writeEntryWithVerification{value: totalModuleFees}(\n            dstChainId, transactionID, srcModules\n        );\n\n        emit InterchainTransactionSent(\n            sender, block.chainid, receiver, dstChainId, message, clientNonce, transactionID, dbWriterNonce\n        );\n        // Increment nonce for next message\n        clientNonce++;\n    }\n\n    // TODO: Gas Fee Consideration that is paid to executor\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(bytes32 transactionID, bytes calldata transaction) public {\n        // Steps to verify:\n        // 1. Call icDB.getEntry(linkedClients.srcChainId, transaction.dbWriterNonce)\n        // 2. Verify the entry hash vs bytes calldata provided\n        // 3. Check receiver's app dstModule configuration\n        // 4. Check receiver app's optimistic time period\n        // 5. Read module entry's based on receiver app dstModule config\n        // 6. Confirm module threshold is met\n        // 7. Check optimistic threshold set on app config\n        // 8. Execute the transaction, is optimistic period is met.\n\n        InterchainTransaction memory icTx = abi.decode(transaction, (InterchainTransaction));\n\n        // 1. Call icDB.getEntry(linkedClients.srcChainId, transaction.dbWriterNonce)\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            srcWriter: linkedClients[icTx.srcChainId],\n            writerNonce: icTx.dbWriterNonce,\n            dataHash: icTx.transactionId\n        });\n\n        bytes memory reconstructedID =\n            abi.encode(icTx.srcSender, icTx.srcChainId, icTx.dstReceiver, icTx.dstChainId, icTx.message, icTx.nonce);\n\n        // 2. Verify the entry hash vs bytes calldata provided\n        require(icEntry.dataHash == keccak256(reconstructedID), \"Invalid transaction ID\");\n\n        address receivingApp = convertBytes32ToAddress(icTx.dstReceiver);\n        // 3. Check receiver's app dstModule configuration\n        address[] memory approvedDstModules = IInterchainApp(receivingApp).getReceivingModules();\n\n        uint256 appRequiredResponses = IInterchainApp(receivingApp).getRequiredResponses();\n\n        // 4. Check receiver app's optimistic time period\n        uint256 optimisticTimePeriod = IInterchainApp(receivingApp).getOptimisticTimePeriod();\n\n        // 5. Read module entry's based on receiver app dstModule config\n        uint256[] memory moduleResponseTimestamps = new uint256[](approvedDstModules.length);\n\n        for (uint256 i = 0; i \u003c approvedDstModules.length; i++) {\n            moduleResponseTimestamps[i] = IInterchainDB(interchainDB).readEntry(approvedDstModules[i], icEntry);\n        }\n        // 6. Confirm module threshold is met\n        uint256 validResponses = 0;\n\n        for (uint256 i = 0; i \u003c moduleResponseTimestamps.length; i++) {\n            if (moduleResponseTimestamps[i] + optimisticTimePeriod \u003e= block.timestamp) {\n                validResponses++;\n            }\n        }\n\n        require(validResponses \u003e= appRequiredResponses, \"Not enough valid responses to meet the threshold\");\n\n        // 8. Execute the transaction, is optimistic period \u0026 valid responses is met.\n        IInterchainApp(receivingApp).appReceive();\n    }\n\n    // TODO: Seperate out into utils\n    /**\n     * @inheritdoc IInterchainClientV1\n     */\n    function convertBytes32ToAddress(bytes32 _bytes32) public pure returns (address) {\n        return address(uint160(uint256(_bytes32)));\n    }\n\n    /**\n     * @inheritdoc IInterchainClientV1\n     */\n    function convertAddressToBytes32(address _address) public pure returns (bytes32) {\n        return bytes32(uint256(uint160(_address)));\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Provides information about the current execution context, including the sender of the transaction and its data. While these are generally available via msg.sender and msg.data, they should not be accessed in such a direct manner, since when dealing with meta-transactions the account sending and paying for execution may not be the actual sender (as far as an application is concerned). This contract is only required for intermediate, library-like contracts.","kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Provides information about the current execution context, including the sender of the transaction and its data. While these are generally available via msg.sender and msg.data, they should not be accessed in such a direct manner, since when dealing with meta-transactions the account sending and paying for execution may not be the actual sender (as far as an application is concerned). This contract is only required for intermediate, library-like contracts.\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"Context\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0x982e9011e738d832d83545cccb9c0d49738847d637bb91992a6f611d678b844b\",\"urls\":[\"bzz-raw://6e484f8559b38a654ef0b91ea4bd7da1a17e1ca301762a382750e2af2d85aed7\",\"dweb:/ipfs/QmZz3158XFik6u5SJvaYdQrXpcM87h6aY2kf83ntcqD2sX\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainClientV1.sol:IInterchainApp":{"code":"0x","runtime-code":"0x","info":{"source":"pragma solidity =0.8.20 ^0.8.0 ^0.8.20;\n\n// contracts/interfaces/IInterchainApp.sol\n\ninterface IInterchainApp {\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory sendingModules,\n        address[] memory receivingModules,\n        uint256 requiredResponses,\n        uint64 optimisticTimePeriod\n    )\n        external;\n\n    function getLinkedIApp(uint64 chainID) external view returns (address);\n\n    function getSendingModules() external view returns (address[] memory);\n\n    function getReceivingModules() external view returns (address[] memory);\n\n    function getRequiredResponses() external view returns (uint256);\n\n    function getOptimisticTimePeriod() external view returns (uint64);\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable;\n\n    function appReceive() external;\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sets the address of the InterchainDB contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param _interchainDB The address of the InterchainDB contract.\n     */\n    function setInterchainDB(address _interchainDB) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param message The message being sent.\n     * @param srcModules The source modules involved in the message sending.\n     */\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        address[] calldata srcModules\n    )\n        external\n        payable;\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * @param transactionID The ID of the transaction being executed.\n     * @param transaction The transaction data.\n     */\n    function interchainExecute(bytes32 transactionID, bytes calldata transaction) external;\n\n    /**\n     * @notice Converts a bytes32 value to an address.\n     * @dev Useful for converting blockchain-specific identifiers to Ethereum addresses.\n     * @param _bytes32 The bytes32 value to convert.\n     * @return address The address obtained from the bytes32 value.\n     */\n    function convertBytes32ToAddress(bytes32 _bytes32) external pure returns (address);\n\n    /**\n     * @notice Converts an address to a bytes32 value.\n     * @dev Useful for converting Ethereum addresses to blockchain-specific identifiers.\n     * @param _address The address to convert.\n     * @return bytes32 The bytes32 representation of the address.\n     */\n    function convertAddressToBytes32(address _address) external pure returns (bytes32);\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase\n/// @param srcChainId   The chain id of the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param writerNonce  The nonce of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    bytes32 srcWriter;\n    uint256 writerNonce;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param srcWriter    The address of the writer on the local chain\n    /// @param writerNonce  The nonce of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        address srcWriter,\n        uint256 writerNonce,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            srcWriter: TypeCasts.addressToBytes32(srcWriter),\n            writerNonce: writerNonce,\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryId(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.srcWriter, entry.writerNonce));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param dataHash     The hash of the data written on the source chain\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 dataHash;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingDataHash, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(address writer, uint256 writerNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntry(bytes32 dataHash) external returns (uint256 writerNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param writer        The address of the writer on the source chain\n    /// @param writerNonce   The nonce of the writer on the source chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(\n        uint256 destChainId,\n        address writer,\n        uint256 writerNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 writerNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param writer       The address of the writer on this chain\n    /// @param writerNonce  The nonce of the writer's entry on this chain\n    function getEntry(address writer, uint256 writerNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the writer on this chain.\n    /// @param writer       The address of the writer on this chain\n    function getWriterNonce(address writer) external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, IInterchainClientV1 {\n    uint64 public clientNonce;\n    address public interchainDB;\n\n    // Chain ID =\u003e Bytes32 Address of src clients\n    mapping(uint256 =\u003e bytes32) linkedClients;\n\n    // TODO: Add permissioning\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint256 chainId, bytes32 client) public {\n        linkedClients[chainId] = client;\n    }\n\n    constructor() Ownable(msg.sender) {}\n\n    // @inheritdoc IInterchainClientV1\n    function setInterchainDB(address _interchainDB) public onlyOwner {\n        interchainDB = _interchainDB;\n    }\n\n    /**\n     * @notice Emitted when an interchain transaction is sent.\n     */\n    event InterchainTransactionSent(\n        bytes32 srcSender,\n        uint256 srcChainId,\n        bytes32 indexed dstReceiver,\n        uint256 indexed dstChainId,\n        bytes message,\n        uint64 nonce,\n        bytes32 indexed transactionId,\n        uint256 dbWriterNonce\n    );\n\n    /**\n     * @dev Represents an interchain transaction.\n     */\n    struct InterchainTransaction {\n        bytes32 srcSender;\n        uint256 srcChainId;\n        bytes32 dstReceiver;\n        uint256 dstChainId;\n        bytes message;\n        uint64 nonce;\n        bytes32 transactionId;\n        uint256 dbWriterNonce;\n    }\n\n    // TODO: Calculate Gas Pricing per module and charge fees\n    // TODO: Customizable Gas Limit for Execution\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        address[] calldata srcModules\n    )\n        public\n        payable\n    {\n        uint256 totalModuleFees = msg.value;\n        bytes32 sender = convertAddressToBytes32(msg.sender);\n        bytes32 transactionID = keccak256(abi.encode(sender, block.chainid, receiver, dstChainId, message, clientNonce));\n\n        uint256 dbWriterNonce = IInterchainDB(interchainDB).writeEntryWithVerification{value: totalModuleFees}(\n            dstChainId, transactionID, srcModules\n        );\n\n        emit InterchainTransactionSent(\n            sender, block.chainid, receiver, dstChainId, message, clientNonce, transactionID, dbWriterNonce\n        );\n        // Increment nonce for next message\n        clientNonce++;\n    }\n\n    // TODO: Gas Fee Consideration that is paid to executor\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(bytes32 transactionID, bytes calldata transaction) public {\n        // Steps to verify:\n        // 1. Call icDB.getEntry(linkedClients.srcChainId, transaction.dbWriterNonce)\n        // 2. Verify the entry hash vs bytes calldata provided\n        // 3. Check receiver's app dstModule configuration\n        // 4. Check receiver app's optimistic time period\n        // 5. Read module entry's based on receiver app dstModule config\n        // 6. Confirm module threshold is met\n        // 7. Check optimistic threshold set on app config\n        // 8. Execute the transaction, is optimistic period is met.\n\n        InterchainTransaction memory icTx = abi.decode(transaction, (InterchainTransaction));\n\n        // 1. Call icDB.getEntry(linkedClients.srcChainId, transaction.dbWriterNonce)\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            srcWriter: linkedClients[icTx.srcChainId],\n            writerNonce: icTx.dbWriterNonce,\n            dataHash: icTx.transactionId\n        });\n\n        bytes memory reconstructedID =\n            abi.encode(icTx.srcSender, icTx.srcChainId, icTx.dstReceiver, icTx.dstChainId, icTx.message, icTx.nonce);\n\n        // 2. Verify the entry hash vs bytes calldata provided\n        require(icEntry.dataHash == keccak256(reconstructedID), \"Invalid transaction ID\");\n\n        address receivingApp = convertBytes32ToAddress(icTx.dstReceiver);\n        // 3. Check receiver's app dstModule configuration\n        address[] memory approvedDstModules = IInterchainApp(receivingApp).getReceivingModules();\n\n        uint256 appRequiredResponses = IInterchainApp(receivingApp).getRequiredResponses();\n\n        // 4. Check receiver app's optimistic time period\n        uint256 optimisticTimePeriod = IInterchainApp(receivingApp).getOptimisticTimePeriod();\n\n        // 5. Read module entry's based on receiver app dstModule config\n        uint256[] memory moduleResponseTimestamps = new uint256[](approvedDstModules.length);\n\n        for (uint256 i = 0; i \u003c approvedDstModules.length; i++) {\n            moduleResponseTimestamps[i] = IInterchainDB(interchainDB).readEntry(approvedDstModules[i], icEntry);\n        }\n        // 6. Confirm module threshold is met\n        uint256 validResponses = 0;\n\n        for (uint256 i = 0; i \u003c moduleResponseTimestamps.length; i++) {\n            if (moduleResponseTimestamps[i] + optimisticTimePeriod \u003e= block.timestamp) {\n                validResponses++;\n            }\n        }\n\n        require(validResponses \u003e= appRequiredResponses, \"Not enough valid responses to meet the threshold\");\n\n        // 8. Execute the transaction, is optimistic period \u0026 valid responses is met.\n        IInterchainApp(receivingApp).appReceive();\n    }\n\n    // TODO: Seperate out into utils\n    /**\n     * @inheritdoc IInterchainClientV1\n     */\n    function convertBytes32ToAddress(bytes32 _bytes32) public pure returns (address) {\n        return address(uint160(uint256(_bytes32)));\n    }\n\n    /**\n     * @inheritdoc IInterchainClientV1\n     */\n    function convertAddressToBytes32(address _address) public pure returns (bytes32) {\n        return bytes32(uint256(uint160(_address)));\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[],"name":"appReceive","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint64","name":"chainID","type":"uint64"}],"name":"getLinkedIApp","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getOptimisticTimePeriod","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getReceivingModules","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getRequiredResponses","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getSendingModules","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"receiver","type":"bytes32"},{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"send","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint64[]","name":"chainIDs","type":"uint64[]"},{"internalType":"address[]","name":"linkedIApps","type":"address[]"},{"internalType":"address[]","name":"sendingModules","type":"address[]"},{"internalType":"address[]","name":"receivingModules","type":"address[]"},{"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"internalType":"uint64","name":"optimisticTimePeriod","type":"uint64"}],"name":"setAppConfig","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"appReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainID\",\"type\":\"uint64\"}],\"name\":\"getLinkedIApp\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOptimisticTimePeriod\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReceivingModules\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRequiredResponses\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSendingModules\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"receiver\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"send\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64[]\",\"name\":\"chainIDs\",\"type\":\"uint64[]\"},{\"internalType\":\"address[]\",\"name\":\"linkedIApps\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"sendingModules\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"receivingModules\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"optimisticTimePeriod\",\"type\":\"uint64\"}],\"name\":\"setAppConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"IInterchainApp\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0x982e9011e738d832d83545cccb9c0d49738847d637bb91992a6f611d678b844b\",\"urls\":[\"bzz-raw://6e484f8559b38a654ef0b91ea4bd7da1a17e1ca301762a382750e2af2d85aed7\",\"dweb:/ipfs/QmZz3158XFik6u5SJvaYdQrXpcM87h6aY2kf83ntcqD2sX\"]}},\"version\":1}"},"hashes":{"appReceive()":"7bcad630","getLinkedIApp(uint64)":"bfc849ee","getOptimisticTimePeriod()":"7c9abd3e","getReceivingModules()":"a45e107a","getRequiredResponses()":"f31b19a9","getSendingModules()":"ea13398f","send(bytes32,uint256,bytes)":"e1ef3b3f","setAppConfig(uint64[],address[],address[],address[],uint256,uint64)":"dd34f56a"}},"solidity/InterchainClientV1.sol:IInterchainClientV1":{"code":"0x","runtime-code":"0x","info":{"source":"pragma solidity =0.8.20 ^0.8.0 ^0.8.20;\n\n// contracts/interfaces/IInterchainApp.sol\n\ninterface IInterchainApp {\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory sendingModules,\n        address[] memory receivingModules,\n        uint256 requiredResponses,\n        uint64 optimisticTimePeriod\n    )\n        external;\n\n    function getLinkedIApp(uint64 chainID) external view returns (address);\n\n    function getSendingModules() external view returns (address[] memory);\n\n    function getReceivingModules() external view returns (address[] memory);\n\n    function getRequiredResponses() external view returns (uint256);\n\n    function getOptimisticTimePeriod() external view returns (uint64);\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable;\n\n    function appReceive() external;\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sets the address of the InterchainDB contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param _interchainDB The address of the InterchainDB contract.\n     */\n    function setInterchainDB(address _interchainDB) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param message The message being sent.\n     * @param srcModules The source modules involved in the message sending.\n     */\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        address[] calldata srcModules\n    )\n        external\n        payable;\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * @param transactionID The ID of the transaction being executed.\n     * @param transaction The transaction data.\n     */\n    function interchainExecute(bytes32 transactionID, bytes calldata transaction) external;\n\n    /**\n     * @notice Converts a bytes32 value to an address.\n     * @dev Useful for converting blockchain-specific identifiers to Ethereum addresses.\n     * @param _bytes32 The bytes32 value to convert.\n     * @return address The address obtained from the bytes32 value.\n     */\n    function convertBytes32ToAddress(bytes32 _bytes32) external pure returns (address);\n\n    /**\n     * @notice Converts an address to a bytes32 value.\n     * @dev Useful for converting Ethereum addresses to blockchain-specific identifiers.\n     * @param _address The address to convert.\n     * @return bytes32 The bytes32 representation of the address.\n     */\n    function convertAddressToBytes32(address _address) external pure returns (bytes32);\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase\n/// @param srcChainId   The chain id of the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param writerNonce  The nonce of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    bytes32 srcWriter;\n    uint256 writerNonce;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param srcWriter    The address of the writer on the local chain\n    /// @param writerNonce  The nonce of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        address srcWriter,\n        uint256 writerNonce,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            srcWriter: TypeCasts.addressToBytes32(srcWriter),\n            writerNonce: writerNonce,\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryId(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.srcWriter, entry.writerNonce));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param dataHash     The hash of the data written on the source chain\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 dataHash;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingDataHash, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(address writer, uint256 writerNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntry(bytes32 dataHash) external returns (uint256 writerNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param writer        The address of the writer on the source chain\n    /// @param writerNonce   The nonce of the writer on the source chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(\n        uint256 destChainId,\n        address writer,\n        uint256 writerNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 writerNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param writer       The address of the writer on this chain\n    /// @param writerNonce  The nonce of the writer's entry on this chain\n    function getEntry(address writer, uint256 writerNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the writer on this chain.\n    /// @param writer       The address of the writer on this chain\n    function getWriterNonce(address writer) external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, IInterchainClientV1 {\n    uint64 public clientNonce;\n    address public interchainDB;\n\n    // Chain ID =\u003e Bytes32 Address of src clients\n    mapping(uint256 =\u003e bytes32) linkedClients;\n\n    // TODO: Add permissioning\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint256 chainId, bytes32 client) public {\n        linkedClients[chainId] = client;\n    }\n\n    constructor() Ownable(msg.sender) {}\n\n    // @inheritdoc IInterchainClientV1\n    function setInterchainDB(address _interchainDB) public onlyOwner {\n        interchainDB = _interchainDB;\n    }\n\n    /**\n     * @notice Emitted when an interchain transaction is sent.\n     */\n    event InterchainTransactionSent(\n        bytes32 srcSender,\n        uint256 srcChainId,\n        bytes32 indexed dstReceiver,\n        uint256 indexed dstChainId,\n        bytes message,\n        uint64 nonce,\n        bytes32 indexed transactionId,\n        uint256 dbWriterNonce\n    );\n\n    /**\n     * @dev Represents an interchain transaction.\n     */\n    struct InterchainTransaction {\n        bytes32 srcSender;\n        uint256 srcChainId;\n        bytes32 dstReceiver;\n        uint256 dstChainId;\n        bytes message;\n        uint64 nonce;\n        bytes32 transactionId;\n        uint256 dbWriterNonce;\n    }\n\n    // TODO: Calculate Gas Pricing per module and charge fees\n    // TODO: Customizable Gas Limit for Execution\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        address[] calldata srcModules\n    )\n        public\n        payable\n    {\n        uint256 totalModuleFees = msg.value;\n        bytes32 sender = convertAddressToBytes32(msg.sender);\n        bytes32 transactionID = keccak256(abi.encode(sender, block.chainid, receiver, dstChainId, message, clientNonce));\n\n        uint256 dbWriterNonce = IInterchainDB(interchainDB).writeEntryWithVerification{value: totalModuleFees}(\n            dstChainId, transactionID, srcModules\n        );\n\n        emit InterchainTransactionSent(\n            sender, block.chainid, receiver, dstChainId, message, clientNonce, transactionID, dbWriterNonce\n        );\n        // Increment nonce for next message\n        clientNonce++;\n    }\n\n    // TODO: Gas Fee Consideration that is paid to executor\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(bytes32 transactionID, bytes calldata transaction) public {\n        // Steps to verify:\n        // 1. Call icDB.getEntry(linkedClients.srcChainId, transaction.dbWriterNonce)\n        // 2. Verify the entry hash vs bytes calldata provided\n        // 3. Check receiver's app dstModule configuration\n        // 4. Check receiver app's optimistic time period\n        // 5. Read module entry's based on receiver app dstModule config\n        // 6. Confirm module threshold is met\n        // 7. Check optimistic threshold set on app config\n        // 8. Execute the transaction, is optimistic period is met.\n\n        InterchainTransaction memory icTx = abi.decode(transaction, (InterchainTransaction));\n\n        // 1. Call icDB.getEntry(linkedClients.srcChainId, transaction.dbWriterNonce)\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            srcWriter: linkedClients[icTx.srcChainId],\n            writerNonce: icTx.dbWriterNonce,\n            dataHash: icTx.transactionId\n        });\n\n        bytes memory reconstructedID =\n            abi.encode(icTx.srcSender, icTx.srcChainId, icTx.dstReceiver, icTx.dstChainId, icTx.message, icTx.nonce);\n\n        // 2. Verify the entry hash vs bytes calldata provided\n        require(icEntry.dataHash == keccak256(reconstructedID), \"Invalid transaction ID\");\n\n        address receivingApp = convertBytes32ToAddress(icTx.dstReceiver);\n        // 3. Check receiver's app dstModule configuration\n        address[] memory approvedDstModules = IInterchainApp(receivingApp).getReceivingModules();\n\n        uint256 appRequiredResponses = IInterchainApp(receivingApp).getRequiredResponses();\n\n        // 4. Check receiver app's optimistic time period\n        uint256 optimisticTimePeriod = IInterchainApp(receivingApp).getOptimisticTimePeriod();\n\n        // 5. Read module entry's based on receiver app dstModule config\n        uint256[] memory moduleResponseTimestamps = new uint256[](approvedDstModules.length);\n\n        for (uint256 i = 0; i \u003c approvedDstModules.length; i++) {\n            moduleResponseTimestamps[i] = IInterchainDB(interchainDB).readEntry(approvedDstModules[i], icEntry);\n        }\n        // 6. Confirm module threshold is met\n        uint256 validResponses = 0;\n\n        for (uint256 i = 0; i \u003c moduleResponseTimestamps.length; i++) {\n            if (moduleResponseTimestamps[i] + optimisticTimePeriod \u003e= block.timestamp) {\n                validResponses++;\n            }\n        }\n\n        require(validResponses \u003e= appRequiredResponses, \"Not enough valid responses to meet the threshold\");\n\n        // 8. Execute the transaction, is optimistic period \u0026 valid responses is met.\n        IInterchainApp(receivingApp).appReceive();\n    }\n\n    // TODO: Seperate out into utils\n    /**\n     * @inheritdoc IInterchainClientV1\n     */\n    function convertBytes32ToAddress(bytes32 _bytes32) public pure returns (address) {\n        return address(uint160(uint256(_bytes32)));\n    }\n\n    /**\n     * @inheritdoc IInterchainClientV1\n     */\n    function convertAddressToBytes32(address _address) public pure returns (bytes32) {\n        return bytes32(uint256(uint160(_address)));\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"address","name":"_address","type":"address"}],"name":"convertAddressToBytes32","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_bytes32","type":"bytes32"}],"name":"convertBytes32ToAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionID","type":"bytes32"},{"internalType":"bytes","name":"transaction","type":"bytes"}],"name":"interchainExecute","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"receiver","type":"bytes32"},{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"bytes","name":"message","type":"bytes"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"interchainSend","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"_interchainDB","type":"address"}],"name":"setInterchainDB","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"bytes32","name":"client","type":"bytes32"}],"name":"setLinkedClient","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"convertAddressToBytes32(address)":{"notice":"Converts an address to a bytes32 value."},"convertBytes32ToAddress(bytes32)":{"notice":"Converts a bytes32 value to an address."},"interchainExecute(bytes32,bytes)":{"notice":"Executes a transaction that has been sent via the Interchain."},"interchainSend(bytes32,uint256,bytes,address[])":{"notice":"Sends a message to another chain via the Interchain Communication Protocol."},"setInterchainDB(address)":{"notice":"Sets the address of the InterchainDB contract."},"setLinkedClient(uint256,bytes32)":{"notice":"Sets the linked client for a specific chain ID."}},"version":1},"developerDoc":{"kind":"dev","methods":{"convertAddressToBytes32(address)":{"details":"Useful for converting Ethereum addresses to blockchain-specific identifiers.","params":{"_address":"The address to convert."},"returns":{"_0":"bytes32 The bytes32 representation of the address."}},"convertBytes32ToAddress(bytes32)":{"details":"Useful for converting blockchain-specific identifiers to Ethereum addresses.","params":{"_bytes32":"The bytes32 value to convert."},"returns":{"_0":"address The address obtained from the bytes32 value."}},"interchainExecute(bytes32,bytes)":{"details":"The transaction must have been previously sent and recorded.","params":{"transaction":"The transaction data.","transactionID":"The ID of the transaction being executed."}},"interchainSend(bytes32,uint256,bytes,address[])":{"details":"Charges a fee for the message, which is payable upon calling this function.","params":{"dstChainId":"The chain ID of the destination chain.","message":"The message being sent.","receiver":"The address of the receiver on the destination chain.","srcModules":"The source modules involved in the message sending."}},"setInterchainDB(address)":{"details":"Only callable by the contract owner or an authorized account.","params":{"_interchainDB":"The address of the InterchainDB contract."}},"setLinkedClient(uint256,bytes32)":{"details":"Stores the address of the linked client in a mapping with the chain ID as the key.","params":{"chainId":"The chain ID for which the client is being set.","client":"The address of the client being linked."}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"convertAddressToBytes32\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_bytes32\",\"type\":\"bytes32\"}],\"name\":\"convertBytes32ToAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"transaction\",\"type\":\"bytes\"}],\"name\":\"interchainExecute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"receiver\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"interchainSend\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_interchainDB\",\"type\":\"address\"}],\"name\":\"setInterchainDB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"client\",\"type\":\"bytes32\"}],\"name\":\"setLinkedClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"convertAddressToBytes32(address)\":{\"details\":\"Useful for converting Ethereum addresses to blockchain-specific identifiers.\",\"params\":{\"_address\":\"The address to convert.\"},\"returns\":{\"_0\":\"bytes32 The bytes32 representation of the address.\"}},\"convertBytes32ToAddress(bytes32)\":{\"details\":\"Useful for converting blockchain-specific identifiers to Ethereum addresses.\",\"params\":{\"_bytes32\":\"The bytes32 value to convert.\"},\"returns\":{\"_0\":\"address The address obtained from the bytes32 value.\"}},\"interchainExecute(bytes32,bytes)\":{\"details\":\"The transaction must have been previously sent and recorded.\",\"params\":{\"transaction\":\"The transaction data.\",\"transactionID\":\"The ID of the transaction being executed.\"}},\"interchainSend(bytes32,uint256,bytes,address[])\":{\"details\":\"Charges a fee for the message, which is payable upon calling this function.\",\"params\":{\"dstChainId\":\"The chain ID of the destination chain.\",\"message\":\"The message being sent.\",\"receiver\":\"The address of the receiver on the destination chain.\",\"srcModules\":\"The source modules involved in the message sending.\"}},\"setInterchainDB(address)\":{\"details\":\"Only callable by the contract owner or an authorized account.\",\"params\":{\"_interchainDB\":\"The address of the InterchainDB contract.\"}},\"setLinkedClient(uint256,bytes32)\":{\"details\":\"Stores the address of the linked client in a mapping with the chain ID as the key.\",\"params\":{\"chainId\":\"The chain ID for which the client is being set.\",\"client\":\"The address of the client being linked.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"convertAddressToBytes32(address)\":{\"notice\":\"Converts an address to a bytes32 value.\"},\"convertBytes32ToAddress(bytes32)\":{\"notice\":\"Converts a bytes32 value to an address.\"},\"interchainExecute(bytes32,bytes)\":{\"notice\":\"Executes a transaction that has been sent via the Interchain.\"},\"interchainSend(bytes32,uint256,bytes,address[])\":{\"notice\":\"Sends a message to another chain via the Interchain Communication Protocol.\"},\"setInterchainDB(address)\":{\"notice\":\"Sets the address of the InterchainDB contract.\"},\"setLinkedClient(uint256,bytes32)\":{\"notice\":\"Sets the linked client for a specific chain ID.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"IInterchainClientV1\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0x982e9011e738d832d83545cccb9c0d49738847d637bb91992a6f611d678b844b\",\"urls\":[\"bzz-raw://6e484f8559b38a654ef0b91ea4bd7da1a17e1ca301762a382750e2af2d85aed7\",\"dweb:/ipfs/QmZz3158XFik6u5SJvaYdQrXpcM87h6aY2kf83ntcqD2sX\"]}},\"version\":1}"},"hashes":{"convertAddressToBytes32(address)":"5893740e","convertBytes32ToAddress(bytes32)":"1efa2220","interchainExecute(bytes32,bytes)":"d3388b80","interchainSend(bytes32,uint256,bytes,address[])":"8366a109","setInterchainDB(address)":"b7ce2078","setLinkedClient(uint256,bytes32)":"f34234c8"}},"solidity/InterchainClientV1.sol:IInterchainDB":{"code":"0x","runtime-code":"0x","info":{"source":"pragma solidity =0.8.20 ^0.8.0 ^0.8.20;\n\n// contracts/interfaces/IInterchainApp.sol\n\ninterface IInterchainApp {\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory sendingModules,\n        address[] memory receivingModules,\n        uint256 requiredResponses,\n        uint64 optimisticTimePeriod\n    )\n        external;\n\n    function getLinkedIApp(uint64 chainID) external view returns (address);\n\n    function getSendingModules() external view returns (address[] memory);\n\n    function getReceivingModules() external view returns (address[] memory);\n\n    function getRequiredResponses() external view returns (uint256);\n\n    function getOptimisticTimePeriod() external view returns (uint64);\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable;\n\n    function appReceive() external;\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sets the address of the InterchainDB contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param _interchainDB The address of the InterchainDB contract.\n     */\n    function setInterchainDB(address _interchainDB) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param message The message being sent.\n     * @param srcModules The source modules involved in the message sending.\n     */\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        address[] calldata srcModules\n    )\n        external\n        payable;\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * @param transactionID The ID of the transaction being executed.\n     * @param transaction The transaction data.\n     */\n    function interchainExecute(bytes32 transactionID, bytes calldata transaction) external;\n\n    /**\n     * @notice Converts a bytes32 value to an address.\n     * @dev Useful for converting blockchain-specific identifiers to Ethereum addresses.\n     * @param _bytes32 The bytes32 value to convert.\n     * @return address The address obtained from the bytes32 value.\n     */\n    function convertBytes32ToAddress(bytes32 _bytes32) external pure returns (address);\n\n    /**\n     * @notice Converts an address to a bytes32 value.\n     * @dev Useful for converting Ethereum addresses to blockchain-specific identifiers.\n     * @param _address The address to convert.\n     * @return bytes32 The bytes32 representation of the address.\n     */\n    function convertAddressToBytes32(address _address) external pure returns (bytes32);\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase\n/// @param srcChainId   The chain id of the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param writerNonce  The nonce of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    bytes32 srcWriter;\n    uint256 writerNonce;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param srcWriter    The address of the writer on the local chain\n    /// @param writerNonce  The nonce of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        address srcWriter,\n        uint256 writerNonce,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            srcWriter: TypeCasts.addressToBytes32(srcWriter),\n            writerNonce: writerNonce,\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryId(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.srcWriter, entry.writerNonce));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param dataHash     The hash of the data written on the source chain\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 dataHash;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingDataHash, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(address writer, uint256 writerNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntry(bytes32 dataHash) external returns (uint256 writerNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param writer        The address of the writer on the source chain\n    /// @param writerNonce   The nonce of the writer on the source chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(\n        uint256 destChainId,\n        address writer,\n        uint256 writerNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 writerNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param writer       The address of the writer on this chain\n    /// @param writerNonce  The nonce of the writer's entry on this chain\n    function getEntry(address writer, uint256 writerNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the writer on this chain.\n    /// @param writer       The address of the writer on this chain\n    function getWriterNonce(address writer) external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, IInterchainClientV1 {\n    uint64 public clientNonce;\n    address public interchainDB;\n\n    // Chain ID =\u003e Bytes32 Address of src clients\n    mapping(uint256 =\u003e bytes32) linkedClients;\n\n    // TODO: Add permissioning\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint256 chainId, bytes32 client) public {\n        linkedClients[chainId] = client;\n    }\n\n    constructor() Ownable(msg.sender) {}\n\n    // @inheritdoc IInterchainClientV1\n    function setInterchainDB(address _interchainDB) public onlyOwner {\n        interchainDB = _interchainDB;\n    }\n\n    /**\n     * @notice Emitted when an interchain transaction is sent.\n     */\n    event InterchainTransactionSent(\n        bytes32 srcSender,\n        uint256 srcChainId,\n        bytes32 indexed dstReceiver,\n        uint256 indexed dstChainId,\n        bytes message,\n        uint64 nonce,\n        bytes32 indexed transactionId,\n        uint256 dbWriterNonce\n    );\n\n    /**\n     * @dev Represents an interchain transaction.\n     */\n    struct InterchainTransaction {\n        bytes32 srcSender;\n        uint256 srcChainId;\n        bytes32 dstReceiver;\n        uint256 dstChainId;\n        bytes message;\n        uint64 nonce;\n        bytes32 transactionId;\n        uint256 dbWriterNonce;\n    }\n\n    // TODO: Calculate Gas Pricing per module and charge fees\n    // TODO: Customizable Gas Limit for Execution\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        address[] calldata srcModules\n    )\n        public\n        payable\n    {\n        uint256 totalModuleFees = msg.value;\n        bytes32 sender = convertAddressToBytes32(msg.sender);\n        bytes32 transactionID = keccak256(abi.encode(sender, block.chainid, receiver, dstChainId, message, clientNonce));\n\n        uint256 dbWriterNonce = IInterchainDB(interchainDB).writeEntryWithVerification{value: totalModuleFees}(\n            dstChainId, transactionID, srcModules\n        );\n\n        emit InterchainTransactionSent(\n            sender, block.chainid, receiver, dstChainId, message, clientNonce, transactionID, dbWriterNonce\n        );\n        // Increment nonce for next message\n        clientNonce++;\n    }\n\n    // TODO: Gas Fee Consideration that is paid to executor\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(bytes32 transactionID, bytes calldata transaction) public {\n        // Steps to verify:\n        // 1. Call icDB.getEntry(linkedClients.srcChainId, transaction.dbWriterNonce)\n        // 2. Verify the entry hash vs bytes calldata provided\n        // 3. Check receiver's app dstModule configuration\n        // 4. Check receiver app's optimistic time period\n        // 5. Read module entry's based on receiver app dstModule config\n        // 6. Confirm module threshold is met\n        // 7. Check optimistic threshold set on app config\n        // 8. Execute the transaction, is optimistic period is met.\n\n        InterchainTransaction memory icTx = abi.decode(transaction, (InterchainTransaction));\n\n        // 1. Call icDB.getEntry(linkedClients.srcChainId, transaction.dbWriterNonce)\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            srcWriter: linkedClients[icTx.srcChainId],\n            writerNonce: icTx.dbWriterNonce,\n            dataHash: icTx.transactionId\n        });\n\n        bytes memory reconstructedID =\n            abi.encode(icTx.srcSender, icTx.srcChainId, icTx.dstReceiver, icTx.dstChainId, icTx.message, icTx.nonce);\n\n        // 2. Verify the entry hash vs bytes calldata provided\n        require(icEntry.dataHash == keccak256(reconstructedID), \"Invalid transaction ID\");\n\n        address receivingApp = convertBytes32ToAddress(icTx.dstReceiver);\n        // 3. Check receiver's app dstModule configuration\n        address[] memory approvedDstModules = IInterchainApp(receivingApp).getReceivingModules();\n\n        uint256 appRequiredResponses = IInterchainApp(receivingApp).getRequiredResponses();\n\n        // 4. Check receiver app's optimistic time period\n        uint256 optimisticTimePeriod = IInterchainApp(receivingApp).getOptimisticTimePeriod();\n\n        // 5. Read module entry's based on receiver app dstModule config\n        uint256[] memory moduleResponseTimestamps = new uint256[](approvedDstModules.length);\n\n        for (uint256 i = 0; i \u003c approvedDstModules.length; i++) {\n            moduleResponseTimestamps[i] = IInterchainDB(interchainDB).readEntry(approvedDstModules[i], icEntry);\n        }\n        // 6. Confirm module threshold is met\n        uint256 validResponses = 0;\n\n        for (uint256 i = 0; i \u003c moduleResponseTimestamps.length; i++) {\n            if (moduleResponseTimestamps[i] + optimisticTimePeriod \u003e= block.timestamp) {\n                validResponses++;\n            }\n        }\n\n        require(validResponses \u003e= appRequiredResponses, \"Not enough valid responses to meet the threshold\");\n\n        // 8. Execute the transaction, is optimistic period \u0026 valid responses is met.\n        IInterchainApp(receivingApp).appReceive();\n    }\n\n    // TODO: Seperate out into utils\n    /**\n     * @inheritdoc IInterchainClientV1\n     */\n    function convertBytes32ToAddress(bytes32 _bytes32) public pure returns (address) {\n        return address(uint160(uint256(_bytes32)));\n    }\n\n    /**\n     * @inheritdoc IInterchainClientV1\n     */\n    function convertAddressToBytes32(address _address) public pure returns (bytes32) {\n        return bytes32(uint256(uint160(_address)));\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"bytes32","name":"existingDataHash","type":"bytes32"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"uint256","name":"writerNonce","type":"uint256"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"newEntry","type":"tuple"}],"name":"InterchainDB__ConflictingEntries","type":"error"},{"inputs":[{"internalType":"address","name":"writer","type":"address"},{"internalType":"uint256","name":"writerNonce","type":"uint256"}],"name":"InterchainDB__EntryDoesNotExist","type":"error"},{"inputs":[{"internalType":"uint256","name":"actualFee","type":"uint256"},{"internalType":"uint256","name":"expectedFee","type":"uint256"}],"name":"InterchainDB__IncorrectFeeAmount","type":"error"},{"inputs":[],"name":"InterchainDB__NoModulesSpecified","type":"error"},{"inputs":[],"name":"InterchainDB__SameChainId","type":"error"},{"inputs":[{"internalType":"address","name":"writer","type":"address"},{"internalType":"uint256","name":"writerNonce","type":"uint256"}],"name":"getEntry","outputs":[{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"uint256","name":"writerNonce","type":"uint256"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"getInterchainFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"writer","type":"address"}],"name":"getWriterNonce","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"dstModule","type":"address"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"uint256","name":"writerNonce","type":"uint256"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"entry","type":"tuple"}],"name":"readEntry","outputs":[{"internalType":"uint256","name":"moduleVerifiedAt","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"internalType":"address","name":"writer","type":"address"},{"internalType":"uint256","name":"writerNonce","type":"uint256"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"requestVerification","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"uint256","name":"writerNonce","type":"uint256"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"entry","type":"tuple"}],"name":"verifyEntry","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"name":"writeEntry","outputs":[{"internalType":"uint256","name":"writerNonce","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"writeEntryWithVerification","outputs":[{"internalType":"uint256","name":"writerNonce","type":"uint256"}],"stateMutability":"payable","type":"function"}],"userDoc":{"kind":"user","methods":{"getEntry(address,uint256)":{"notice":"Get the Interchain Entry by the writer and the writer nonce."},"getInterchainFee(uint256,address[])":{"notice":"Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain using the provided Interchain Modules."},"getWriterNonce(address)":{"notice":"Get the nonce of the writer on this chain."},"readEntry(address,(uint256,bytes32,uint256,bytes32))":{"notice":"Read the data written on specific source chain by a specific writer, and verify it on the destination chain using the provided Interchain Module. Note: returned zero value indicates that the module has not verified the entry."},"requestVerification(uint256,address,uint256,address[])":{"notice":"Request the given Interchain Modules to verify the already written entry on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: this method is permissionless, and anyone can request verification for any entry."},"verifyEntry((uint256,bytes32,uint256,bytes32))":{"notice":"Allows the Interchain Module to verify the entry coming from a remote source chain."},"writeEntry(bytes32)":{"notice":"Write data to the Interchain DataBase as a new entry. Note: there are no guarantees that this entry will be available for reading on any of the remote chains. Use `verifyEntry` to ensure that the entry is available for reading on the destination chain."},"writeEntryWithVerification(uint256,bytes32,address[])":{"notice":"Write data to the Interchain DataBase, and request the given Interchain Modules to verify it on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: additional verification for the same entry could be later done using `requestVerification`."}},"version":1},"developerDoc":{"kind":"dev","methods":{"getEntry(address,uint256)":{"details":"Will revert if the entry with the given nonce does not exist.","params":{"writer":"The address of the writer on this chain","writerNonce":"The nonce of the writer's entry on this chain"}},"getInterchainFee(uint256,address[])":{"details":"Will revert if the empty array of modules is provided.","params":{"destChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"}},"getWriterNonce(address)":{"params":{"writer":"The address of the writer on this chain"}},"readEntry(address,(uint256,bytes32,uint256,bytes32))":{"params":{"dstModule":"The destination chain addresses of the Interchain Modules to use for verification","entry":"The Interchain Entry to read"},"returns":{"moduleVerifiedAt":"  The block timestamp at which the entry was verified by the module,                             or zero if the module has not verified the entry."}},"requestVerification(uint256,address,uint256,address[])":{"details":"Will revert if the entry with the given nonce does not exist.","params":{"destChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification","writer":"The address of the writer on the source chain","writerNonce":"The nonce of the writer on the source chain"}},"verifyEntry((uint256,bytes32,uint256,bytes32))":{"params":{"entry":"The Interchain Entry to confirm"}},"writeEntry(bytes32)":{"params":{"dataHash":"The hash of the data to be written to the Interchain DataBase as a new entry"},"returns":{"writerNonce":"The writer-specific nonce of the written entry"}},"writeEntryWithVerification(uint256,bytes32,address[])":{"details":"Will revert if the empty array of modules is provided.","params":{"dataHash":"The hash of the data to be written to the Interchain DataBase as a new entry","destChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"},"returns":{"writerNonce":"The writer-specific nonce of the written entry"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"existingDataHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"newEntry\",\"type\":\"tuple\"}],\"name\":\"InterchainDB__ConflictingEntries\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"writer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__EntryDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actualFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedFee\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__IncorrectFeeAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainDB__NoModulesSpecified\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainDB__SameChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"writer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"}],\"name\":\"getEntry\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"getInterchainFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"writer\",\"type\":\"address\"}],\"name\":\"getWriterNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dstModule\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"entry\",\"type\":\"tuple\"}],\"name\":\"readEntry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"moduleVerifiedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"writer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"requestVerification\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"entry\",\"type\":\"tuple\"}],\"name\":\"verifyEntry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"writeEntry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"writeEntryWithVerification\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getEntry(address,uint256)\":{\"details\":\"Will revert if the entry with the given nonce does not exist.\",\"params\":{\"writer\":\"The address of the writer on this chain\",\"writerNonce\":\"The nonce of the writer's entry on this chain\"}},\"getInterchainFee(uint256,address[])\":{\"details\":\"Will revert if the empty array of modules is provided.\",\"params\":{\"destChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"}},\"getWriterNonce(address)\":{\"params\":{\"writer\":\"The address of the writer on this chain\"}},\"readEntry(address,(uint256,bytes32,uint256,bytes32))\":{\"params\":{\"dstModule\":\"The destination chain addresses of the Interchain Modules to use for verification\",\"entry\":\"The Interchain Entry to read\"},\"returns\":{\"moduleVerifiedAt\":\"  The block timestamp at which the entry was verified by the module,                             or zero if the module has not verified the entry.\"}},\"requestVerification(uint256,address,uint256,address[])\":{\"details\":\"Will revert if the entry with the given nonce does not exist.\",\"params\":{\"destChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\",\"writer\":\"The address of the writer on the source chain\",\"writerNonce\":\"The nonce of the writer on the source chain\"}},\"verifyEntry((uint256,bytes32,uint256,bytes32))\":{\"params\":{\"entry\":\"The Interchain Entry to confirm\"}},\"writeEntry(bytes32)\":{\"params\":{\"dataHash\":\"The hash of the data to be written to the Interchain DataBase as a new entry\"},\"returns\":{\"writerNonce\":\"The writer-specific nonce of the written entry\"}},\"writeEntryWithVerification(uint256,bytes32,address[])\":{\"details\":\"Will revert if the empty array of modules is provided.\",\"params\":{\"dataHash\":\"The hash of the data to be written to the Interchain DataBase as a new entry\",\"destChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"},\"returns\":{\"writerNonce\":\"The writer-specific nonce of the written entry\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getEntry(address,uint256)\":{\"notice\":\"Get the Interchain Entry by the writer and the writer nonce.\"},\"getInterchainFee(uint256,address[])\":{\"notice\":\"Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain using the provided Interchain Modules.\"},\"getWriterNonce(address)\":{\"notice\":\"Get the nonce of the writer on this chain.\"},\"readEntry(address,(uint256,bytes32,uint256,bytes32))\":{\"notice\":\"Read the data written on specific source chain by a specific writer, and verify it on the destination chain using the provided Interchain Module. Note: returned zero value indicates that the module has not verified the entry.\"},\"requestVerification(uint256,address,uint256,address[])\":{\"notice\":\"Request the given Interchain Modules to verify the already written entry on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: this method is permissionless, and anyone can request verification for any entry.\"},\"verifyEntry((uint256,bytes32,uint256,bytes32))\":{\"notice\":\"Allows the Interchain Module to verify the entry coming from a remote source chain.\"},\"writeEntry(bytes32)\":{\"notice\":\"Write data to the Interchain DataBase as a new entry. Note: there are no guarantees that this entry will be available for reading on any of the remote chains. Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\"},\"writeEntryWithVerification(uint256,bytes32,address[])\":{\"notice\":\"Write data to the Interchain DataBase, and request the given Interchain Modules to verify it on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: additional verification for the same entry could be later done using `requestVerification`.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"IInterchainDB\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0x982e9011e738d832d83545cccb9c0d49738847d637bb91992a6f611d678b844b\",\"urls\":[\"bzz-raw://6e484f8559b38a654ef0b91ea4bd7da1a17e1ca301762a382750e2af2d85aed7\",\"dweb:/ipfs/QmZz3158XFik6u5SJvaYdQrXpcM87h6aY2kf83ntcqD2sX\"]}},\"version\":1}"},"hashes":{"getEntry(address,uint256)":"b8a740e0","getInterchainFee(uint256,address[])":"fc7686ec","getWriterNonce(address)":"4a30a686","readEntry(address,(uint256,bytes32,uint256,bytes32))":"d48588e0","requestVerification(uint256,address,uint256,address[])":"b4f16bae","verifyEntry((uint256,bytes32,uint256,bytes32))":"9cbc6dd5","writeEntry(bytes32)":"2ad8c706","writeEntryWithVerification(uint256,bytes32,address[])":"67c769af"}},"solidity/InterchainClientV1.sol:InterchainClientV1":{"code":"0x608060405234801561001057600080fd5b50338061003757604051631e4fbdf760e01b81526000600482015260240160405180910390fd5b61004081610046565b50610096565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b611298806100a56000396000f3fe6080604052600436106100bc5760003560e01c80638366a10911610074578063d3388b801161004e578063d3388b801461023f578063f2fde38b1461025f578063f34234c81461027f57600080fd5b80638366a109146101e15780638da5cb5b146101f4578063b7ce20781461021f57600080fd5b80631efa2220116100a55780631efa22201461016a5780635893740e14610188578063715018a6146101ca57600080fd5b80630d898416146100c15780630e785ce014610118575b600080fd5b3480156100cd57600080fd5b506000546100fa9074010000000000000000000000000000000000000000900467ffffffffffffffff1681565b60405167ffffffffffffffff90911681526020015b60405180910390f35b34801561012457600080fd5b506001546101459073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200161010f565b34801561017657600080fd5b50610145610185366004610b5c565b90565b34801561019457600080fd5b506101bc6101a3366004610b97565b73ffffffffffffffffffffffffffffffffffffffff1690565b60405190815260200161010f565b3480156101d657600080fd5b506101df6102ac565b005b6101df6101ef366004610c04565b6102c0565b34801561020057600080fd5b5060005473ffffffffffffffffffffffffffffffffffffffff16610145565b34801561022b57600080fd5b506101df61023a366004610b97565b610486565b34801561024b57600080fd5b506101df61025a366004610cb6565b6104d5565b34801561026b57600080fd5b506101df61027a366004610b97565b610a30565b34801561028b57600080fd5b506101df61029a366004610d02565b60009182526002602052604090912055565b6102b4610a94565b6102be6000610ae7565b565b6000805460405134923392909161030891849146918d918d918d918d9174010000000000000000000000000000000000000000900467ffffffffffffffff1690602001610d4f565b60408051601f198184030181529082905280516020909101206001547f67c769af00000000000000000000000000000000000000000000000000000000835290925060009173ffffffffffffffffffffffffffffffffffffffff909116906367c769af908690610382908d9087908c908c90600401610d99565b60206040518083038185885af11580156103a0573d6000803e3d6000fd5b50505050506040513d601f19601f820116820180604052508101906103c59190610e05565b905081898b7ff679da022706ad89d2486ce3bf6cba510d619af7c1b2f6799637ed085f9287d186468d8d600060149054906101000a900467ffffffffffffffff168960405161041996959493929190610e1e565b60405180910390a46000805474010000000000000000000000000000000000000000900467ffffffffffffffff1690601461045383610e8c565b91906101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055505050505050505050505050565b61048e610a94565b600180547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b60006104e382840184610fd3565b9050600060405180608001604052808360200151815260200160026000856020015181526020019081526020016000205481526020018360e0015181526020018360c0015181525090506000826000015183602001518460400151856060015186608001518760a0015160405160200161056296959493929190611091565b604051602081830303815290604052905080805190602001208260600151146105ec576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f496e76616c6964207472616e73616374696f6e2049440000000000000000000060448201526064015b60405180910390fd5b60006105f9846040015190565b905060008173ffffffffffffffffffffffffffffffffffffffff1663a45e107a6040518163ffffffff1660e01b8152600401600060405180830381865afa158015610648573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526106709190810190611113565b905060008273ffffffffffffffffffffffffffffffffffffffff1663f31b19a96040518163ffffffff1660e01b8152600401602060405180830381865afa1580156106bf573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106e39190610e05565b905060008373ffffffffffffffffffffffffffffffffffffffff16637c9abd3e6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610732573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061075691906111c5565b67ffffffffffffffff1690506000835167ffffffffffffffff81111561077e5761077e610eb3565b6040519080825280602002602001820160405280156107a7578160200160208202803683370190505b50905060005b84518110156108d857600154855173ffffffffffffffffffffffffffffffffffffffff9091169063d48588e0908790849081106107ec576107ec6111e2565b602090810291909101810151604080517fffffffff0000000000000000000000000000000000000000000000000000000060e086901b16815273ffffffffffffffffffffffffffffffffffffffff90921660048301528c516024830152918c01516044820152908b0151606482015260608b0151608482015260a401602060405180830381865afa158015610885573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108a99190610e05565b8282815181106108bb576108bb6111e2565b6020908102919091010152806108d081611211565b9150506107ad565b506000805b82518110156109315742848483815181106108fa576108fa6111e2565b602002602001015161090c9190611249565b1061091f578161091b81611211565b9250505b8061092981611211565b9150506108dd565b50838110156109c2576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603060248201527f4e6f7420656e6f7567682076616c696420726573706f6e73657320746f206d6560448201527f657420746865207468726573686f6c640000000000000000000000000000000060648201526084016105e3565b8573ffffffffffffffffffffffffffffffffffffffff16637bcad6306040518163ffffffff1660e01b8152600401600060405180830381600087803b158015610a0a57600080fd5b505af1158015610a1e573d6000803e3d6000fd5b50505050505050505050505050505050565b610a38610a94565b73ffffffffffffffffffffffffffffffffffffffff8116610a88576040517f1e4fbdf7000000000000000000000000000000000000000000000000000000008152600060048201526024016105e3565b610a9181610ae7565b50565b60005473ffffffffffffffffffffffffffffffffffffffff1633146102be576040517f118cdaa70000000000000000000000000000000000000000000000000000000081523360048201526024016105e3565b6000805473ffffffffffffffffffffffffffffffffffffffff8381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b600060208284031215610b6e57600080fd5b5035919050565b73ffffffffffffffffffffffffffffffffffffffff81168114610a9157600080fd5b600060208284031215610ba957600080fd5b8135610bb481610b75565b9392505050565b60008083601f840112610bcd57600080fd5b50813567ffffffffffffffff811115610be557600080fd5b602083019150836020828501011115610bfd57600080fd5b9250929050565b60008060008060008060808789031215610c1d57600080fd5b8635955060208701359450604087013567ffffffffffffffff80821115610c4357600080fd5b610c4f8a838b01610bbb565b90965094506060890135915080821115610c6857600080fd5b818901915089601f830112610c7c57600080fd5b813581811115610c8b57600080fd5b8a60208260051b8501011115610ca057600080fd5b6020830194508093505050509295509295509295565b600080600060408486031215610ccb57600080fd5b83359250602084013567ffffffffffffffff811115610ce957600080fd5b610cf586828701610bbb565b9497909650939450505050565b60008060408385031215610d1557600080fd5b50508035926020909101359150565b818352818160208501375060006020828401015260006020601f19601f840116840101905092915050565b87815286602082015285604082015284606082015260c060808201526000610d7b60c083018587610d24565b905067ffffffffffffffff831660a083015298975050505050505050565b84815260208082018590526060604083018190528201839052600090849060808401835b86811015610df8578335610dd081610b75565b73ffffffffffffffffffffffffffffffffffffffff1682529282019290820190600101610dbd565b5098975050505050505050565b600060208284031215610e1757600080fd5b5051919050565b86815285602082015260a060408201526000610e3e60a083018688610d24565b67ffffffffffffffff9490941660608301525060800152949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600067ffffffffffffffff808316818103610ea957610ea9610e5d565b6001019392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051610100810167ffffffffffffffff81118282101715610f0657610f06610eb3565b60405290565b604051601f8201601f1916810167ffffffffffffffff81118282101715610f3557610f35610eb3565b604052919050565b600082601f830112610f4e57600080fd5b813567ffffffffffffffff811115610f6857610f68610eb3565b610f7b6020601f19601f84011601610f0c565b818152846020838601011115610f9057600080fd5b816020850160208301376000918101602001919091529392505050565b67ffffffffffffffff81168114610a9157600080fd5b8035610fce81610fad565b919050565b600060208284031215610fe557600080fd5b813567ffffffffffffffff80821115610ffd57600080fd5b90830190610100828603121561101257600080fd5b61101a610ee2565b8235815260208301356020820152604083013560408201526060830135606082015260808301358281111561104e57600080fd5b61105a87828601610f3d565b60808301525061106c60a08401610fc3565b60a082015260c083013560c082015260e083013560e082015280935050505092915050565b86815260006020878184015286604084015285606084015260c0608084015284518060c085015260005b818110156110d75786810183015185820160e0015282016110bb565b50600060e0828601015260e0601f19601f8301168501019250505061110860a083018467ffffffffffffffff169052565b979650505050505050565b6000602080838503121561112657600080fd5b825167ffffffffffffffff8082111561113e57600080fd5b818501915085601f83011261115257600080fd5b81518181111561116457611164610eb3565b8060051b9150611175848301610f0c565b818152918301840191848101908884111561118f57600080fd5b938501935b838510156111b957845192506111a983610b75565b8282529385019390850190611194565b98975050505050505050565b6000602082840312156111d757600080fd5b8151610bb481610fad565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361124257611242610e5d565b5060010190565b8082018082111561125c5761125c610e5d565b9291505056fea2646970667358221220deb17baf20f7e8ce8635f4a7b487f8fccc999d99fa0ac55fadf98d9ba40105ae64736f6c63430008140033","runtime-code":"0x6080604052600436106100bc5760003560e01c80638366a10911610074578063d3388b801161004e578063d3388b801461023f578063f2fde38b1461025f578063f34234c81461027f57600080fd5b80638366a109146101e15780638da5cb5b146101f4578063b7ce20781461021f57600080fd5b80631efa2220116100a55780631efa22201461016a5780635893740e14610188578063715018a6146101ca57600080fd5b80630d898416146100c15780630e785ce014610118575b600080fd5b3480156100cd57600080fd5b506000546100fa9074010000000000000000000000000000000000000000900467ffffffffffffffff1681565b60405167ffffffffffffffff90911681526020015b60405180910390f35b34801561012457600080fd5b506001546101459073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200161010f565b34801561017657600080fd5b50610145610185366004610b5c565b90565b34801561019457600080fd5b506101bc6101a3366004610b97565b73ffffffffffffffffffffffffffffffffffffffff1690565b60405190815260200161010f565b3480156101d657600080fd5b506101df6102ac565b005b6101df6101ef366004610c04565b6102c0565b34801561020057600080fd5b5060005473ffffffffffffffffffffffffffffffffffffffff16610145565b34801561022b57600080fd5b506101df61023a366004610b97565b610486565b34801561024b57600080fd5b506101df61025a366004610cb6565b6104d5565b34801561026b57600080fd5b506101df61027a366004610b97565b610a30565b34801561028b57600080fd5b506101df61029a366004610d02565b60009182526002602052604090912055565b6102b4610a94565b6102be6000610ae7565b565b6000805460405134923392909161030891849146918d918d918d918d9174010000000000000000000000000000000000000000900467ffffffffffffffff1690602001610d4f565b60408051601f198184030181529082905280516020909101206001547f67c769af00000000000000000000000000000000000000000000000000000000835290925060009173ffffffffffffffffffffffffffffffffffffffff909116906367c769af908690610382908d9087908c908c90600401610d99565b60206040518083038185885af11580156103a0573d6000803e3d6000fd5b50505050506040513d601f19601f820116820180604052508101906103c59190610e05565b905081898b7ff679da022706ad89d2486ce3bf6cba510d619af7c1b2f6799637ed085f9287d186468d8d600060149054906101000a900467ffffffffffffffff168960405161041996959493929190610e1e565b60405180910390a46000805474010000000000000000000000000000000000000000900467ffffffffffffffff1690601461045383610e8c565b91906101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055505050505050505050505050565b61048e610a94565b600180547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b60006104e382840184610fd3565b9050600060405180608001604052808360200151815260200160026000856020015181526020019081526020016000205481526020018360e0015181526020018360c0015181525090506000826000015183602001518460400151856060015186608001518760a0015160405160200161056296959493929190611091565b604051602081830303815290604052905080805190602001208260600151146105ec576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f496e76616c6964207472616e73616374696f6e2049440000000000000000000060448201526064015b60405180910390fd5b60006105f9846040015190565b905060008173ffffffffffffffffffffffffffffffffffffffff1663a45e107a6040518163ffffffff1660e01b8152600401600060405180830381865afa158015610648573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526106709190810190611113565b905060008273ffffffffffffffffffffffffffffffffffffffff1663f31b19a96040518163ffffffff1660e01b8152600401602060405180830381865afa1580156106bf573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106e39190610e05565b905060008373ffffffffffffffffffffffffffffffffffffffff16637c9abd3e6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610732573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061075691906111c5565b67ffffffffffffffff1690506000835167ffffffffffffffff81111561077e5761077e610eb3565b6040519080825280602002602001820160405280156107a7578160200160208202803683370190505b50905060005b84518110156108d857600154855173ffffffffffffffffffffffffffffffffffffffff9091169063d48588e0908790849081106107ec576107ec6111e2565b602090810291909101810151604080517fffffffff0000000000000000000000000000000000000000000000000000000060e086901b16815273ffffffffffffffffffffffffffffffffffffffff90921660048301528c516024830152918c01516044820152908b0151606482015260608b0151608482015260a401602060405180830381865afa158015610885573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108a99190610e05565b8282815181106108bb576108bb6111e2565b6020908102919091010152806108d081611211565b9150506107ad565b506000805b82518110156109315742848483815181106108fa576108fa6111e2565b602002602001015161090c9190611249565b1061091f578161091b81611211565b9250505b8061092981611211565b9150506108dd565b50838110156109c2576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603060248201527f4e6f7420656e6f7567682076616c696420726573706f6e73657320746f206d6560448201527f657420746865207468726573686f6c640000000000000000000000000000000060648201526084016105e3565b8573ffffffffffffffffffffffffffffffffffffffff16637bcad6306040518163ffffffff1660e01b8152600401600060405180830381600087803b158015610a0a57600080fd5b505af1158015610a1e573d6000803e3d6000fd5b50505050505050505050505050505050565b610a38610a94565b73ffffffffffffffffffffffffffffffffffffffff8116610a88576040517f1e4fbdf7000000000000000000000000000000000000000000000000000000008152600060048201526024016105e3565b610a9181610ae7565b50565b60005473ffffffffffffffffffffffffffffffffffffffff1633146102be576040517f118cdaa70000000000000000000000000000000000000000000000000000000081523360048201526024016105e3565b6000805473ffffffffffffffffffffffffffffffffffffffff8381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b600060208284031215610b6e57600080fd5b5035919050565b73ffffffffffffffffffffffffffffffffffffffff81168114610a9157600080fd5b600060208284031215610ba957600080fd5b8135610bb481610b75565b9392505050565b60008083601f840112610bcd57600080fd5b50813567ffffffffffffffff811115610be557600080fd5b602083019150836020828501011115610bfd57600080fd5b9250929050565b60008060008060008060808789031215610c1d57600080fd5b8635955060208701359450604087013567ffffffffffffffff80821115610c4357600080fd5b610c4f8a838b01610bbb565b90965094506060890135915080821115610c6857600080fd5b818901915089601f830112610c7c57600080fd5b813581811115610c8b57600080fd5b8a60208260051b8501011115610ca057600080fd5b6020830194508093505050509295509295509295565b600080600060408486031215610ccb57600080fd5b83359250602084013567ffffffffffffffff811115610ce957600080fd5b610cf586828701610bbb565b9497909650939450505050565b60008060408385031215610d1557600080fd5b50508035926020909101359150565b818352818160208501375060006020828401015260006020601f19601f840116840101905092915050565b87815286602082015285604082015284606082015260c060808201526000610d7b60c083018587610d24565b905067ffffffffffffffff831660a083015298975050505050505050565b84815260208082018590526060604083018190528201839052600090849060808401835b86811015610df8578335610dd081610b75565b73ffffffffffffffffffffffffffffffffffffffff1682529282019290820190600101610dbd565b5098975050505050505050565b600060208284031215610e1757600080fd5b5051919050565b86815285602082015260a060408201526000610e3e60a083018688610d24565b67ffffffffffffffff9490941660608301525060800152949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600067ffffffffffffffff808316818103610ea957610ea9610e5d565b6001019392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051610100810167ffffffffffffffff81118282101715610f0657610f06610eb3565b60405290565b604051601f8201601f1916810167ffffffffffffffff81118282101715610f3557610f35610eb3565b604052919050565b600082601f830112610f4e57600080fd5b813567ffffffffffffffff811115610f6857610f68610eb3565b610f7b6020601f19601f84011601610f0c565b818152846020838601011115610f9057600080fd5b816020850160208301376000918101602001919091529392505050565b67ffffffffffffffff81168114610a9157600080fd5b8035610fce81610fad565b919050565b600060208284031215610fe557600080fd5b813567ffffffffffffffff80821115610ffd57600080fd5b90830190610100828603121561101257600080fd5b61101a610ee2565b8235815260208301356020820152604083013560408201526060830135606082015260808301358281111561104e57600080fd5b61105a87828601610f3d565b60808301525061106c60a08401610fc3565b60a082015260c083013560c082015260e083013560e082015280935050505092915050565b86815260006020878184015286604084015285606084015260c0608084015284518060c085015260005b818110156110d75786810183015185820160e0015282016110bb565b50600060e0828601015260e0601f19601f8301168501019250505061110860a083018467ffffffffffffffff169052565b979650505050505050565b6000602080838503121561112657600080fd5b825167ffffffffffffffff8082111561113e57600080fd5b818501915085601f83011261115257600080fd5b81518181111561116457611164610eb3565b8060051b9150611175848301610f0c565b818152918301840191848101908884111561118f57600080fd5b938501935b838510156111b957845192506111a983610b75565b8282529385019390850190611194565b98975050505050505050565b6000602082840312156111d757600080fd5b8151610bb481610fad565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361124257611242610e5d565b5060010190565b8082018082111561125c5761125c610e5d565b9291505056fea2646970667358221220deb17baf20f7e8ce8635f4a7b487f8fccc999d99fa0ac55fadf98d9ba40105ae64736f6c63430008140033","info":{"source":"pragma solidity =0.8.20 ^0.8.0 ^0.8.20;\n\n// contracts/interfaces/IInterchainApp.sol\n\ninterface IInterchainApp {\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory sendingModules,\n        address[] memory receivingModules,\n        uint256 requiredResponses,\n        uint64 optimisticTimePeriod\n    )\n        external;\n\n    function getLinkedIApp(uint64 chainID) external view returns (address);\n\n    function getSendingModules() external view returns (address[] memory);\n\n    function getReceivingModules() external view returns (address[] memory);\n\n    function getRequiredResponses() external view returns (uint256);\n\n    function getOptimisticTimePeriod() external view returns (uint64);\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable;\n\n    function appReceive() external;\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sets the address of the InterchainDB contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param _interchainDB The address of the InterchainDB contract.\n     */\n    function setInterchainDB(address _interchainDB) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param message The message being sent.\n     * @param srcModules The source modules involved in the message sending.\n     */\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        address[] calldata srcModules\n    )\n        external\n        payable;\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * @param transactionID The ID of the transaction being executed.\n     * @param transaction The transaction data.\n     */\n    function interchainExecute(bytes32 transactionID, bytes calldata transaction) external;\n\n    /**\n     * @notice Converts a bytes32 value to an address.\n     * @dev Useful for converting blockchain-specific identifiers to Ethereum addresses.\n     * @param _bytes32 The bytes32 value to convert.\n     * @return address The address obtained from the bytes32 value.\n     */\n    function convertBytes32ToAddress(bytes32 _bytes32) external pure returns (address);\n\n    /**\n     * @notice Converts an address to a bytes32 value.\n     * @dev Useful for converting Ethereum addresses to blockchain-specific identifiers.\n     * @param _address The address to convert.\n     * @return bytes32 The bytes32 representation of the address.\n     */\n    function convertAddressToBytes32(address _address) external pure returns (bytes32);\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase\n/// @param srcChainId   The chain id of the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param writerNonce  The nonce of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    bytes32 srcWriter;\n    uint256 writerNonce;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param srcWriter    The address of the writer on the local chain\n    /// @param writerNonce  The nonce of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        address srcWriter,\n        uint256 writerNonce,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            srcWriter: TypeCasts.addressToBytes32(srcWriter),\n            writerNonce: writerNonce,\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryId(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.srcWriter, entry.writerNonce));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param dataHash     The hash of the data written on the source chain\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 dataHash;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingDataHash, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(address writer, uint256 writerNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntry(bytes32 dataHash) external returns (uint256 writerNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param writer        The address of the writer on the source chain\n    /// @param writerNonce   The nonce of the writer on the source chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(\n        uint256 destChainId,\n        address writer,\n        uint256 writerNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 writerNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param writer       The address of the writer on this chain\n    /// @param writerNonce  The nonce of the writer's entry on this chain\n    function getEntry(address writer, uint256 writerNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the writer on this chain.\n    /// @param writer       The address of the writer on this chain\n    function getWriterNonce(address writer) external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, IInterchainClientV1 {\n    uint64 public clientNonce;\n    address public interchainDB;\n\n    // Chain ID =\u003e Bytes32 Address of src clients\n    mapping(uint256 =\u003e bytes32) linkedClients;\n\n    // TODO: Add permissioning\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint256 chainId, bytes32 client) public {\n        linkedClients[chainId] = client;\n    }\n\n    constructor() Ownable(msg.sender) {}\n\n    // @inheritdoc IInterchainClientV1\n    function setInterchainDB(address _interchainDB) public onlyOwner {\n        interchainDB = _interchainDB;\n    }\n\n    /**\n     * @notice Emitted when an interchain transaction is sent.\n     */\n    event InterchainTransactionSent(\n        bytes32 srcSender,\n        uint256 srcChainId,\n        bytes32 indexed dstReceiver,\n        uint256 indexed dstChainId,\n        bytes message,\n        uint64 nonce,\n        bytes32 indexed transactionId,\n        uint256 dbWriterNonce\n    );\n\n    /**\n     * @dev Represents an interchain transaction.\n     */\n    struct InterchainTransaction {\n        bytes32 srcSender;\n        uint256 srcChainId;\n        bytes32 dstReceiver;\n        uint256 dstChainId;\n        bytes message;\n        uint64 nonce;\n        bytes32 transactionId;\n        uint256 dbWriterNonce;\n    }\n\n    // TODO: Calculate Gas Pricing per module and charge fees\n    // TODO: Customizable Gas Limit for Execution\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        address[] calldata srcModules\n    )\n        public\n        payable\n    {\n        uint256 totalModuleFees = msg.value;\n        bytes32 sender = convertAddressToBytes32(msg.sender);\n        bytes32 transactionID = keccak256(abi.encode(sender, block.chainid, receiver, dstChainId, message, clientNonce));\n\n        uint256 dbWriterNonce = IInterchainDB(interchainDB).writeEntryWithVerification{value: totalModuleFees}(\n            dstChainId, transactionID, srcModules\n        );\n\n        emit InterchainTransactionSent(\n            sender, block.chainid, receiver, dstChainId, message, clientNonce, transactionID, dbWriterNonce\n        );\n        // Increment nonce for next message\n        clientNonce++;\n    }\n\n    // TODO: Gas Fee Consideration that is paid to executor\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(bytes32 transactionID, bytes calldata transaction) public {\n        // Steps to verify:\n        // 1. Call icDB.getEntry(linkedClients.srcChainId, transaction.dbWriterNonce)\n        // 2. Verify the entry hash vs bytes calldata provided\n        // 3. Check receiver's app dstModule configuration\n        // 4. Check receiver app's optimistic time period\n        // 5. Read module entry's based on receiver app dstModule config\n        // 6. Confirm module threshold is met\n        // 7. Check optimistic threshold set on app config\n        // 8. Execute the transaction, is optimistic period is met.\n\n        InterchainTransaction memory icTx = abi.decode(transaction, (InterchainTransaction));\n\n        // 1. Call icDB.getEntry(linkedClients.srcChainId, transaction.dbWriterNonce)\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            srcWriter: linkedClients[icTx.srcChainId],\n            writerNonce: icTx.dbWriterNonce,\n            dataHash: icTx.transactionId\n        });\n\n        bytes memory reconstructedID =\n            abi.encode(icTx.srcSender, icTx.srcChainId, icTx.dstReceiver, icTx.dstChainId, icTx.message, icTx.nonce);\n\n        // 2. Verify the entry hash vs bytes calldata provided\n        require(icEntry.dataHash == keccak256(reconstructedID), \"Invalid transaction ID\");\n\n        address receivingApp = convertBytes32ToAddress(icTx.dstReceiver);\n        // 3. Check receiver's app dstModule configuration\n        address[] memory approvedDstModules = IInterchainApp(receivingApp).getReceivingModules();\n\n        uint256 appRequiredResponses = IInterchainApp(receivingApp).getRequiredResponses();\n\n        // 4. Check receiver app's optimistic time period\n        uint256 optimisticTimePeriod = IInterchainApp(receivingApp).getOptimisticTimePeriod();\n\n        // 5. Read module entry's based on receiver app dstModule config\n        uint256[] memory moduleResponseTimestamps = new uint256[](approvedDstModules.length);\n\n        for (uint256 i = 0; i \u003c approvedDstModules.length; i++) {\n            moduleResponseTimestamps[i] = IInterchainDB(interchainDB).readEntry(approvedDstModules[i], icEntry);\n        }\n        // 6. Confirm module threshold is met\n        uint256 validResponses = 0;\n\n        for (uint256 i = 0; i \u003c moduleResponseTimestamps.length; i++) {\n            if (moduleResponseTimestamps[i] + optimisticTimePeriod \u003e= block.timestamp) {\n                validResponses++;\n            }\n        }\n\n        require(validResponses \u003e= appRequiredResponses, \"Not enough valid responses to meet the threshold\");\n\n        // 8. Execute the transaction, is optimistic period \u0026 valid responses is met.\n        IInterchainApp(receivingApp).appReceive();\n    }\n\n    // TODO: Seperate out into utils\n    /**\n     * @inheritdoc IInterchainClientV1\n     */\n    function convertBytes32ToAddress(bytes32 _bytes32) public pure returns (address) {\n        return address(uint160(uint256(_bytes32)));\n    }\n\n    /**\n     * @inheritdoc IInterchainClientV1\n     */\n    function convertAddressToBytes32(address _address) public pure returns (bytes32) {\n        return bytes32(uint256(uint160(_address)));\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"14932:5599:0:-:0;;;15350:36;;;;;;;;;-1:-1:-1;15372:10:0;;7493:95;;7546:31;;-1:-1:-1;;;7546:31:0;;7574:1;7546:31;;;160:51:1;133:18;;7546:31:0;;;;;;;7493:95;7597:32;7616:12;7597:18;:32::i;:::-;7449:187;14932:5599;;9136:187;9209:16;9228:6;;-1:-1:-1;;;;;9244:17:0;;;-1:-1:-1;;;;;;9244:17:0;;;;;;9276:40;;9228:6;;;;;;;9276:40;;9209:16;9276:40;9199:124;9136:187;:::o;14:203:1:-;14932:5599:0;;;;;;","srcMapRuntime":"14932:5599:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;14998:25;;;;;;;;;;-1:-1:-1;14998:25:0;;;;;;;;;;;;;;295:18:1;283:31;;;265:50;;253:2;238:18;14998:25:0;;;;;;;;15029:27;;;;;;;;;;-1:-1:-1;15029:27:0;;;;;;;;;;;502:42:1;490:55;;;472:74;;460:2;445:18;15029:27:0;326:226:1;20188:140:0;;;;;;;;;;-1:-1:-1;20188:140:0;;;;;:::i;:::-;20310:8;20188:140;20389;;;;;;;;;;-1:-1:-1;20389:140:0;;;;;:::i;:::-;20495:26;;;20389:140;;;;1299:25:1;;;1287:2;1272:18;20389:140:0;1153:177:1;8517:101:0;;;;;;;;;;;;;:::i;:::-;;16391:827;;;;;;:::i;:::-;;:::i;7862:85::-;;;;;;;;;;-1:-1:-1;7908:7:0;7934:6;;;7862:85;;15431:110;;;;;;;;;;-1:-1:-1;15431:110:0;;;;;:::i;:::-;;:::i;17323:2767::-;;;;;;;;;;-1:-1:-1;17323:2767:0;;;;;:::i;:::-;;:::i;8767:215::-;;;;;;;;;;-1:-1:-1;8767:215:0;;;;;:::i;:::-;;:::i;15231:113::-;;;;;;;;;;-1:-1:-1;15231:113:0;;;;;:::i;:::-;15306:22;;;;:13;:22;;;;;;:31;15231:113;8517:101;7755:13;:11;:13::i;:::-;8581:30:::1;8608:1;8581:18;:30::i;:::-;8517:101::o:0;16391:827::-;16591:23;16797:11;;16732:77;;16617:9;;16677:10;;16591:23;;16732:77;;16677:10;;16751:13;;16766:8;;16776:10;;16788:7;;;;16797:11;;;;;;16732:77;;;:::i;:::-;;;;-1:-1:-1;;16732:77:0;;;;;;;;;;16722:88;;16732:77;16722:88;;;;16859:12;;16845:139;;;16722:88;;-1:-1:-1;16821:21:0;;16859:12;;;;;16845:54;;16907:15;;16845:139;;16937:10;;16722:88;;16964:10;;;;16845:139;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;16821:163;;17106:13;17072:10;17062:8;17000:144;17039:6;17047:13;17084:7;;17093:11;;;;;;;;;;;17121:13;17000:144;;;;;;;;;;;:::i;:::-;;;;;;;;17198:11;:13;;;;;;;;:11;:13;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;16581:637;;;;16391:827;;;;;;:::o;15431:110::-;7755:13;:11;:13::i;:::-;15506:12:::1;:28:::0;;;::::1;;::::0;;;::::1;::::0;;;::::1;::::0;;15431:110::o;17323:2767::-;17959:33;17995:48;;;;18006:11;17995:48;:::i;:::-;17959:84;;18140:30;18173:210;;;;;;;;18215:4;:15;;;18173:210;;;;18255:13;:30;18269:4;:15;;;18255:30;;;;;;;;;;;;18173:210;;;;18312:4;:18;;;18173:210;;;;18354:4;:18;;;18173:210;;;18140:243;;18394:28;18448:4;:14;;;18464:4;:15;;;18481:4;:16;;;18499:4;:15;;;18516:4;:12;;;18530:4;:10;;;18437:104;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;18394:147;;18653:15;18643:26;;;;;;18623:7;:16;;;:46;18615:81;;;;;;;10337:2:1;18615:81:0;;;10319:21:1;10376:2;10356:18;;;10349:30;10415:24;10395:18;;;10388:52;10457:18;;18615:81:0;;;;;;;;;18707:20;18730:41;18754:4;:16;;;20310:8;20188:140;18730:41;18707:64;;18840:35;18893:12;18878:48;;;:50;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;18878:50:0;;;;;;;;;;;;:::i;:::-;18840:88;;18939:28;18985:12;18970:49;;;:51;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;18939:82;;19090:28;19136:12;19121:52;;;:54;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;19090:85;;;;19259:41;19317:18;:25;19303:40;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;19303:40:0;;19259:84;;19359:9;19354:180;19378:18;:25;19374:1;:29;19354:180;;;19468:12;;19492:21;;19468:12;;;;;19454:37;;19492:18;;19511:1;;19492:21;;;;;;:::i;:::-;;;;;;;;;;;;19454:69;;;;;;;;;;;12214:42:1;12202:55;;;19454:69:0;;;12184:74:1;12294:13;;12274:18;;;12267:41;12350:15;;;12344:22;12324:18;;;12317:50;12409:15;;;12403:22;12383:18;;;12376:50;12398:2;12469:15;;12463:22;12442:19;;;12435:51;12156:19;;19454:69:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;19424:24;19449:1;19424:27;;;;;;;;:::i;:::-;;;;;;;;;;:99;19405:3;;;;:::i;:::-;;;;19354:180;;;;19589:22;19631:9;19626:210;19650:24;:31;19646:1;:35;19626:210;;;19760:15;19736:20;19706:24;19731:1;19706:27;;;;;;;;:::i;:::-;;;;;;;:50;;;;:::i;:::-;:69;19702:124;;19795:16;;;;:::i;:::-;;;;19702:124;19683:3;;;;:::i;:::-;;;;19626:210;;;;19872:20;19854:14;:38;;19846:99;;;;;;;13029:2:1;19846:99:0;;;13011:21:1;13068:2;13048:18;;;13041:30;13107:34;13087:18;;;13080:62;13178:18;13158;;;13151:46;13214:19;;19846:99:0;12827:412:1;19846:99:0;20057:12;20042:39;;;:41;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;17408:2682;;;;;;;;;17323:2767;;;:::o;8767:215::-;7755:13;:11;:13::i;:::-;8851:22:::1;::::0;::::1;8847:91;;8896:31;::::0;::::1;::::0;;8924:1:::1;8896:31;::::0;::::1;472:74:1::0;445:18;;8896:31:0::1;326:226:1::0;8847:91:0::1;8947:28;8966:8;8947:18;:28::i;:::-;8767:215:::0;:::o;8020:162::-;7908:7;7934:6;8079:23;7934:6;4461:10;8079:23;8075:101;;8125:40;;;;;4461:10;8125:40;;;472:74:1;445:18;;8125:40:0;326:226:1;9136:187:0;9209:16;9228:6;;;9244:17;;;;;;;;;;9276:40;;9228:6;;;;;;;9276:40;;9209:16;9276:40;9199:124;9136:187;:::o;557:180:1:-;616:6;669:2;657:9;648:7;644:23;640:32;637:52;;;685:1;682;675:12;637:52;-1:-1:-1;708:23:1;;557:180;-1:-1:-1;557:180:1:o;742:154::-;828:42;821:5;817:54;810:5;807:65;797:93;;886:1;883;876:12;901:247;960:6;1013:2;1001:9;992:7;988:23;984:32;981:52;;;1029:1;1026;1019:12;981:52;1068:9;1055:23;1087:31;1112:5;1087:31;:::i;:::-;1137:5;901:247;-1:-1:-1;;;901:247:1:o;1335:347::-;1386:8;1396:6;1450:3;1443:4;1435:6;1431:17;1427:27;1417:55;;1468:1;1465;1458:12;1417:55;-1:-1:-1;1491:20:1;;1534:18;1523:30;;1520:50;;;1566:1;1563;1556:12;1520:50;1603:4;1595:6;1591:17;1579:29;;1655:3;1648:4;1639:6;1631;1627:19;1623:30;1620:39;1617:59;;;1672:1;1669;1662:12;1617:59;1335:347;;;;;:::o;1687:1039::-;1811:6;1819;1827;1835;1843;1851;1904:3;1892:9;1883:7;1879:23;1875:33;1872:53;;;1921:1;1918;1911:12;1872:53;1957:9;1944:23;1934:33;;2014:2;2003:9;1999:18;1986:32;1976:42;;2069:2;2058:9;2054:18;2041:32;2092:18;2133:2;2125:6;2122:14;2119:34;;;2149:1;2146;2139:12;2119:34;2188:58;2238:7;2229:6;2218:9;2214:22;2188:58;:::i;:::-;2265:8;;-1:-1:-1;2162:84:1;-1:-1:-1;2353:2:1;2338:18;;2325:32;;-1:-1:-1;2369:16:1;;;2366:36;;;2398:1;2395;2388:12;2366:36;2436:8;2425:9;2421:24;2411:34;;2483:7;2476:4;2472:2;2468:13;2464:27;2454:55;;2505:1;2502;2495:12;2454:55;2545:2;2532:16;2571:2;2563:6;2560:14;2557:34;;;2587:1;2584;2577:12;2557:34;2640:7;2635:2;2625:6;2622:1;2618:14;2614:2;2610:23;2606:32;2603:45;2600:65;;;2661:1;2658;2651:12;2600:65;2692:2;2688;2684:11;2674:21;;2714:6;2704:16;;;;;1687:1039;;;;;;;;:::o;2731:477::-;2810:6;2818;2826;2879:2;2867:9;2858:7;2854:23;2850:32;2847:52;;;2895:1;2892;2885:12;2847:52;2931:9;2918:23;2908:33;;2992:2;2981:9;2977:18;2964:32;3019:18;3011:6;3008:30;3005:50;;;3051:1;3048;3041:12;3005:50;3090:58;3140:7;3131:6;3120:9;3116:22;3090:58;:::i;:::-;2731:477;;3167:8;;-1:-1:-1;3064:84:1;;-1:-1:-1;;;;2731:477:1:o;3213:248::-;3281:6;3289;3342:2;3330:9;3321:7;3317:23;3313:32;3310:52;;;3358:1;3355;3348:12;3310:52;-1:-1:-1;;3381:23:1;;;3451:2;3436:18;;;3423:32;;-1:-1:-1;3213:248:1:o;3466:325::-;3554:6;3549:3;3542:19;3606:6;3599:5;3592:4;3587:3;3583:14;3570:43;;3658:1;3651:4;3642:6;3637:3;3633:16;3629:27;3622:38;3524:3;3780:4;-1:-1:-1;;3705:2:1;3697:6;3693:15;3689:88;3684:3;3680:98;3676:109;3669:116;;3466:325;;;;:::o;3796:626::-;4091:6;4080:9;4073:25;4134:6;4129:2;4118:9;4114:18;4107:34;4177:6;4172:2;4161:9;4157:18;4150:34;4220:6;4215:2;4204:9;4200:18;4193:34;4264:3;4258;4247:9;4243:19;4236:32;4054:4;4285:62;4342:3;4331:9;4327:19;4319:6;4311;4285:62;:::i;:::-;4277:70;;4396:18;4388:6;4384:31;4378:3;4367:9;4363:19;4356:60;3796:626;;;;;;;;;;:::o;4427:871::-;4695:25;;;4739:2;4757:18;;;4750:34;;;4683:2;4815;4800:18;;4793:30;;;4668:18;;4858:22;;;4635:4;;4938:6;;4911:3;4896:19;;4635:4;4972:300;4986:6;4983:1;4980:13;4972:300;;;5061:6;5048:20;5081:31;5106:5;5081:31;:::i;:::-;5148:42;5137:54;5125:67;;5247:15;;;;5212:12;;;;5008:1;5001:9;4972:300;;;-1:-1:-1;5289:3:1;4427:871;-1:-1:-1;;;;;;;;4427:871:1:o;5303:184::-;5373:6;5426:2;5414:9;5405:7;5401:23;5397:32;5394:52;;;5442:1;5439;5432:12;5394:52;-1:-1:-1;5465:16:1;;5303:184;-1:-1:-1;5303:184:1:o;5492:554::-;5759:6;5748:9;5741:25;5802:6;5797:2;5786:9;5782:18;5775:34;5845:3;5840:2;5829:9;5825:18;5818:31;5722:4;5866:62;5923:3;5912:9;5908:19;5900:6;5892;5866:62;:::i;:::-;5976:18;5964:31;;;;5959:2;5944:18;;5937:59;-1:-1:-1;6027:3:1;6012:19;6005:35;5858:70;5492:554;-1:-1:-1;;;;5492:554:1:o;6051:184::-;6103:77;6100:1;6093:88;6200:4;6197:1;6190:15;6224:4;6221:1;6214:15;6240:209;6278:3;6306:18;6359:2;6352:5;6348:14;6386:2;6377:7;6374:15;6371:41;;6392:18;;:::i;:::-;6441:1;6428:15;;6240:209;-1:-1:-1;;;6240:209:1:o;6454:184::-;6506:77;6503:1;6496:88;6603:4;6600:1;6593:15;6627:4;6624:1;6617:15;6643:255;6715:2;6709:9;6757:6;6745:19;;6794:18;6779:34;;6815:22;;;6776:62;6773:88;;;6841:18;;:::i;:::-;6877:2;6870:22;6643:255;:::o;6903:334::-;6974:2;6968:9;7030:2;7020:13;;-1:-1:-1;;7016:86:1;7004:99;;7133:18;7118:34;;7154:22;;;7115:62;7112:88;;;7180:18;;:::i;:::-;7216:2;7209:22;6903:334;;-1:-1:-1;6903:334:1:o;7242:589::-;7284:5;7337:3;7330:4;7322:6;7318:17;7314:27;7304:55;;7355:1;7352;7345:12;7304:55;7391:6;7378:20;7417:18;7413:2;7410:26;7407:52;;;7439:18;;:::i;:::-;7483:114;7591:4;-1:-1:-1;;7515:4:1;7511:2;7507:13;7503:86;7499:97;7483:114;:::i;:::-;7622:2;7613:7;7606:19;7668:3;7661:4;7656:2;7648:6;7644:15;7640:26;7637:35;7634:55;;;7685:1;7682;7675:12;7634:55;7750:2;7743:4;7735:6;7731:17;7724:4;7715:7;7711:18;7698:55;7798:1;7773:16;;;7791:4;7769:27;7762:38;;;;7777:7;7242:589;-1:-1:-1;;;7242:589:1:o;7836:129::-;7921:18;7914:5;7910:30;7903:5;7900:41;7890:69;;7955:1;7952;7945:12;7970:132;8037:20;;8066:30;8037:20;8066:30;:::i;:::-;7970:132;;;:::o;8107:1042::-;8204:6;8257:2;8245:9;8236:7;8232:23;8228:32;8225:52;;;8273:1;8270;8263:12;8225:52;8313:9;8300:23;8342:18;8383:2;8375:6;8372:14;8369:34;;;8399:1;8396;8389:12;8369:34;8422:22;;;;8478:6;8460:16;;;8456:29;8453:49;;;8498:1;8495;8488:12;8453:49;8524:22;;:::i;:::-;8582:2;8569:16;8562:5;8555:31;8639:2;8635;8631:11;8618:25;8613:2;8606:5;8602:14;8595:49;8697:2;8693;8689:11;8676:25;8671:2;8664:5;8660:14;8653:49;8755:2;8751;8747:11;8734:25;8729:2;8722:5;8718:14;8711:49;8806:3;8802:2;8798:12;8785:26;8836:2;8826:8;8823:16;8820:36;;;8852:1;8849;8842:12;8820:36;8889:44;8925:7;8914:8;8910:2;8906:17;8889:44;:::i;:::-;8883:3;8876:5;8872:15;8865:69;;8967:31;8993:3;8989:2;8985:12;8967:31;:::i;:::-;8961:3;8954:5;8950:15;8943:56;9053:3;9049:2;9045:12;9032:26;9026:3;9019:5;9015:15;9008:51;9113:3;9109:2;9105:12;9092:26;9086:3;9079:5;9075:15;9068:51;9138:5;9128:15;;;;;8107:1042;;;;:::o;9154:976::-;9439:6;9428:9;9421:25;9402:4;9465:2;9503:6;9498:2;9487:9;9483:18;9476:34;9546:6;9541:2;9530:9;9526:18;9519:34;9589:6;9584:2;9573:9;9569:18;9562:34;9633:3;9627;9616:9;9612:19;9605:32;9666:6;9660:13;9710:6;9704:3;9693:9;9689:19;9682:35;9735:1;9745:141;9759:6;9756:1;9753:13;9745:141;;;9855:14;;;9851:23;;9845:30;9820:17;;;9839:3;9816:27;9809:67;9774:10;;9745:141;;;9749:3;9936:1;9930:3;9921:6;9910:9;9906:22;9902:32;9895:43;10065:3;-1:-1:-1;;9990:2:1;9982:6;9978:15;9974:88;9963:9;9959:104;9955:114;9947:122;;;;10078:46;10119:3;10108:9;10104:19;10096:6;90:18;79:30;67:43;;14:102;10078:46;9154:976;;;;;;;;;:::o;10486:1011::-;10581:6;10612:2;10655;10643:9;10634:7;10630:23;10626:32;10623:52;;;10671:1;10668;10661:12;10623:52;10704:9;10698:16;10733:18;10774:2;10766:6;10763:14;10760:34;;;10790:1;10787;10780:12;10760:34;10828:6;10817:9;10813:22;10803:32;;10873:7;10866:4;10862:2;10858:13;10854:27;10844:55;;10895:1;10892;10885:12;10844:55;10924:2;10918:9;10946:2;10942;10939:10;10936:36;;;10952:18;;:::i;:::-;10998:2;10995:1;10991:10;10981:20;;11021:28;11045:2;11041;11037:11;11021:28;:::i;:::-;11083:15;;;11153:11;;;11149:20;;;11114:12;;;;11181:19;;;11178:39;;;11213:1;11210;11203:12;11178:39;11237:11;;;;11257:210;11273:6;11268:3;11265:15;11257:210;;;11346:3;11340:10;11327:23;;11363:31;11388:5;11363:31;:::i;:::-;11407:18;;;11290:12;;;;11445;;;;11257:210;;;11486:5;10486:1011;-1:-1:-1;;;;;;;;10486:1011:1:o;11502:249::-;11571:6;11624:2;11612:9;11603:7;11599:23;11595:32;11592:52;;;11640:1;11637;11630:12;11592:52;11672:9;11666:16;11691:30;11715:5;11691:30;:::i;11756:184::-;11808:77;11805:1;11798:88;11905:4;11902:1;11895:15;11929:4;11926:1;11919:15;12497:195;12536:3;12567:66;12560:5;12557:77;12554:103;;12637:18;;:::i;:::-;-1:-1:-1;12684:1:1;12673:13;;12497:195::o;12697:125::-;12762:9;;;12783:10;;;12780:36;;;12796:18;;:::i;:::-;12697:125;;;;:::o","abiDefinition":[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"bytes32","name":"srcSender","type":"bytes32"},{"indexed":false,"internalType":"uint256","name":"srcChainId","type":"uint256"},{"indexed":true,"internalType":"bytes32","name":"dstReceiver","type":"bytes32"},{"indexed":true,"internalType":"uint256","name":"dstChainId","type":"uint256"},{"indexed":false,"internalType":"bytes","name":"message","type":"bytes"},{"indexed":false,"internalType":"uint64","name":"nonce","type":"uint64"},{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":false,"internalType":"uint256","name":"dbWriterNonce","type":"uint256"}],"name":"InterchainTransactionSent","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[],"name":"clientNonce","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_address","type":"address"}],"name":"convertAddressToBytes32","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_bytes32","type":"bytes32"}],"name":"convertBytes32ToAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"interchainDB","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionID","type":"bytes32"},{"internalType":"bytes","name":"transaction","type":"bytes"}],"name":"interchainExecute","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"receiver","type":"bytes32"},{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"bytes","name":"message","type":"bytes"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"interchainSend","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_interchainDB","type":"address"}],"name":"setInterchainDB","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"bytes32","name":"client","type":"bytes32"}],"name":"setLinkedClient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"events":{"InterchainTransactionSent(bytes32,uint256,bytes32,uint256,bytes,uint64,bytes32,uint256)":{"notice":"Emitted when an interchain transaction is sent."}},"kind":"user","methods":{"convertAddressToBytes32(address)":{"notice":"Converts an address to a bytes32 value."},"convertBytes32ToAddress(bytes32)":{"notice":"Converts a bytes32 value to an address."},"interchainExecute(bytes32,bytes)":{"notice":"Executes a transaction that has been sent via the Interchain."},"interchainSend(bytes32,uint256,bytes,address[])":{"notice":"Sends a message to another chain via the Interchain Communication Protocol."},"setInterchainDB(address)":{"notice":"Sets the address of the InterchainDB contract."},"setLinkedClient(uint256,bytes32)":{"notice":"Sets the linked client for a specific chain ID."}},"version":1},"developerDoc":{"details":"Implements the operations of the Interchain Execution Layer.","errors":{"OwnableInvalidOwner(address)":[{"details":"The owner is not a valid owner account. (eg. `address(0)`)"}],"OwnableUnauthorizedAccount(address)":[{"details":"The caller account is not authorized to perform an operation."}]},"kind":"dev","methods":{"convertAddressToBytes32(address)":{"details":"Useful for converting Ethereum addresses to blockchain-specific identifiers.","params":{"_address":"The address to convert."},"returns":{"_0":"bytes32 The bytes32 representation of the address."}},"convertBytes32ToAddress(bytes32)":{"details":"Useful for converting blockchain-specific identifiers to Ethereum addresses.","params":{"_bytes32":"The bytes32 value to convert."},"returns":{"_0":"address The address obtained from the bytes32 value."}},"interchainExecute(bytes32,bytes)":{"details":"The transaction must have been previously sent and recorded.","params":{"transaction":"The transaction data.","transactionID":"The ID of the transaction being executed."}},"interchainSend(bytes32,uint256,bytes,address[])":{"details":"Charges a fee for the message, which is payable upon calling this function.","params":{"dstChainId":"The chain ID of the destination chain.","message":"The message being sent.","receiver":"The address of the receiver on the destination chain.","srcModules":"The source modules involved in the message sending."}},"owner()":{"details":"Returns the address of the current owner."},"renounceOwnership()":{"details":"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."},"setInterchainDB(address)":{"details":"Only callable by the contract owner or an authorized account.","params":{"_interchainDB":"The address of the InterchainDB contract."}},"setLinkedClient(uint256,bytes32)":{"details":"Stores the address of the linked client in a mapping with the chain ID as the key.","params":{"chainId":"The chain ID for which the client is being set.","client":"The address of the client being linked."}},"transferOwnership(address)":{"details":"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}},"title":"InterchainClientV1","version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"srcSender\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"dstReceiver\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dbWriterNonce\",\"type\":\"uint256\"}],\"name\":\"InterchainTransactionSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"clientNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"convertAddressToBytes32\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_bytes32\",\"type\":\"bytes32\"}],\"name\":\"convertBytes32ToAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interchainDB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"transaction\",\"type\":\"bytes\"}],\"name\":\"interchainExecute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"receiver\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"interchainSend\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_interchainDB\",\"type\":\"address\"}],\"name\":\"setInterchainDB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"client\",\"type\":\"bytes32\"}],\"name\":\"setLinkedClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Implements the operations of the Interchain Execution Layer.\",\"errors\":{\"OwnableInvalidOwner(address)\":[{\"details\":\"The owner is not a valid owner account. (eg. `address(0)`)\"}],\"OwnableUnauthorizedAccount(address)\":[{\"details\":\"The caller account is not authorized to perform an operation.\"}]},\"kind\":\"dev\",\"methods\":{\"convertAddressToBytes32(address)\":{\"details\":\"Useful for converting Ethereum addresses to blockchain-specific identifiers.\",\"params\":{\"_address\":\"The address to convert.\"},\"returns\":{\"_0\":\"bytes32 The bytes32 representation of the address.\"}},\"convertBytes32ToAddress(bytes32)\":{\"details\":\"Useful for converting blockchain-specific identifiers to Ethereum addresses.\",\"params\":{\"_bytes32\":\"The bytes32 value to convert.\"},\"returns\":{\"_0\":\"address The address obtained from the bytes32 value.\"}},\"interchainExecute(bytes32,bytes)\":{\"details\":\"The transaction must have been previously sent and recorded.\",\"params\":{\"transaction\":\"The transaction data.\",\"transactionID\":\"The ID of the transaction being executed.\"}},\"interchainSend(bytes32,uint256,bytes,address[])\":{\"details\":\"Charges a fee for the message, which is payable upon calling this function.\",\"params\":{\"dstChainId\":\"The chain ID of the destination chain.\",\"message\":\"The message being sent.\",\"receiver\":\"The address of the receiver on the destination chain.\",\"srcModules\":\"The source modules involved in the message sending.\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"setInterchainDB(address)\":{\"details\":\"Only callable by the contract owner or an authorized account.\",\"params\":{\"_interchainDB\":\"The address of the InterchainDB contract.\"}},\"setLinkedClient(uint256,bytes32)\":{\"details\":\"Stores the address of the linked client in a mapping with the chain ID as the key.\",\"params\":{\"chainId\":\"The chain ID for which the client is being set.\",\"client\":\"The address of the client being linked.\"}},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"title\":\"InterchainClientV1\",\"version\":1},\"userdoc\":{\"events\":{\"InterchainTransactionSent(bytes32,uint256,bytes32,uint256,bytes,uint64,bytes32,uint256)\":{\"notice\":\"Emitted when an interchain transaction is sent.\"}},\"kind\":\"user\",\"methods\":{\"convertAddressToBytes32(address)\":{\"notice\":\"Converts an address to a bytes32 value.\"},\"convertBytes32ToAddress(bytes32)\":{\"notice\":\"Converts a bytes32 value to an address.\"},\"interchainExecute(bytes32,bytes)\":{\"notice\":\"Executes a transaction that has been sent via the Interchain.\"},\"interchainSend(bytes32,uint256,bytes,address[])\":{\"notice\":\"Sends a message to another chain via the Interchain Communication Protocol.\"},\"setInterchainDB(address)\":{\"notice\":\"Sets the address of the InterchainDB contract.\"},\"setLinkedClient(uint256,bytes32)\":{\"notice\":\"Sets the linked client for a specific chain ID.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"InterchainClientV1\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0x982e9011e738d832d83545cccb9c0d49738847d637bb91992a6f611d678b844b\",\"urls\":[\"bzz-raw://6e484f8559b38a654ef0b91ea4bd7da1a17e1ca301762a382750e2af2d85aed7\",\"dweb:/ipfs/QmZz3158XFik6u5SJvaYdQrXpcM87h6aY2kf83ntcqD2sX\"]}},\"version\":1}"},"hashes":{"clientNonce()":"0d898416","convertAddressToBytes32(address)":"5893740e","convertBytes32ToAddress(bytes32)":"1efa2220","interchainDB()":"0e785ce0","interchainExecute(bytes32,bytes)":"d3388b80","interchainSend(bytes32,uint256,bytes,address[])":"8366a109","owner()":"8da5cb5b","renounceOwnership()":"715018a6","setInterchainDB(address)":"b7ce2078","setLinkedClient(uint256,bytes32)":"f34234c8","transferOwnership(address)":"f2fde38b"}},"solidity/InterchainClientV1.sol:InterchainEntryLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220a95898eae832fabe134bfc065c874495ab528dcf6f2ea618092430b693351e4c64736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220a95898eae832fabe134bfc065c874495ab528dcf6f2ea618092430b693351e4c64736f6c63430008140033","info":{"source":"pragma solidity =0.8.20 ^0.8.0 ^0.8.20;\n\n// contracts/interfaces/IInterchainApp.sol\n\ninterface IInterchainApp {\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory sendingModules,\n        address[] memory receivingModules,\n        uint256 requiredResponses,\n        uint64 optimisticTimePeriod\n    )\n        external;\n\n    function getLinkedIApp(uint64 chainID) external view returns (address);\n\n    function getSendingModules() external view returns (address[] memory);\n\n    function getReceivingModules() external view returns (address[] memory);\n\n    function getRequiredResponses() external view returns (uint256);\n\n    function getOptimisticTimePeriod() external view returns (uint64);\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable;\n\n    function appReceive() external;\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sets the address of the InterchainDB contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param _interchainDB The address of the InterchainDB contract.\n     */\n    function setInterchainDB(address _interchainDB) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param message The message being sent.\n     * @param srcModules The source modules involved in the message sending.\n     */\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        address[] calldata srcModules\n    )\n        external\n        payable;\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * @param transactionID The ID of the transaction being executed.\n     * @param transaction The transaction data.\n     */\n    function interchainExecute(bytes32 transactionID, bytes calldata transaction) external;\n\n    /**\n     * @notice Converts a bytes32 value to an address.\n     * @dev Useful for converting blockchain-specific identifiers to Ethereum addresses.\n     * @param _bytes32 The bytes32 value to convert.\n     * @return address The address obtained from the bytes32 value.\n     */\n    function convertBytes32ToAddress(bytes32 _bytes32) external pure returns (address);\n\n    /**\n     * @notice Converts an address to a bytes32 value.\n     * @dev Useful for converting Ethereum addresses to blockchain-specific identifiers.\n     * @param _address The address to convert.\n     * @return bytes32 The bytes32 representation of the address.\n     */\n    function convertAddressToBytes32(address _address) external pure returns (bytes32);\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase\n/// @param srcChainId   The chain id of the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param writerNonce  The nonce of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    bytes32 srcWriter;\n    uint256 writerNonce;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param srcWriter    The address of the writer on the local chain\n    /// @param writerNonce  The nonce of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        address srcWriter,\n        uint256 writerNonce,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            srcWriter: TypeCasts.addressToBytes32(srcWriter),\n            writerNonce: writerNonce,\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryId(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.srcWriter, entry.writerNonce));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param dataHash     The hash of the data written on the source chain\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 dataHash;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingDataHash, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(address writer, uint256 writerNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntry(bytes32 dataHash) external returns (uint256 writerNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param writer        The address of the writer on the source chain\n    /// @param writerNonce   The nonce of the writer on the source chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(\n        uint256 destChainId,\n        address writer,\n        uint256 writerNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 writerNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param writer       The address of the writer on this chain\n    /// @param writerNonce  The nonce of the writer's entry on this chain\n    function getEntry(address writer, uint256 writerNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the writer on this chain.\n    /// @param writer       The address of the writer on this chain\n    function getWriterNonce(address writer) external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, IInterchainClientV1 {\n    uint64 public clientNonce;\n    address public interchainDB;\n\n    // Chain ID =\u003e Bytes32 Address of src clients\n    mapping(uint256 =\u003e bytes32) linkedClients;\n\n    // TODO: Add permissioning\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint256 chainId, bytes32 client) public {\n        linkedClients[chainId] = client;\n    }\n\n    constructor() Ownable(msg.sender) {}\n\n    // @inheritdoc IInterchainClientV1\n    function setInterchainDB(address _interchainDB) public onlyOwner {\n        interchainDB = _interchainDB;\n    }\n\n    /**\n     * @notice Emitted when an interchain transaction is sent.\n     */\n    event InterchainTransactionSent(\n        bytes32 srcSender,\n        uint256 srcChainId,\n        bytes32 indexed dstReceiver,\n        uint256 indexed dstChainId,\n        bytes message,\n        uint64 nonce,\n        bytes32 indexed transactionId,\n        uint256 dbWriterNonce\n    );\n\n    /**\n     * @dev Represents an interchain transaction.\n     */\n    struct InterchainTransaction {\n        bytes32 srcSender;\n        uint256 srcChainId;\n        bytes32 dstReceiver;\n        uint256 dstChainId;\n        bytes message;\n        uint64 nonce;\n        bytes32 transactionId;\n        uint256 dbWriterNonce;\n    }\n\n    // TODO: Calculate Gas Pricing per module and charge fees\n    // TODO: Customizable Gas Limit for Execution\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        address[] calldata srcModules\n    )\n        public\n        payable\n    {\n        uint256 totalModuleFees = msg.value;\n        bytes32 sender = convertAddressToBytes32(msg.sender);\n        bytes32 transactionID = keccak256(abi.encode(sender, block.chainid, receiver, dstChainId, message, clientNonce));\n\n        uint256 dbWriterNonce = IInterchainDB(interchainDB).writeEntryWithVerification{value: totalModuleFees}(\n            dstChainId, transactionID, srcModules\n        );\n\n        emit InterchainTransactionSent(\n            sender, block.chainid, receiver, dstChainId, message, clientNonce, transactionID, dbWriterNonce\n        );\n        // Increment nonce for next message\n        clientNonce++;\n    }\n\n    // TODO: Gas Fee Consideration that is paid to executor\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(bytes32 transactionID, bytes calldata transaction) public {\n        // Steps to verify:\n        // 1. Call icDB.getEntry(linkedClients.srcChainId, transaction.dbWriterNonce)\n        // 2. Verify the entry hash vs bytes calldata provided\n        // 3. Check receiver's app dstModule configuration\n        // 4. Check receiver app's optimistic time period\n        // 5. Read module entry's based on receiver app dstModule config\n        // 6. Confirm module threshold is met\n        // 7. Check optimistic threshold set on app config\n        // 8. Execute the transaction, is optimistic period is met.\n\n        InterchainTransaction memory icTx = abi.decode(transaction, (InterchainTransaction));\n\n        // 1. Call icDB.getEntry(linkedClients.srcChainId, transaction.dbWriterNonce)\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            srcWriter: linkedClients[icTx.srcChainId],\n            writerNonce: icTx.dbWriterNonce,\n            dataHash: icTx.transactionId\n        });\n\n        bytes memory reconstructedID =\n            abi.encode(icTx.srcSender, icTx.srcChainId, icTx.dstReceiver, icTx.dstChainId, icTx.message, icTx.nonce);\n\n        // 2. Verify the entry hash vs bytes calldata provided\n        require(icEntry.dataHash == keccak256(reconstructedID), \"Invalid transaction ID\");\n\n        address receivingApp = convertBytes32ToAddress(icTx.dstReceiver);\n        // 3. Check receiver's app dstModule configuration\n        address[] memory approvedDstModules = IInterchainApp(receivingApp).getReceivingModules();\n\n        uint256 appRequiredResponses = IInterchainApp(receivingApp).getRequiredResponses();\n\n        // 4. Check receiver app's optimistic time period\n        uint256 optimisticTimePeriod = IInterchainApp(receivingApp).getOptimisticTimePeriod();\n\n        // 5. Read module entry's based on receiver app dstModule config\n        uint256[] memory moduleResponseTimestamps = new uint256[](approvedDstModules.length);\n\n        for (uint256 i = 0; i \u003c approvedDstModules.length; i++) {\n            moduleResponseTimestamps[i] = IInterchainDB(interchainDB).readEntry(approvedDstModules[i], icEntry);\n        }\n        // 6. Confirm module threshold is met\n        uint256 validResponses = 0;\n\n        for (uint256 i = 0; i \u003c moduleResponseTimestamps.length; i++) {\n            if (moduleResponseTimestamps[i] + optimisticTimePeriod \u003e= block.timestamp) {\n                validResponses++;\n            }\n        }\n\n        require(validResponses \u003e= appRequiredResponses, \"Not enough valid responses to meet the threshold\");\n\n        // 8. Execute the transaction, is optimistic period \u0026 valid responses is met.\n        IInterchainApp(receivingApp).appReceive();\n    }\n\n    // TODO: Seperate out into utils\n    /**\n     * @inheritdoc IInterchainClientV1\n     */\n    function convertBytes32ToAddress(bytes32 _bytes32) public pure returns (address) {\n        return address(uint160(uint256(_bytes32)));\n    }\n\n    /**\n     * @inheritdoc IInterchainClientV1\n     */\n    function convertAddressToBytes32(address _address) public pure returns (bytes32) {\n        return bytes32(uint256(uint160(_address)));\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"5187:1080:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;5187:1080:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"5187:1080:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"InterchainEntryLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0x982e9011e738d832d83545cccb9c0d49738847d637bb91992a6f611d678b844b\",\"urls\":[\"bzz-raw://6e484f8559b38a654ef0b91ea4bd7da1a17e1ca301762a382750e2af2d85aed7\",\"dweb:/ipfs/QmZz3158XFik6u5SJvaYdQrXpcM87h6aY2kf83ntcqD2sX\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainClientV1.sol:Ownable":{"code":"0x","runtime-code":"0x","info":{"source":"pragma solidity =0.8.20 ^0.8.0 ^0.8.20;\n\n// contracts/interfaces/IInterchainApp.sol\n\ninterface IInterchainApp {\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory sendingModules,\n        address[] memory receivingModules,\n        uint256 requiredResponses,\n        uint64 optimisticTimePeriod\n    )\n        external;\n\n    function getLinkedIApp(uint64 chainID) external view returns (address);\n\n    function getSendingModules() external view returns (address[] memory);\n\n    function getReceivingModules() external view returns (address[] memory);\n\n    function getRequiredResponses() external view returns (uint256);\n\n    function getOptimisticTimePeriod() external view returns (uint64);\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable;\n\n    function appReceive() external;\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sets the address of the InterchainDB contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param _interchainDB The address of the InterchainDB contract.\n     */\n    function setInterchainDB(address _interchainDB) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param message The message being sent.\n     * @param srcModules The source modules involved in the message sending.\n     */\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        address[] calldata srcModules\n    )\n        external\n        payable;\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * @param transactionID The ID of the transaction being executed.\n     * @param transaction The transaction data.\n     */\n    function interchainExecute(bytes32 transactionID, bytes calldata transaction) external;\n\n    /**\n     * @notice Converts a bytes32 value to an address.\n     * @dev Useful for converting blockchain-specific identifiers to Ethereum addresses.\n     * @param _bytes32 The bytes32 value to convert.\n     * @return address The address obtained from the bytes32 value.\n     */\n    function convertBytes32ToAddress(bytes32 _bytes32) external pure returns (address);\n\n    /**\n     * @notice Converts an address to a bytes32 value.\n     * @dev Useful for converting Ethereum addresses to blockchain-specific identifiers.\n     * @param _address The address to convert.\n     * @return bytes32 The bytes32 representation of the address.\n     */\n    function convertAddressToBytes32(address _address) external pure returns (bytes32);\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase\n/// @param srcChainId   The chain id of the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param writerNonce  The nonce of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    bytes32 srcWriter;\n    uint256 writerNonce;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param srcWriter    The address of the writer on the local chain\n    /// @param writerNonce  The nonce of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        address srcWriter,\n        uint256 writerNonce,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            srcWriter: TypeCasts.addressToBytes32(srcWriter),\n            writerNonce: writerNonce,\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryId(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.srcWriter, entry.writerNonce));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param dataHash     The hash of the data written on the source chain\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 dataHash;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingDataHash, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(address writer, uint256 writerNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntry(bytes32 dataHash) external returns (uint256 writerNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param writer        The address of the writer on the source chain\n    /// @param writerNonce   The nonce of the writer on the source chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(\n        uint256 destChainId,\n        address writer,\n        uint256 writerNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 writerNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param writer       The address of the writer on this chain\n    /// @param writerNonce  The nonce of the writer's entry on this chain\n    function getEntry(address writer, uint256 writerNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the writer on this chain.\n    /// @param writer       The address of the writer on this chain\n    function getWriterNonce(address writer) external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, IInterchainClientV1 {\n    uint64 public clientNonce;\n    address public interchainDB;\n\n    // Chain ID =\u003e Bytes32 Address of src clients\n    mapping(uint256 =\u003e bytes32) linkedClients;\n\n    // TODO: Add permissioning\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint256 chainId, bytes32 client) public {\n        linkedClients[chainId] = client;\n    }\n\n    constructor() Ownable(msg.sender) {}\n\n    // @inheritdoc IInterchainClientV1\n    function setInterchainDB(address _interchainDB) public onlyOwner {\n        interchainDB = _interchainDB;\n    }\n\n    /**\n     * @notice Emitted when an interchain transaction is sent.\n     */\n    event InterchainTransactionSent(\n        bytes32 srcSender,\n        uint256 srcChainId,\n        bytes32 indexed dstReceiver,\n        uint256 indexed dstChainId,\n        bytes message,\n        uint64 nonce,\n        bytes32 indexed transactionId,\n        uint256 dbWriterNonce\n    );\n\n    /**\n     * @dev Represents an interchain transaction.\n     */\n    struct InterchainTransaction {\n        bytes32 srcSender;\n        uint256 srcChainId;\n        bytes32 dstReceiver;\n        uint256 dstChainId;\n        bytes message;\n        uint64 nonce;\n        bytes32 transactionId;\n        uint256 dbWriterNonce;\n    }\n\n    // TODO: Calculate Gas Pricing per module and charge fees\n    // TODO: Customizable Gas Limit for Execution\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        address[] calldata srcModules\n    )\n        public\n        payable\n    {\n        uint256 totalModuleFees = msg.value;\n        bytes32 sender = convertAddressToBytes32(msg.sender);\n        bytes32 transactionID = keccak256(abi.encode(sender, block.chainid, receiver, dstChainId, message, clientNonce));\n\n        uint256 dbWriterNonce = IInterchainDB(interchainDB).writeEntryWithVerification{value: totalModuleFees}(\n            dstChainId, transactionID, srcModules\n        );\n\n        emit InterchainTransactionSent(\n            sender, block.chainid, receiver, dstChainId, message, clientNonce, transactionID, dbWriterNonce\n        );\n        // Increment nonce for next message\n        clientNonce++;\n    }\n\n    // TODO: Gas Fee Consideration that is paid to executor\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(bytes32 transactionID, bytes calldata transaction) public {\n        // Steps to verify:\n        // 1. Call icDB.getEntry(linkedClients.srcChainId, transaction.dbWriterNonce)\n        // 2. Verify the entry hash vs bytes calldata provided\n        // 3. Check receiver's app dstModule configuration\n        // 4. Check receiver app's optimistic time period\n        // 5. Read module entry's based on receiver app dstModule config\n        // 6. Confirm module threshold is met\n        // 7. Check optimistic threshold set on app config\n        // 8. Execute the transaction, is optimistic period is met.\n\n        InterchainTransaction memory icTx = abi.decode(transaction, (InterchainTransaction));\n\n        // 1. Call icDB.getEntry(linkedClients.srcChainId, transaction.dbWriterNonce)\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            srcWriter: linkedClients[icTx.srcChainId],\n            writerNonce: icTx.dbWriterNonce,\n            dataHash: icTx.transactionId\n        });\n\n        bytes memory reconstructedID =\n            abi.encode(icTx.srcSender, icTx.srcChainId, icTx.dstReceiver, icTx.dstChainId, icTx.message, icTx.nonce);\n\n        // 2. Verify the entry hash vs bytes calldata provided\n        require(icEntry.dataHash == keccak256(reconstructedID), \"Invalid transaction ID\");\n\n        address receivingApp = convertBytes32ToAddress(icTx.dstReceiver);\n        // 3. Check receiver's app dstModule configuration\n        address[] memory approvedDstModules = IInterchainApp(receivingApp).getReceivingModules();\n\n        uint256 appRequiredResponses = IInterchainApp(receivingApp).getRequiredResponses();\n\n        // 4. Check receiver app's optimistic time period\n        uint256 optimisticTimePeriod = IInterchainApp(receivingApp).getOptimisticTimePeriod();\n\n        // 5. Read module entry's based on receiver app dstModule config\n        uint256[] memory moduleResponseTimestamps = new uint256[](approvedDstModules.length);\n\n        for (uint256 i = 0; i \u003c approvedDstModules.length; i++) {\n            moduleResponseTimestamps[i] = IInterchainDB(interchainDB).readEntry(approvedDstModules[i], icEntry);\n        }\n        // 6. Confirm module threshold is met\n        uint256 validResponses = 0;\n\n        for (uint256 i = 0; i \u003c moduleResponseTimestamps.length; i++) {\n            if (moduleResponseTimestamps[i] + optimisticTimePeriod \u003e= block.timestamp) {\n                validResponses++;\n            }\n        }\n\n        require(validResponses \u003e= appRequiredResponses, \"Not enough valid responses to meet the threshold\");\n\n        // 8. Execute the transaction, is optimistic period \u0026 valid responses is met.\n        IInterchainApp(receivingApp).appReceive();\n    }\n\n    // TODO: Seperate out into utils\n    /**\n     * @inheritdoc IInterchainClientV1\n     */\n    function convertBytes32ToAddress(bytes32 _bytes32) public pure returns (address) {\n        return address(uint160(uint256(_bytes32)));\n    }\n\n    /**\n     * @inheritdoc IInterchainClientV1\n     */\n    function convertAddressToBytes32(address _address) public pure returns (bytes32) {\n        return bytes32(uint256(uint160(_address)));\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Contract module which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. The initial owner is set to the address provided by the deployer. This can later be changed with {transferOwnership}. This module is used through inheritance. It will make available the modifier `onlyOwner`, which can be applied to your functions to restrict their use to the owner.","errors":{"OwnableInvalidOwner(address)":[{"details":"The owner is not a valid owner account. (eg. `address(0)`)"}],"OwnableUnauthorizedAccount(address)":[{"details":"The caller account is not authorized to perform an operation."}]},"kind":"dev","methods":{"constructor":{"details":"Initializes the contract setting the address provided by the deployer as the initial owner."},"owner()":{"details":"Returns the address of the current owner."},"renounceOwnership()":{"details":"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."},"transferOwnership(address)":{"details":"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Contract module which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. The initial owner is set to the address provided by the deployer. This can later be changed with {transferOwnership}. This module is used through inheritance. It will make available the modifier `onlyOwner`, which can be applied to your functions to restrict their use to the owner.\",\"errors\":{\"OwnableInvalidOwner(address)\":[{\"details\":\"The owner is not a valid owner account. (eg. `address(0)`)\"}],\"OwnableUnauthorizedAccount(address)\":[{\"details\":\"The caller account is not authorized to perform an operation.\"}]},\"kind\":\"dev\",\"methods\":{\"constructor\":{\"details\":\"Initializes the contract setting the address provided by the deployer as the initial owner.\"},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"Ownable\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0x982e9011e738d832d83545cccb9c0d49738847d637bb91992a6f611d678b844b\",\"urls\":[\"bzz-raw://6e484f8559b38a654ef0b91ea4bd7da1a17e1ca301762a382750e2af2d85aed7\",\"dweb:/ipfs/QmZz3158XFik6u5SJvaYdQrXpcM87h6aY2kf83ntcqD2sX\"]}},\"version\":1}"},"hashes":{"owner()":"8da5cb5b","renounceOwnership()":"715018a6","transferOwnership(address)":"f2fde38b"}},"solidity/InterchainClientV1.sol:TypeCasts":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122051a177649b9982e67f24164c71b3c0e94b78eaf8ea59631a67835bf49d39d38264736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122051a177649b9982e67f24164c71b3c0e94b78eaf8ea59631a67835bf49d39d38264736f6c63430008140033","info":{"source":"pragma solidity =0.8.20 ^0.8.0 ^0.8.20;\n\n// contracts/interfaces/IInterchainApp.sol\n\ninterface IInterchainApp {\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory sendingModules,\n        address[] memory receivingModules,\n        uint256 requiredResponses,\n        uint64 optimisticTimePeriod\n    )\n        external;\n\n    function getLinkedIApp(uint64 chainID) external view returns (address);\n\n    function getSendingModules() external view returns (address[] memory);\n\n    function getReceivingModules() external view returns (address[] memory);\n\n    function getRequiredResponses() external view returns (uint256);\n\n    function getOptimisticTimePeriod() external view returns (uint64);\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable;\n\n    function appReceive() external;\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sets the address of the InterchainDB contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param _interchainDB The address of the InterchainDB contract.\n     */\n    function setInterchainDB(address _interchainDB) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param message The message being sent.\n     * @param srcModules The source modules involved in the message sending.\n     */\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        address[] calldata srcModules\n    )\n        external\n        payable;\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * @param transactionID The ID of the transaction being executed.\n     * @param transaction The transaction data.\n     */\n    function interchainExecute(bytes32 transactionID, bytes calldata transaction) external;\n\n    /**\n     * @notice Converts a bytes32 value to an address.\n     * @dev Useful for converting blockchain-specific identifiers to Ethereum addresses.\n     * @param _bytes32 The bytes32 value to convert.\n     * @return address The address obtained from the bytes32 value.\n     */\n    function convertBytes32ToAddress(bytes32 _bytes32) external pure returns (address);\n\n    /**\n     * @notice Converts an address to a bytes32 value.\n     * @dev Useful for converting Ethereum addresses to blockchain-specific identifiers.\n     * @param _address The address to convert.\n     * @return bytes32 The bytes32 representation of the address.\n     */\n    function convertAddressToBytes32(address _address) external pure returns (bytes32);\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase\n/// @param srcChainId   The chain id of the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param writerNonce  The nonce of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    bytes32 srcWriter;\n    uint256 writerNonce;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param srcWriter    The address of the writer on the local chain\n    /// @param writerNonce  The nonce of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        address srcWriter,\n        uint256 writerNonce,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            srcWriter: TypeCasts.addressToBytes32(srcWriter),\n            writerNonce: writerNonce,\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryId(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.srcWriter, entry.writerNonce));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param dataHash     The hash of the data written on the source chain\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 dataHash;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingDataHash, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(address writer, uint256 writerNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntry(bytes32 dataHash) external returns (uint256 writerNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param writer        The address of the writer on the source chain\n    /// @param writerNonce   The nonce of the writer on the source chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(\n        uint256 destChainId,\n        address writer,\n        uint256 writerNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 writerNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param writer       The address of the writer on this chain\n    /// @param writerNonce  The nonce of the writer's entry on this chain\n    function getEntry(address writer, uint256 writerNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the writer on this chain.\n    /// @param writer       The address of the writer on this chain\n    function getWriterNonce(address writer) external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, IInterchainClientV1 {\n    uint64 public clientNonce;\n    address public interchainDB;\n\n    // Chain ID =\u003e Bytes32 Address of src clients\n    mapping(uint256 =\u003e bytes32) linkedClients;\n\n    // TODO: Add permissioning\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint256 chainId, bytes32 client) public {\n        linkedClients[chainId] = client;\n    }\n\n    constructor() Ownable(msg.sender) {}\n\n    // @inheritdoc IInterchainClientV1\n    function setInterchainDB(address _interchainDB) public onlyOwner {\n        interchainDB = _interchainDB;\n    }\n\n    /**\n     * @notice Emitted when an interchain transaction is sent.\n     */\n    event InterchainTransactionSent(\n        bytes32 srcSender,\n        uint256 srcChainId,\n        bytes32 indexed dstReceiver,\n        uint256 indexed dstChainId,\n        bytes message,\n        uint64 nonce,\n        bytes32 indexed transactionId,\n        uint256 dbWriterNonce\n    );\n\n    /**\n     * @dev Represents an interchain transaction.\n     */\n    struct InterchainTransaction {\n        bytes32 srcSender;\n        uint256 srcChainId;\n        bytes32 dstReceiver;\n        uint256 dstChainId;\n        bytes message;\n        uint64 nonce;\n        bytes32 transactionId;\n        uint256 dbWriterNonce;\n    }\n\n    // TODO: Calculate Gas Pricing per module and charge fees\n    // TODO: Customizable Gas Limit for Execution\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        address[] calldata srcModules\n    )\n        public\n        payable\n    {\n        uint256 totalModuleFees = msg.value;\n        bytes32 sender = convertAddressToBytes32(msg.sender);\n        bytes32 transactionID = keccak256(abi.encode(sender, block.chainid, receiver, dstChainId, message, clientNonce));\n\n        uint256 dbWriterNonce = IInterchainDB(interchainDB).writeEntryWithVerification{value: totalModuleFees}(\n            dstChainId, transactionID, srcModules\n        );\n\n        emit InterchainTransactionSent(\n            sender, block.chainid, receiver, dstChainId, message, clientNonce, transactionID, dbWriterNonce\n        );\n        // Increment nonce for next message\n        clientNonce++;\n    }\n\n    // TODO: Gas Fee Consideration that is paid to executor\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(bytes32 transactionID, bytes calldata transaction) public {\n        // Steps to verify:\n        // 1. Call icDB.getEntry(linkedClients.srcChainId, transaction.dbWriterNonce)\n        // 2. Verify the entry hash vs bytes calldata provided\n        // 3. Check receiver's app dstModule configuration\n        // 4. Check receiver app's optimistic time period\n        // 5. Read module entry's based on receiver app dstModule config\n        // 6. Confirm module threshold is met\n        // 7. Check optimistic threshold set on app config\n        // 8. Execute the transaction, is optimistic period is met.\n\n        InterchainTransaction memory icTx = abi.decode(transaction, (InterchainTransaction));\n\n        // 1. Call icDB.getEntry(linkedClients.srcChainId, transaction.dbWriterNonce)\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            srcWriter: linkedClients[icTx.srcChainId],\n            writerNonce: icTx.dbWriterNonce,\n            dataHash: icTx.transactionId\n        });\n\n        bytes memory reconstructedID =\n            abi.encode(icTx.srcSender, icTx.srcChainId, icTx.dstReceiver, icTx.dstChainId, icTx.message, icTx.nonce);\n\n        // 2. Verify the entry hash vs bytes calldata provided\n        require(icEntry.dataHash == keccak256(reconstructedID), \"Invalid transaction ID\");\n\n        address receivingApp = convertBytes32ToAddress(icTx.dstReceiver);\n        // 3. Check receiver's app dstModule configuration\n        address[] memory approvedDstModules = IInterchainApp(receivingApp).getReceivingModules();\n\n        uint256 appRequiredResponses = IInterchainApp(receivingApp).getRequiredResponses();\n\n        // 4. Check receiver app's optimistic time period\n        uint256 optimisticTimePeriod = IInterchainApp(receivingApp).getOptimisticTimePeriod();\n\n        // 5. Read module entry's based on receiver app dstModule config\n        uint256[] memory moduleResponseTimestamps = new uint256[](approvedDstModules.length);\n\n        for (uint256 i = 0; i \u003c approvedDstModules.length; i++) {\n            moduleResponseTimestamps[i] = IInterchainDB(interchainDB).readEntry(approvedDstModules[i], icEntry);\n        }\n        // 6. Confirm module threshold is met\n        uint256 validResponses = 0;\n\n        for (uint256 i = 0; i \u003c moduleResponseTimestamps.length; i++) {\n            if (moduleResponseTimestamps[i] + optimisticTimePeriod \u003e= block.timestamp) {\n                validResponses++;\n            }\n        }\n\n        require(validResponses \u003e= appRequiredResponses, \"Not enough valid responses to meet the threshold\");\n\n        // 8. Execute the transaction, is optimistic period \u0026 valid responses is met.\n        IInterchainApp(receivingApp).appReceive();\n    }\n\n    // TODO: Seperate out into utils\n    /**\n     * @inheritdoc IInterchainClientV1\n     */\n    function convertBytes32ToAddress(bytes32 _bytes32) public pure returns (address) {\n        return address(uint160(uint256(_bytes32)));\n    }\n\n    /**\n     * @inheritdoc IInterchainClientV1\n     */\n    function convertAddressToBytes32(address _address) public pure returns (bytes32) {\n        return bytes32(uint256(uint160(_address)));\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"3443:280:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;3443:280:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"3443:280:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"TypeCasts\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0x982e9011e738d832d83545cccb9c0d49738847d637bb91992a6f611d678b844b\",\"urls\":[\"bzz-raw://6e484f8559b38a654ef0b91ea4bd7da1a17e1ca301762a382750e2af2d85aed7\",\"dweb:/ipfs/QmZz3158XFik6u5SJvaYdQrXpcM87h6aY2kf83ntcqD2sX\"]}},\"version\":1}"},"hashes":{}}}