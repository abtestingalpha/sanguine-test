{"solidity/InterchainClientV1.sol:AppConfigLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220a87a993969f5061f5ade82f73788956af47cfe0cd38ba32e176753cc201ca21f64736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220a87a993969f5061f5ade82f73788956af47cfe0cd38ba32e176753cc201ca21f64736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainClientV1Events.sol\n\nabstract contract InterchainClientV1Events {\n    // TODO: figure out indexing\n\n    event InterchainTransactionSent(\n        bytes32 indexed transactionId,\n        uint256 indexed dbNonce,\n        uint256 dstChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver,\n        uint256 verificationFee,\n        uint256 executionFee,\n        bytes options,\n        bytes message\n    );\n\n    event InterchainTransactionReceived(\n        bytes32 indexed transactionId,\n        uint256 indexed dbNonce,\n        uint256 srcChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver\n    );\n}\n\n// contracts/interfaces/IExecutionFees.sol\n\ninterface IExecutionFees {\n    /// @notice Add the execution fee for a transaction. The attached value will be added to the\n    /// rewards for the executor completing the transaction.\n    /// Note: this could be used to store the execution fee for a new transaction, or to add more\n    /// funds to the execution fee of an existing transaction. Therefore this function is payable,\n    /// and does not implement any caller restrictions.\n    /// @dev Will revert if the executor is already recorded for the transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to add the execution fee to.\n    function addExecutionFee(uint256 dstChainId, bytes32 transactionId) external payable;\n\n    /// @notice Record the executor (who completed the transaction) for a transaction,\n    /// and update the accumulated rewards for the executor.\n    /// @dev Could only be called by the Recorder.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to record the executor for.\n    /// @param executor             The address of the executor who completed the transaction.\n    function recordExecutor(uint256 dstChainId, bytes32 transactionId, address executor) external;\n\n    /// @notice Allows the executor to claim their unclaimed rewards.\n    /// @dev Will revert if the executor has no unclaimed rewards.\n    function claimExecutionFees() external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the accumulated rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function getAccumulatedRewards(address executor) external view returns (uint256 accumulated);\n\n    /// @notice Get the unclaimed rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function getUnclaimedRewards(address executor) external view returns (uint256 unclaimed);\n}\n\n// contracts/interfaces/IExecutionService.sol\n\ninterface IExecutionService {\n    /// @notice Request the execution of an Interchain Transaction on a remote chain.\n    /// Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient\n    /// event with the same transactionId, then execute the transaction on the remote chain:\n    /// `dstInterchainClient.executeTransaction(transactionPayload)`\n    /// Once the execution is confirmed on the source chain, the off-chain actor will be able\n    /// to claim `executionFee` in the ExecutionFees contract.\n    /// @dev Could only be called by `InterchainClient` contracts.\n    /// Will revert if the execution fee is not big enough.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param transactionId        The id of the transaction to execute.\n    /// @param executionFee         The fee paid for the execution.\n    /// @param options              The options to use for the execution.\n    function requestExecution(\n        uint256 dstChainId,\n        uint256 txPayloadSize,\n        bytes32 transactionId,\n        uint256 executionFee,\n        bytes memory options\n    )\n        external;\n\n    /// @notice Get the execution fee for executing an Interchain Transaction on a remote chain.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param options              The options to use for the execution.\n    function getExecutionFee(\n        uint256 dstChainId,\n        uint256 txPayloadSize,\n        bytes memory options\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\ninterface IInterchainApp {\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory sendingModules,\n        address[] memory receivingModules,\n        uint256 requiredResponses,\n        uint64 optimisticTimePeriod\n    )\n        external;\n\n    function getLinkedIApp(uint64 chainID) external view returns (address);\n\n    function getSendingModules() external view returns (address[] memory);\n\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable;\n\n    function appReceive(uint256 srcChainId, bytes32 sender, uint64 nonce, bytes calldata message) external payable;\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 expected);\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sets the address of the InterchainDB contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param _interchainDB The address of the InterchainDB contract.\n     */\n    function setInterchainDB(address _interchainDB) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently primarily gas limit + native gas drop.\n     * @param message The message being sent.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     */\n    function interchainExecute(uint256 gasLimit, bytes calldata transaction) external payable;\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction The InterchainTransaction struct to be checked.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction) external view returns (bool);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    uint8 constant OPTIONS_V1 = 1;\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the entry on the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint64 nonce;\n    uint256 dbNonce;\n    bytes options;\n    bytes message;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint64 nonce,\n        uint256 dbNonce,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            nonce: nonce,\n            dbNonce: dbNonce,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the local Interchain DataBase.\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    struct LocalEntry {\n        address writer;\n        bytes32 dataHash;\n    }\n\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param entryValue   The value of the entry: writer + dataHash hashed together\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 entryValue;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingEntryValue, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(uint256 dbNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the written entry on this chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(uint256 destChainId, uint256 dbNonce, address[] memory srcModules) external payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`\n    /// by providing the returned `dbNonce`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param dbNonce      The database nonce of the written entry on this chain\n    function getEntry(uint256 dbNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the database.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, InterchainClientV1Events, IInterchainClientV1 {\n    using AppConfigLib for bytes;\n    using OptionsLib for bytes;\n\n    uint64 public clientNonce;\n    address public interchainDB;\n    address public executionFees;\n    mapping(bytes32 =\u003e bool) public executedTransactions;\n\n    // Chain ID =\u003e Bytes32 Address of src clients\n    mapping(uint256 =\u003e bytes32) public linkedClients;\n\n    constructor() Ownable(msg.sender) {}\n\n    // @inheritdoc IInterchainClientV1\n    function setExecutionFees(address executionFees_) public onlyOwner {\n        executionFees = executionFees_;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setInterchainDB(address _interchainDB) public onlyOwner {\n        interchainDB = _interchainDB;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint256 chainId, bytes32 client) public onlyOwner {\n        linkedClients[chainId] = client;\n    }\n\n    // TODO: Calculate Gas Pricing per module and charge fees\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        public\n        payable\n    {\n        // TODO: should check options for being correctly formatted\n        uint256 verificationFee = IInterchainDB(interchainDB).getInterchainFee(dstChainId, srcModules);\n        // TODO: should check msg.value \u003e= verificationFee\n        uint256 executionFee = msg.value - verificationFee;\n\n        InterchainTransaction memory icTx = InterchainTransactionLib.constructLocalTransaction({\n            srcSender: msg.sender,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            nonce: clientNonce,\n            dbNonce: IInterchainDB(interchainDB).getDBNonce(),\n            options: options,\n            message: message\n        });\n\n        bytes32 transactionId = icTx.transactionId();\n        // Sanity check: nonce returned from DB should match the nonce used to construct the transaction\n        assert(\n            icTx.dbNonce\n                == IInterchainDB(interchainDB).writeEntryWithVerification{value: verificationFee}(\n                    icTx.dstChainId, transactionId, srcModules\n                )\n        );\n        if (srcExecutionService != address(0)) {\n            IExecutionService(srcExecutionService).requestExecution({\n                dstChainId: dstChainId,\n                // TODO: there should be a way to calculate the payload size without encoding the transaction\n                txPayloadSize: abi.encode(icTx).length,\n                transactionId: transactionId,\n                executionFee: executionFee,\n                options: options\n            });\n        }\n        IExecutionFees(executionFees).addExecutionFee{value: executionFee}(icTx.dstChainId, transactionId);\n        emit InterchainTransactionSent(\n            transactionId,\n            icTx.dbNonce,\n            icTx.dstChainId,\n            icTx.srcSender,\n            icTx.dstReceiver,\n            verificationFee,\n            executionFee,\n            options,\n            message\n        );\n        // Increment nonce for next message\n        clientNonce++;\n    }\n\n    // TODO: App Config Versioning\n    // TODO: What if receiver is not a contract / doesn't conform to interface?\n    /**\n     * @dev Retrieves the application configuration for a given receiver application.\n     * @param receiverApp The address of the receiver application.\n     * @return requiredResponses The number of required responses from the receiving modules.\n     * @return optimisticTimePeriod The time period within which responses are considered valid.\n     * @return approvedDstModules An array of addresses of the approved destination modules.\n     */\n    function _getAppConfig(address receiverApp)\n        internal\n        view\n        returns (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules)\n    {\n        bytes memory appConfig;\n        (appConfig, approvedDstModules) = IInterchainApp(receiverApp).getReceivingConfig();\n        AppConfigV1 memory decodedAppConfig = appConfig.decodeAppConfigV1();\n        requiredResponses = decodedAppConfig.requiredResponses;\n        optimisticTimePeriod = decodedAppConfig.optimisticPeriod;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata encodedTx) public view returns (bool) {\n        InterchainTransaction memory icTx = InterchainTransactionLib.decodeTransaction(encodedTx);\n        bytes32 transactionId = icTx.transactionId();\n        return _isExecutable(transactionId, icTx);\n    }\n\n    function _isExecutable(bytes32 transactionId, InterchainTransaction memory icTx) internal view returns (bool) {\n        require(executedTransactions[transactionId] == false, \"Transaction already executed\");\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            dbNonce: icTx.dbNonce,\n            srcWriter: linkedClients[icTx.srcChainId],\n            dataHash: transactionId\n        });\n\n        (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules) =\n            _getAppConfig(TypeCasts.bytes32ToAddress(icTx.dstReceiver));\n\n        uint256[] memory approvedResponses = _getApprovedResponses(approvedDstModules, icEntry);\n\n        uint256 finalizedResponses = _getFinalizedResponsesCount(approvedResponses, optimisticTimePeriod);\n        require(finalizedResponses \u003e= requiredResponses, \"Not enough valid responses to meet the threshold\");\n        return true;\n    }\n\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedResponses An array of timestamps when each approved response was recorded.\n     * @param optimisticTimePeriod The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses The count of responses that are finalized within the optimistic time period.\n     */\n    function _getFinalizedResponsesCount(\n        uint256[] memory approvedResponses,\n        uint256 optimisticTimePeriod\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 finalizedResponses = 0;\n        for (uint256 i = 0; i \u003c approvedResponses.length; i++) {\n            if (approvedResponses[i] + optimisticTimePeriod \u003c= block.timestamp) {\n                finalizedResponses++;\n            }\n        }\n        return finalizedResponses;\n    }\n    /**\n     * @dev Retrieves the responses from approved modules for a given InterchainEntry.\n     * This function iterates over all approved modules, querying the InterchainDB for each module's response\n     * to the provided InterchainEntry. It compiles these responses into an array of uint256, where each\n     * element represents the timestamp of a module's response.\n     *\n     * @param approvedModules An array of addresses representing the approved modules that can write responses.\n     * @param icEntry The InterchainEntry for which responses are being retrieved.\n     * @return approvedResponses An array of uint256 representing the timestamps of responses from approved modules.\n     */\n\n    function _getApprovedResponses(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry\n    )\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory approvedResponses = new uint256[](approvedModules.length);\n        for (uint256 i = 0; i \u003c approvedModules.length; i++) {\n            approvedResponses[i] = IInterchainDB(interchainDB).readEntry(approvedModules[i], icEntry);\n        }\n        return approvedResponses;\n    }\n\n    function encodeTransaction(InterchainTransaction memory icTx) public view returns (bytes memory) {\n        return abi.encode(icTx);\n    }\n\n    function encodeOptionsV1(OptionsV1 memory options) public view returns (bytes memory) {\n        return options.encodeOptionsV1();\n    }\n\n    // TODO: Gas Fee Consideration that is paid to executor\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(uint256 gasLimit, bytes calldata transaction) external payable {\n        InterchainTransaction memory icTx = InterchainTransactionLib.decodeTransaction(transaction);\n        bytes32 transactionId = icTx.transactionId();\n        require(_isExecutable(transactionId, icTx), \"Transaction is not executable\");\n        executedTransactions[transactionId] = true;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n        if (msg.value != decodedOptions.gasAirdrop) {\n            revert InterchainClientV1__IncorrectMsgValue(msg.value, decodedOptions.gasAirdrop);\n        }\n        // We should always use at least as much as the requested gas limit.\n        // The executor can specify a higher gas limit if they wanted.\n        if (decodedOptions.gasLimit \u003e gasLimit) gasLimit = decodedOptions.gasLimit;\n        // Pass the full msg.value to the app: we have already checked that it matches the requested gas airdrop.\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: gasLimit, value: msg.value}({\n            srcChainId: icTx.srcChainId,\n            sender: icTx.srcSender,\n            nonce: icTx.nonce,\n            message: icTx.message\n        });\n        emit InterchainTransactionReceived(\n            transactionId, icTx.dbNonce, icTx.srcChainId, icTx.srcSender, icTx.dstReceiver\n        );\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"9670:2072:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;9670:2072:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"9670:2072:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[{"internalType":"uint8","name":"version","type":"uint8"}],"name":"AppConfigLib__IncorrectVersion","type":"error"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"AppConfigLib__IncorrectVersion\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"AppConfigLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0xb1820886ef923c4c065c5baff37b5df87b8df1e6d6b4c15efa8656e6bf9bab55\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://d5135fd5a15dd9be50d78f48a77d63d2477f99180a88a45d658259fa89e992a9\",\"dweb:/ipfs/QmeHcqSVFPtKYu1XVd751xBixEPBV2b3rN2jMUYAMKTKqN\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainClientV1.sol:Context":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainClientV1Events.sol\n\nabstract contract InterchainClientV1Events {\n    // TODO: figure out indexing\n\n    event InterchainTransactionSent(\n        bytes32 indexed transactionId,\n        uint256 indexed dbNonce,\n        uint256 dstChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver,\n        uint256 verificationFee,\n        uint256 executionFee,\n        bytes options,\n        bytes message\n    );\n\n    event InterchainTransactionReceived(\n        bytes32 indexed transactionId,\n        uint256 indexed dbNonce,\n        uint256 srcChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver\n    );\n}\n\n// contracts/interfaces/IExecutionFees.sol\n\ninterface IExecutionFees {\n    /// @notice Add the execution fee for a transaction. The attached value will be added to the\n    /// rewards for the executor completing the transaction.\n    /// Note: this could be used to store the execution fee for a new transaction, or to add more\n    /// funds to the execution fee of an existing transaction. Therefore this function is payable,\n    /// and does not implement any caller restrictions.\n    /// @dev Will revert if the executor is already recorded for the transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to add the execution fee to.\n    function addExecutionFee(uint256 dstChainId, bytes32 transactionId) external payable;\n\n    /// @notice Record the executor (who completed the transaction) for a transaction,\n    /// and update the accumulated rewards for the executor.\n    /// @dev Could only be called by the Recorder.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to record the executor for.\n    /// @param executor             The address of the executor who completed the transaction.\n    function recordExecutor(uint256 dstChainId, bytes32 transactionId, address executor) external;\n\n    /// @notice Allows the executor to claim their unclaimed rewards.\n    /// @dev Will revert if the executor has no unclaimed rewards.\n    function claimExecutionFees() external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the accumulated rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function getAccumulatedRewards(address executor) external view returns (uint256 accumulated);\n\n    /// @notice Get the unclaimed rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function getUnclaimedRewards(address executor) external view returns (uint256 unclaimed);\n}\n\n// contracts/interfaces/IExecutionService.sol\n\ninterface IExecutionService {\n    /// @notice Request the execution of an Interchain Transaction on a remote chain.\n    /// Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient\n    /// event with the same transactionId, then execute the transaction on the remote chain:\n    /// `dstInterchainClient.executeTransaction(transactionPayload)`\n    /// Once the execution is confirmed on the source chain, the off-chain actor will be able\n    /// to claim `executionFee` in the ExecutionFees contract.\n    /// @dev Could only be called by `InterchainClient` contracts.\n    /// Will revert if the execution fee is not big enough.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param transactionId        The id of the transaction to execute.\n    /// @param executionFee         The fee paid for the execution.\n    /// @param options              The options to use for the execution.\n    function requestExecution(\n        uint256 dstChainId,\n        uint256 txPayloadSize,\n        bytes32 transactionId,\n        uint256 executionFee,\n        bytes memory options\n    )\n        external;\n\n    /// @notice Get the execution fee for executing an Interchain Transaction on a remote chain.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param options              The options to use for the execution.\n    function getExecutionFee(\n        uint256 dstChainId,\n        uint256 txPayloadSize,\n        bytes memory options\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\ninterface IInterchainApp {\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory sendingModules,\n        address[] memory receivingModules,\n        uint256 requiredResponses,\n        uint64 optimisticTimePeriod\n    )\n        external;\n\n    function getLinkedIApp(uint64 chainID) external view returns (address);\n\n    function getSendingModules() external view returns (address[] memory);\n\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable;\n\n    function appReceive(uint256 srcChainId, bytes32 sender, uint64 nonce, bytes calldata message) external payable;\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 expected);\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sets the address of the InterchainDB contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param _interchainDB The address of the InterchainDB contract.\n     */\n    function setInterchainDB(address _interchainDB) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently primarily gas limit + native gas drop.\n     * @param message The message being sent.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     */\n    function interchainExecute(uint256 gasLimit, bytes calldata transaction) external payable;\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction The InterchainTransaction struct to be checked.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction) external view returns (bool);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    uint8 constant OPTIONS_V1 = 1;\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the entry on the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint64 nonce;\n    uint256 dbNonce;\n    bytes options;\n    bytes message;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint64 nonce,\n        uint256 dbNonce,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            nonce: nonce,\n            dbNonce: dbNonce,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the local Interchain DataBase.\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    struct LocalEntry {\n        address writer;\n        bytes32 dataHash;\n    }\n\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param entryValue   The value of the entry: writer + dataHash hashed together\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 entryValue;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingEntryValue, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(uint256 dbNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the written entry on this chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(uint256 destChainId, uint256 dbNonce, address[] memory srcModules) external payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`\n    /// by providing the returned `dbNonce`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param dbNonce      The database nonce of the written entry on this chain\n    function getEntry(uint256 dbNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the database.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, InterchainClientV1Events, IInterchainClientV1 {\n    using AppConfigLib for bytes;\n    using OptionsLib for bytes;\n\n    uint64 public clientNonce;\n    address public interchainDB;\n    address public executionFees;\n    mapping(bytes32 =\u003e bool) public executedTransactions;\n\n    // Chain ID =\u003e Bytes32 Address of src clients\n    mapping(uint256 =\u003e bytes32) public linkedClients;\n\n    constructor() Ownable(msg.sender) {}\n\n    // @inheritdoc IInterchainClientV1\n    function setExecutionFees(address executionFees_) public onlyOwner {\n        executionFees = executionFees_;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setInterchainDB(address _interchainDB) public onlyOwner {\n        interchainDB = _interchainDB;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint256 chainId, bytes32 client) public onlyOwner {\n        linkedClients[chainId] = client;\n    }\n\n    // TODO: Calculate Gas Pricing per module and charge fees\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        public\n        payable\n    {\n        // TODO: should check options for being correctly formatted\n        uint256 verificationFee = IInterchainDB(interchainDB).getInterchainFee(dstChainId, srcModules);\n        // TODO: should check msg.value \u003e= verificationFee\n        uint256 executionFee = msg.value - verificationFee;\n\n        InterchainTransaction memory icTx = InterchainTransactionLib.constructLocalTransaction({\n            srcSender: msg.sender,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            nonce: clientNonce,\n            dbNonce: IInterchainDB(interchainDB).getDBNonce(),\n            options: options,\n            message: message\n        });\n\n        bytes32 transactionId = icTx.transactionId();\n        // Sanity check: nonce returned from DB should match the nonce used to construct the transaction\n        assert(\n            icTx.dbNonce\n                == IInterchainDB(interchainDB).writeEntryWithVerification{value: verificationFee}(\n                    icTx.dstChainId, transactionId, srcModules\n                )\n        );\n        if (srcExecutionService != address(0)) {\n            IExecutionService(srcExecutionService).requestExecution({\n                dstChainId: dstChainId,\n                // TODO: there should be a way to calculate the payload size without encoding the transaction\n                txPayloadSize: abi.encode(icTx).length,\n                transactionId: transactionId,\n                executionFee: executionFee,\n                options: options\n            });\n        }\n        IExecutionFees(executionFees).addExecutionFee{value: executionFee}(icTx.dstChainId, transactionId);\n        emit InterchainTransactionSent(\n            transactionId,\n            icTx.dbNonce,\n            icTx.dstChainId,\n            icTx.srcSender,\n            icTx.dstReceiver,\n            verificationFee,\n            executionFee,\n            options,\n            message\n        );\n        // Increment nonce for next message\n        clientNonce++;\n    }\n\n    // TODO: App Config Versioning\n    // TODO: What if receiver is not a contract / doesn't conform to interface?\n    /**\n     * @dev Retrieves the application configuration for a given receiver application.\n     * @param receiverApp The address of the receiver application.\n     * @return requiredResponses The number of required responses from the receiving modules.\n     * @return optimisticTimePeriod The time period within which responses are considered valid.\n     * @return approvedDstModules An array of addresses of the approved destination modules.\n     */\n    function _getAppConfig(address receiverApp)\n        internal\n        view\n        returns (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules)\n    {\n        bytes memory appConfig;\n        (appConfig, approvedDstModules) = IInterchainApp(receiverApp).getReceivingConfig();\n        AppConfigV1 memory decodedAppConfig = appConfig.decodeAppConfigV1();\n        requiredResponses = decodedAppConfig.requiredResponses;\n        optimisticTimePeriod = decodedAppConfig.optimisticPeriod;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata encodedTx) public view returns (bool) {\n        InterchainTransaction memory icTx = InterchainTransactionLib.decodeTransaction(encodedTx);\n        bytes32 transactionId = icTx.transactionId();\n        return _isExecutable(transactionId, icTx);\n    }\n\n    function _isExecutable(bytes32 transactionId, InterchainTransaction memory icTx) internal view returns (bool) {\n        require(executedTransactions[transactionId] == false, \"Transaction already executed\");\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            dbNonce: icTx.dbNonce,\n            srcWriter: linkedClients[icTx.srcChainId],\n            dataHash: transactionId\n        });\n\n        (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules) =\n            _getAppConfig(TypeCasts.bytes32ToAddress(icTx.dstReceiver));\n\n        uint256[] memory approvedResponses = _getApprovedResponses(approvedDstModules, icEntry);\n\n        uint256 finalizedResponses = _getFinalizedResponsesCount(approvedResponses, optimisticTimePeriod);\n        require(finalizedResponses \u003e= requiredResponses, \"Not enough valid responses to meet the threshold\");\n        return true;\n    }\n\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedResponses An array of timestamps when each approved response was recorded.\n     * @param optimisticTimePeriod The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses The count of responses that are finalized within the optimistic time period.\n     */\n    function _getFinalizedResponsesCount(\n        uint256[] memory approvedResponses,\n        uint256 optimisticTimePeriod\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 finalizedResponses = 0;\n        for (uint256 i = 0; i \u003c approvedResponses.length; i++) {\n            if (approvedResponses[i] + optimisticTimePeriod \u003c= block.timestamp) {\n                finalizedResponses++;\n            }\n        }\n        return finalizedResponses;\n    }\n    /**\n     * @dev Retrieves the responses from approved modules for a given InterchainEntry.\n     * This function iterates over all approved modules, querying the InterchainDB for each module's response\n     * to the provided InterchainEntry. It compiles these responses into an array of uint256, where each\n     * element represents the timestamp of a module's response.\n     *\n     * @param approvedModules An array of addresses representing the approved modules that can write responses.\n     * @param icEntry The InterchainEntry for which responses are being retrieved.\n     * @return approvedResponses An array of uint256 representing the timestamps of responses from approved modules.\n     */\n\n    function _getApprovedResponses(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry\n    )\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory approvedResponses = new uint256[](approvedModules.length);\n        for (uint256 i = 0; i \u003c approvedModules.length; i++) {\n            approvedResponses[i] = IInterchainDB(interchainDB).readEntry(approvedModules[i], icEntry);\n        }\n        return approvedResponses;\n    }\n\n    function encodeTransaction(InterchainTransaction memory icTx) public view returns (bytes memory) {\n        return abi.encode(icTx);\n    }\n\n    function encodeOptionsV1(OptionsV1 memory options) public view returns (bytes memory) {\n        return options.encodeOptionsV1();\n    }\n\n    // TODO: Gas Fee Consideration that is paid to executor\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(uint256 gasLimit, bytes calldata transaction) external payable {\n        InterchainTransaction memory icTx = InterchainTransactionLib.decodeTransaction(transaction);\n        bytes32 transactionId = icTx.transactionId();\n        require(_isExecutable(transactionId, icTx), \"Transaction is not executable\");\n        executedTransactions[transactionId] = true;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n        if (msg.value != decodedOptions.gasAirdrop) {\n            revert InterchainClientV1__IncorrectMsgValue(msg.value, decodedOptions.gasAirdrop);\n        }\n        // We should always use at least as much as the requested gas limit.\n        // The executor can specify a higher gas limit if they wanted.\n        if (decodedOptions.gasLimit \u003e gasLimit) gasLimit = decodedOptions.gasLimit;\n        // Pass the full msg.value to the app: we have already checked that it matches the requested gas airdrop.\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: gasLimit, value: msg.value}({\n            srcChainId: icTx.srcChainId,\n            sender: icTx.srcSender,\n            nonce: icTx.nonce,\n            message: icTx.message\n        });\n        emit InterchainTransactionReceived(\n            transactionId, icTx.dbNonce, icTx.srcChainId, icTx.srcSender, icTx.dstReceiver\n        );\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Provides information about the current execution context, including the sender of the transaction and its data. While these are generally available via msg.sender and msg.data, they should not be accessed in such a direct manner, since when dealing with meta-transactions the account sending and paying for execution may not be the actual sender (as far as an application is concerned). This contract is only required for intermediate, library-like contracts.","kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Provides information about the current execution context, including the sender of the transaction and its data. While these are generally available via msg.sender and msg.data, they should not be accessed in such a direct manner, since when dealing with meta-transactions the account sending and paying for execution may not be the actual sender (as far as an application is concerned). This contract is only required for intermediate, library-like contracts.\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"Context\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0xb1820886ef923c4c065c5baff37b5df87b8df1e6d6b4c15efa8656e6bf9bab55\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://d5135fd5a15dd9be50d78f48a77d63d2477f99180a88a45d658259fa89e992a9\",\"dweb:/ipfs/QmeHcqSVFPtKYu1XVd751xBixEPBV2b3rN2jMUYAMKTKqN\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainClientV1.sol:IExecutionFees":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainClientV1Events.sol\n\nabstract contract InterchainClientV1Events {\n    // TODO: figure out indexing\n\n    event InterchainTransactionSent(\n        bytes32 indexed transactionId,\n        uint256 indexed dbNonce,\n        uint256 dstChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver,\n        uint256 verificationFee,\n        uint256 executionFee,\n        bytes options,\n        bytes message\n    );\n\n    event InterchainTransactionReceived(\n        bytes32 indexed transactionId,\n        uint256 indexed dbNonce,\n        uint256 srcChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver\n    );\n}\n\n// contracts/interfaces/IExecutionFees.sol\n\ninterface IExecutionFees {\n    /// @notice Add the execution fee for a transaction. The attached value will be added to the\n    /// rewards for the executor completing the transaction.\n    /// Note: this could be used to store the execution fee for a new transaction, or to add more\n    /// funds to the execution fee of an existing transaction. Therefore this function is payable,\n    /// and does not implement any caller restrictions.\n    /// @dev Will revert if the executor is already recorded for the transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to add the execution fee to.\n    function addExecutionFee(uint256 dstChainId, bytes32 transactionId) external payable;\n\n    /// @notice Record the executor (who completed the transaction) for a transaction,\n    /// and update the accumulated rewards for the executor.\n    /// @dev Could only be called by the Recorder.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to record the executor for.\n    /// @param executor             The address of the executor who completed the transaction.\n    function recordExecutor(uint256 dstChainId, bytes32 transactionId, address executor) external;\n\n    /// @notice Allows the executor to claim their unclaimed rewards.\n    /// @dev Will revert if the executor has no unclaimed rewards.\n    function claimExecutionFees() external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the accumulated rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function getAccumulatedRewards(address executor) external view returns (uint256 accumulated);\n\n    /// @notice Get the unclaimed rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function getUnclaimedRewards(address executor) external view returns (uint256 unclaimed);\n}\n\n// contracts/interfaces/IExecutionService.sol\n\ninterface IExecutionService {\n    /// @notice Request the execution of an Interchain Transaction on a remote chain.\n    /// Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient\n    /// event with the same transactionId, then execute the transaction on the remote chain:\n    /// `dstInterchainClient.executeTransaction(transactionPayload)`\n    /// Once the execution is confirmed on the source chain, the off-chain actor will be able\n    /// to claim `executionFee` in the ExecutionFees contract.\n    /// @dev Could only be called by `InterchainClient` contracts.\n    /// Will revert if the execution fee is not big enough.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param transactionId        The id of the transaction to execute.\n    /// @param executionFee         The fee paid for the execution.\n    /// @param options              The options to use for the execution.\n    function requestExecution(\n        uint256 dstChainId,\n        uint256 txPayloadSize,\n        bytes32 transactionId,\n        uint256 executionFee,\n        bytes memory options\n    )\n        external;\n\n    /// @notice Get the execution fee for executing an Interchain Transaction on a remote chain.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param options              The options to use for the execution.\n    function getExecutionFee(\n        uint256 dstChainId,\n        uint256 txPayloadSize,\n        bytes memory options\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\ninterface IInterchainApp {\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory sendingModules,\n        address[] memory receivingModules,\n        uint256 requiredResponses,\n        uint64 optimisticTimePeriod\n    )\n        external;\n\n    function getLinkedIApp(uint64 chainID) external view returns (address);\n\n    function getSendingModules() external view returns (address[] memory);\n\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable;\n\n    function appReceive(uint256 srcChainId, bytes32 sender, uint64 nonce, bytes calldata message) external payable;\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 expected);\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sets the address of the InterchainDB contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param _interchainDB The address of the InterchainDB contract.\n     */\n    function setInterchainDB(address _interchainDB) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently primarily gas limit + native gas drop.\n     * @param message The message being sent.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     */\n    function interchainExecute(uint256 gasLimit, bytes calldata transaction) external payable;\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction The InterchainTransaction struct to be checked.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction) external view returns (bool);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    uint8 constant OPTIONS_V1 = 1;\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the entry on the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint64 nonce;\n    uint256 dbNonce;\n    bytes options;\n    bytes message;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint64 nonce,\n        uint256 dbNonce,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            nonce: nonce,\n            dbNonce: dbNonce,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the local Interchain DataBase.\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    struct LocalEntry {\n        address writer;\n        bytes32 dataHash;\n    }\n\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param entryValue   The value of the entry: writer + dataHash hashed together\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 entryValue;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingEntryValue, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(uint256 dbNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the written entry on this chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(uint256 destChainId, uint256 dbNonce, address[] memory srcModules) external payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`\n    /// by providing the returned `dbNonce`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param dbNonce      The database nonce of the written entry on this chain\n    function getEntry(uint256 dbNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the database.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, InterchainClientV1Events, IInterchainClientV1 {\n    using AppConfigLib for bytes;\n    using OptionsLib for bytes;\n\n    uint64 public clientNonce;\n    address public interchainDB;\n    address public executionFees;\n    mapping(bytes32 =\u003e bool) public executedTransactions;\n\n    // Chain ID =\u003e Bytes32 Address of src clients\n    mapping(uint256 =\u003e bytes32) public linkedClients;\n\n    constructor() Ownable(msg.sender) {}\n\n    // @inheritdoc IInterchainClientV1\n    function setExecutionFees(address executionFees_) public onlyOwner {\n        executionFees = executionFees_;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setInterchainDB(address _interchainDB) public onlyOwner {\n        interchainDB = _interchainDB;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint256 chainId, bytes32 client) public onlyOwner {\n        linkedClients[chainId] = client;\n    }\n\n    // TODO: Calculate Gas Pricing per module and charge fees\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        public\n        payable\n    {\n        // TODO: should check options for being correctly formatted\n        uint256 verificationFee = IInterchainDB(interchainDB).getInterchainFee(dstChainId, srcModules);\n        // TODO: should check msg.value \u003e= verificationFee\n        uint256 executionFee = msg.value - verificationFee;\n\n        InterchainTransaction memory icTx = InterchainTransactionLib.constructLocalTransaction({\n            srcSender: msg.sender,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            nonce: clientNonce,\n            dbNonce: IInterchainDB(interchainDB).getDBNonce(),\n            options: options,\n            message: message\n        });\n\n        bytes32 transactionId = icTx.transactionId();\n        // Sanity check: nonce returned from DB should match the nonce used to construct the transaction\n        assert(\n            icTx.dbNonce\n                == IInterchainDB(interchainDB).writeEntryWithVerification{value: verificationFee}(\n                    icTx.dstChainId, transactionId, srcModules\n                )\n        );\n        if (srcExecutionService != address(0)) {\n            IExecutionService(srcExecutionService).requestExecution({\n                dstChainId: dstChainId,\n                // TODO: there should be a way to calculate the payload size without encoding the transaction\n                txPayloadSize: abi.encode(icTx).length,\n                transactionId: transactionId,\n                executionFee: executionFee,\n                options: options\n            });\n        }\n        IExecutionFees(executionFees).addExecutionFee{value: executionFee}(icTx.dstChainId, transactionId);\n        emit InterchainTransactionSent(\n            transactionId,\n            icTx.dbNonce,\n            icTx.dstChainId,\n            icTx.srcSender,\n            icTx.dstReceiver,\n            verificationFee,\n            executionFee,\n            options,\n            message\n        );\n        // Increment nonce for next message\n        clientNonce++;\n    }\n\n    // TODO: App Config Versioning\n    // TODO: What if receiver is not a contract / doesn't conform to interface?\n    /**\n     * @dev Retrieves the application configuration for a given receiver application.\n     * @param receiverApp The address of the receiver application.\n     * @return requiredResponses The number of required responses from the receiving modules.\n     * @return optimisticTimePeriod The time period within which responses are considered valid.\n     * @return approvedDstModules An array of addresses of the approved destination modules.\n     */\n    function _getAppConfig(address receiverApp)\n        internal\n        view\n        returns (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules)\n    {\n        bytes memory appConfig;\n        (appConfig, approvedDstModules) = IInterchainApp(receiverApp).getReceivingConfig();\n        AppConfigV1 memory decodedAppConfig = appConfig.decodeAppConfigV1();\n        requiredResponses = decodedAppConfig.requiredResponses;\n        optimisticTimePeriod = decodedAppConfig.optimisticPeriod;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata encodedTx) public view returns (bool) {\n        InterchainTransaction memory icTx = InterchainTransactionLib.decodeTransaction(encodedTx);\n        bytes32 transactionId = icTx.transactionId();\n        return _isExecutable(transactionId, icTx);\n    }\n\n    function _isExecutable(bytes32 transactionId, InterchainTransaction memory icTx) internal view returns (bool) {\n        require(executedTransactions[transactionId] == false, \"Transaction already executed\");\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            dbNonce: icTx.dbNonce,\n            srcWriter: linkedClients[icTx.srcChainId],\n            dataHash: transactionId\n        });\n\n        (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules) =\n            _getAppConfig(TypeCasts.bytes32ToAddress(icTx.dstReceiver));\n\n        uint256[] memory approvedResponses = _getApprovedResponses(approvedDstModules, icEntry);\n\n        uint256 finalizedResponses = _getFinalizedResponsesCount(approvedResponses, optimisticTimePeriod);\n        require(finalizedResponses \u003e= requiredResponses, \"Not enough valid responses to meet the threshold\");\n        return true;\n    }\n\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedResponses An array of timestamps when each approved response was recorded.\n     * @param optimisticTimePeriod The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses The count of responses that are finalized within the optimistic time period.\n     */\n    function _getFinalizedResponsesCount(\n        uint256[] memory approvedResponses,\n        uint256 optimisticTimePeriod\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 finalizedResponses = 0;\n        for (uint256 i = 0; i \u003c approvedResponses.length; i++) {\n            if (approvedResponses[i] + optimisticTimePeriod \u003c= block.timestamp) {\n                finalizedResponses++;\n            }\n        }\n        return finalizedResponses;\n    }\n    /**\n     * @dev Retrieves the responses from approved modules for a given InterchainEntry.\n     * This function iterates over all approved modules, querying the InterchainDB for each module's response\n     * to the provided InterchainEntry. It compiles these responses into an array of uint256, where each\n     * element represents the timestamp of a module's response.\n     *\n     * @param approvedModules An array of addresses representing the approved modules that can write responses.\n     * @param icEntry The InterchainEntry for which responses are being retrieved.\n     * @return approvedResponses An array of uint256 representing the timestamps of responses from approved modules.\n     */\n\n    function _getApprovedResponses(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry\n    )\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory approvedResponses = new uint256[](approvedModules.length);\n        for (uint256 i = 0; i \u003c approvedModules.length; i++) {\n            approvedResponses[i] = IInterchainDB(interchainDB).readEntry(approvedModules[i], icEntry);\n        }\n        return approvedResponses;\n    }\n\n    function encodeTransaction(InterchainTransaction memory icTx) public view returns (bytes memory) {\n        return abi.encode(icTx);\n    }\n\n    function encodeOptionsV1(OptionsV1 memory options) public view returns (bytes memory) {\n        return options.encodeOptionsV1();\n    }\n\n    // TODO: Gas Fee Consideration that is paid to executor\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(uint256 gasLimit, bytes calldata transaction) external payable {\n        InterchainTransaction memory icTx = InterchainTransactionLib.decodeTransaction(transaction);\n        bytes32 transactionId = icTx.transactionId();\n        require(_isExecutable(transactionId, icTx), \"Transaction is not executable\");\n        executedTransactions[transactionId] = true;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n        if (msg.value != decodedOptions.gasAirdrop) {\n            revert InterchainClientV1__IncorrectMsgValue(msg.value, decodedOptions.gasAirdrop);\n        }\n        // We should always use at least as much as the requested gas limit.\n        // The executor can specify a higher gas limit if they wanted.\n        if (decodedOptions.gasLimit \u003e gasLimit) gasLimit = decodedOptions.gasLimit;\n        // Pass the full msg.value to the app: we have already checked that it matches the requested gas airdrop.\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: gasLimit, value: msg.value}({\n            srcChainId: icTx.srcChainId,\n            sender: icTx.srcSender,\n            nonce: icTx.nonce,\n            message: icTx.message\n        });\n        emit InterchainTransactionReceived(\n            transactionId, icTx.dbNonce, icTx.srcChainId, icTx.srcSender, icTx.dstReceiver\n        );\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"addExecutionFee","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"claimExecutionFees","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"executor","type":"address"}],"name":"getAccumulatedRewards","outputs":[{"internalType":"uint256","name":"accumulated","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"executor","type":"address"}],"name":"getUnclaimedRewards","outputs":[{"internalType":"uint256","name":"unclaimed","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"internalType":"address","name":"executor","type":"address"}],"name":"recordExecutor","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"addExecutionFee(uint256,bytes32)":{"notice":"Add the execution fee for a transaction. The attached value will be added to the rewards for the executor completing the transaction. Note: this could be used to store the execution fee for a new transaction, or to add more funds to the execution fee of an existing transaction. Therefore this function is payable, and does not implement any caller restrictions."},"claimExecutionFees()":{"notice":"Allows the executor to claim their unclaimed rewards."},"getAccumulatedRewards(address)":{"notice":"Get the accumulated rewards for an executor."},"getUnclaimedRewards(address)":{"notice":"Get the unclaimed rewards for an executor."},"recordExecutor(uint256,bytes32,address)":{"notice":"Record the executor (who completed the transaction) for a transaction, and update the accumulated rewards for the executor."}},"version":1},"developerDoc":{"kind":"dev","methods":{"addExecutionFee(uint256,bytes32)":{"details":"Will revert if the executor is already recorded for the transaction.","params":{"dstChainId":"The chain id of the destination chain.","transactionId":"The id of the transaction to add the execution fee to."}},"claimExecutionFees()":{"details":"Will revert if the executor has no unclaimed rewards."},"getAccumulatedRewards(address)":{"params":{"executor":"The address of the executor to get the rewards for."}},"getUnclaimedRewards(address)":{"params":{"executor":"The address of the executor to get the rewards for."}},"recordExecutor(uint256,bytes32,address)":{"details":"Could only be called by the Recorder.","params":{"dstChainId":"The chain id of the destination chain.","executor":"The address of the executor who completed the transaction.","transactionId":"The id of the transaction to record the executor for."}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"addExecutionFee\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimExecutionFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"name\":\"getAccumulatedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"accumulated\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"name\":\"getUnclaimedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"unclaimed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"name\":\"recordExecutor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"addExecutionFee(uint256,bytes32)\":{\"details\":\"Will revert if the executor is already recorded for the transaction.\",\"params\":{\"dstChainId\":\"The chain id of the destination chain.\",\"transactionId\":\"The id of the transaction to add the execution fee to.\"}},\"claimExecutionFees()\":{\"details\":\"Will revert if the executor has no unclaimed rewards.\"},\"getAccumulatedRewards(address)\":{\"params\":{\"executor\":\"The address of the executor to get the rewards for.\"}},\"getUnclaimedRewards(address)\":{\"params\":{\"executor\":\"The address of the executor to get the rewards for.\"}},\"recordExecutor(uint256,bytes32,address)\":{\"details\":\"Could only be called by the Recorder.\",\"params\":{\"dstChainId\":\"The chain id of the destination chain.\",\"executor\":\"The address of the executor who completed the transaction.\",\"transactionId\":\"The id of the transaction to record the executor for.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"addExecutionFee(uint256,bytes32)\":{\"notice\":\"Add the execution fee for a transaction. The attached value will be added to the rewards for the executor completing the transaction. Note: this could be used to store the execution fee for a new transaction, or to add more funds to the execution fee of an existing transaction. Therefore this function is payable, and does not implement any caller restrictions.\"},\"claimExecutionFees()\":{\"notice\":\"Allows the executor to claim their unclaimed rewards.\"},\"getAccumulatedRewards(address)\":{\"notice\":\"Get the accumulated rewards for an executor.\"},\"getUnclaimedRewards(address)\":{\"notice\":\"Get the unclaimed rewards for an executor.\"},\"recordExecutor(uint256,bytes32,address)\":{\"notice\":\"Record the executor (who completed the transaction) for a transaction, and update the accumulated rewards for the executor.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"IExecutionFees\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0xb1820886ef923c4c065c5baff37b5df87b8df1e6d6b4c15efa8656e6bf9bab55\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://d5135fd5a15dd9be50d78f48a77d63d2477f99180a88a45d658259fa89e992a9\",\"dweb:/ipfs/QmeHcqSVFPtKYu1XVd751xBixEPBV2b3rN2jMUYAMKTKqN\"]}},\"version\":1}"},"hashes":{"addExecutionFee(uint256,bytes32)":"ffecec7e","claimExecutionFees()":"10886ac4","getAccumulatedRewards(address)":"5ee09669","getUnclaimedRewards(address)":"69a69e29","recordExecutor(uint256,bytes32,address)":"0676b706"}},"solidity/InterchainClientV1.sol:IExecutionService":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainClientV1Events.sol\n\nabstract contract InterchainClientV1Events {\n    // TODO: figure out indexing\n\n    event InterchainTransactionSent(\n        bytes32 indexed transactionId,\n        uint256 indexed dbNonce,\n        uint256 dstChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver,\n        uint256 verificationFee,\n        uint256 executionFee,\n        bytes options,\n        bytes message\n    );\n\n    event InterchainTransactionReceived(\n        bytes32 indexed transactionId,\n        uint256 indexed dbNonce,\n        uint256 srcChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver\n    );\n}\n\n// contracts/interfaces/IExecutionFees.sol\n\ninterface IExecutionFees {\n    /// @notice Add the execution fee for a transaction. The attached value will be added to the\n    /// rewards for the executor completing the transaction.\n    /// Note: this could be used to store the execution fee for a new transaction, or to add more\n    /// funds to the execution fee of an existing transaction. Therefore this function is payable,\n    /// and does not implement any caller restrictions.\n    /// @dev Will revert if the executor is already recorded for the transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to add the execution fee to.\n    function addExecutionFee(uint256 dstChainId, bytes32 transactionId) external payable;\n\n    /// @notice Record the executor (who completed the transaction) for a transaction,\n    /// and update the accumulated rewards for the executor.\n    /// @dev Could only be called by the Recorder.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to record the executor for.\n    /// @param executor             The address of the executor who completed the transaction.\n    function recordExecutor(uint256 dstChainId, bytes32 transactionId, address executor) external;\n\n    /// @notice Allows the executor to claim their unclaimed rewards.\n    /// @dev Will revert if the executor has no unclaimed rewards.\n    function claimExecutionFees() external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the accumulated rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function getAccumulatedRewards(address executor) external view returns (uint256 accumulated);\n\n    /// @notice Get the unclaimed rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function getUnclaimedRewards(address executor) external view returns (uint256 unclaimed);\n}\n\n// contracts/interfaces/IExecutionService.sol\n\ninterface IExecutionService {\n    /// @notice Request the execution of an Interchain Transaction on a remote chain.\n    /// Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient\n    /// event with the same transactionId, then execute the transaction on the remote chain:\n    /// `dstInterchainClient.executeTransaction(transactionPayload)`\n    /// Once the execution is confirmed on the source chain, the off-chain actor will be able\n    /// to claim `executionFee` in the ExecutionFees contract.\n    /// @dev Could only be called by `InterchainClient` contracts.\n    /// Will revert if the execution fee is not big enough.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param transactionId        The id of the transaction to execute.\n    /// @param executionFee         The fee paid for the execution.\n    /// @param options              The options to use for the execution.\n    function requestExecution(\n        uint256 dstChainId,\n        uint256 txPayloadSize,\n        bytes32 transactionId,\n        uint256 executionFee,\n        bytes memory options\n    )\n        external;\n\n    /// @notice Get the execution fee for executing an Interchain Transaction on a remote chain.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param options              The options to use for the execution.\n    function getExecutionFee(\n        uint256 dstChainId,\n        uint256 txPayloadSize,\n        bytes memory options\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\ninterface IInterchainApp {\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory sendingModules,\n        address[] memory receivingModules,\n        uint256 requiredResponses,\n        uint64 optimisticTimePeriod\n    )\n        external;\n\n    function getLinkedIApp(uint64 chainID) external view returns (address);\n\n    function getSendingModules() external view returns (address[] memory);\n\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable;\n\n    function appReceive(uint256 srcChainId, bytes32 sender, uint64 nonce, bytes calldata message) external payable;\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 expected);\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sets the address of the InterchainDB contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param _interchainDB The address of the InterchainDB contract.\n     */\n    function setInterchainDB(address _interchainDB) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently primarily gas limit + native gas drop.\n     * @param message The message being sent.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     */\n    function interchainExecute(uint256 gasLimit, bytes calldata transaction) external payable;\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction The InterchainTransaction struct to be checked.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction) external view returns (bool);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    uint8 constant OPTIONS_V1 = 1;\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the entry on the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint64 nonce;\n    uint256 dbNonce;\n    bytes options;\n    bytes message;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint64 nonce,\n        uint256 dbNonce,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            nonce: nonce,\n            dbNonce: dbNonce,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the local Interchain DataBase.\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    struct LocalEntry {\n        address writer;\n        bytes32 dataHash;\n    }\n\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param entryValue   The value of the entry: writer + dataHash hashed together\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 entryValue;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingEntryValue, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(uint256 dbNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the written entry on this chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(uint256 destChainId, uint256 dbNonce, address[] memory srcModules) external payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`\n    /// by providing the returned `dbNonce`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param dbNonce      The database nonce of the written entry on this chain\n    function getEntry(uint256 dbNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the database.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, InterchainClientV1Events, IInterchainClientV1 {\n    using AppConfigLib for bytes;\n    using OptionsLib for bytes;\n\n    uint64 public clientNonce;\n    address public interchainDB;\n    address public executionFees;\n    mapping(bytes32 =\u003e bool) public executedTransactions;\n\n    // Chain ID =\u003e Bytes32 Address of src clients\n    mapping(uint256 =\u003e bytes32) public linkedClients;\n\n    constructor() Ownable(msg.sender) {}\n\n    // @inheritdoc IInterchainClientV1\n    function setExecutionFees(address executionFees_) public onlyOwner {\n        executionFees = executionFees_;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setInterchainDB(address _interchainDB) public onlyOwner {\n        interchainDB = _interchainDB;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint256 chainId, bytes32 client) public onlyOwner {\n        linkedClients[chainId] = client;\n    }\n\n    // TODO: Calculate Gas Pricing per module and charge fees\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        public\n        payable\n    {\n        // TODO: should check options for being correctly formatted\n        uint256 verificationFee = IInterchainDB(interchainDB).getInterchainFee(dstChainId, srcModules);\n        // TODO: should check msg.value \u003e= verificationFee\n        uint256 executionFee = msg.value - verificationFee;\n\n        InterchainTransaction memory icTx = InterchainTransactionLib.constructLocalTransaction({\n            srcSender: msg.sender,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            nonce: clientNonce,\n            dbNonce: IInterchainDB(interchainDB).getDBNonce(),\n            options: options,\n            message: message\n        });\n\n        bytes32 transactionId = icTx.transactionId();\n        // Sanity check: nonce returned from DB should match the nonce used to construct the transaction\n        assert(\n            icTx.dbNonce\n                == IInterchainDB(interchainDB).writeEntryWithVerification{value: verificationFee}(\n                    icTx.dstChainId, transactionId, srcModules\n                )\n        );\n        if (srcExecutionService != address(0)) {\n            IExecutionService(srcExecutionService).requestExecution({\n                dstChainId: dstChainId,\n                // TODO: there should be a way to calculate the payload size without encoding the transaction\n                txPayloadSize: abi.encode(icTx).length,\n                transactionId: transactionId,\n                executionFee: executionFee,\n                options: options\n            });\n        }\n        IExecutionFees(executionFees).addExecutionFee{value: executionFee}(icTx.dstChainId, transactionId);\n        emit InterchainTransactionSent(\n            transactionId,\n            icTx.dbNonce,\n            icTx.dstChainId,\n            icTx.srcSender,\n            icTx.dstReceiver,\n            verificationFee,\n            executionFee,\n            options,\n            message\n        );\n        // Increment nonce for next message\n        clientNonce++;\n    }\n\n    // TODO: App Config Versioning\n    // TODO: What if receiver is not a contract / doesn't conform to interface?\n    /**\n     * @dev Retrieves the application configuration for a given receiver application.\n     * @param receiverApp The address of the receiver application.\n     * @return requiredResponses The number of required responses from the receiving modules.\n     * @return optimisticTimePeriod The time period within which responses are considered valid.\n     * @return approvedDstModules An array of addresses of the approved destination modules.\n     */\n    function _getAppConfig(address receiverApp)\n        internal\n        view\n        returns (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules)\n    {\n        bytes memory appConfig;\n        (appConfig, approvedDstModules) = IInterchainApp(receiverApp).getReceivingConfig();\n        AppConfigV1 memory decodedAppConfig = appConfig.decodeAppConfigV1();\n        requiredResponses = decodedAppConfig.requiredResponses;\n        optimisticTimePeriod = decodedAppConfig.optimisticPeriod;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata encodedTx) public view returns (bool) {\n        InterchainTransaction memory icTx = InterchainTransactionLib.decodeTransaction(encodedTx);\n        bytes32 transactionId = icTx.transactionId();\n        return _isExecutable(transactionId, icTx);\n    }\n\n    function _isExecutable(bytes32 transactionId, InterchainTransaction memory icTx) internal view returns (bool) {\n        require(executedTransactions[transactionId] == false, \"Transaction already executed\");\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            dbNonce: icTx.dbNonce,\n            srcWriter: linkedClients[icTx.srcChainId],\n            dataHash: transactionId\n        });\n\n        (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules) =\n            _getAppConfig(TypeCasts.bytes32ToAddress(icTx.dstReceiver));\n\n        uint256[] memory approvedResponses = _getApprovedResponses(approvedDstModules, icEntry);\n\n        uint256 finalizedResponses = _getFinalizedResponsesCount(approvedResponses, optimisticTimePeriod);\n        require(finalizedResponses \u003e= requiredResponses, \"Not enough valid responses to meet the threshold\");\n        return true;\n    }\n\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedResponses An array of timestamps when each approved response was recorded.\n     * @param optimisticTimePeriod The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses The count of responses that are finalized within the optimistic time period.\n     */\n    function _getFinalizedResponsesCount(\n        uint256[] memory approvedResponses,\n        uint256 optimisticTimePeriod\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 finalizedResponses = 0;\n        for (uint256 i = 0; i \u003c approvedResponses.length; i++) {\n            if (approvedResponses[i] + optimisticTimePeriod \u003c= block.timestamp) {\n                finalizedResponses++;\n            }\n        }\n        return finalizedResponses;\n    }\n    /**\n     * @dev Retrieves the responses from approved modules for a given InterchainEntry.\n     * This function iterates over all approved modules, querying the InterchainDB for each module's response\n     * to the provided InterchainEntry. It compiles these responses into an array of uint256, where each\n     * element represents the timestamp of a module's response.\n     *\n     * @param approvedModules An array of addresses representing the approved modules that can write responses.\n     * @param icEntry The InterchainEntry for which responses are being retrieved.\n     * @return approvedResponses An array of uint256 representing the timestamps of responses from approved modules.\n     */\n\n    function _getApprovedResponses(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry\n    )\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory approvedResponses = new uint256[](approvedModules.length);\n        for (uint256 i = 0; i \u003c approvedModules.length; i++) {\n            approvedResponses[i] = IInterchainDB(interchainDB).readEntry(approvedModules[i], icEntry);\n        }\n        return approvedResponses;\n    }\n\n    function encodeTransaction(InterchainTransaction memory icTx) public view returns (bytes memory) {\n        return abi.encode(icTx);\n    }\n\n    function encodeOptionsV1(OptionsV1 memory options) public view returns (bytes memory) {\n        return options.encodeOptionsV1();\n    }\n\n    // TODO: Gas Fee Consideration that is paid to executor\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(uint256 gasLimit, bytes calldata transaction) external payable {\n        InterchainTransaction memory icTx = InterchainTransactionLib.decodeTransaction(transaction);\n        bytes32 transactionId = icTx.transactionId();\n        require(_isExecutable(transactionId, icTx), \"Transaction is not executable\");\n        executedTransactions[transactionId] = true;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n        if (msg.value != decodedOptions.gasAirdrop) {\n            revert InterchainClientV1__IncorrectMsgValue(msg.value, decodedOptions.gasAirdrop);\n        }\n        // We should always use at least as much as the requested gas limit.\n        // The executor can specify a higher gas limit if they wanted.\n        if (decodedOptions.gasLimit \u003e gasLimit) gasLimit = decodedOptions.gasLimit;\n        // Pass the full msg.value to the app: we have already checked that it matches the requested gas airdrop.\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: gasLimit, value: msg.value}({\n            srcChainId: icTx.srcChainId,\n            sender: icTx.srcSender,\n            nonce: icTx.nonce,\n            message: icTx.message\n        });\n        emit InterchainTransactionReceived(\n            transactionId, icTx.dbNonce, icTx.srcChainId, icTx.srcSender, icTx.dstReceiver\n        );\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"uint256","name":"txPayloadSize","type":"uint256"},{"internalType":"bytes","name":"options","type":"bytes"}],"name":"getExecutionFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"uint256","name":"txPayloadSize","type":"uint256"},{"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"internalType":"uint256","name":"executionFee","type":"uint256"},{"internalType":"bytes","name":"options","type":"bytes"}],"name":"requestExecution","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"getExecutionFee(uint256,uint256,bytes)":{"notice":"Get the execution fee for executing an Interchain Transaction on a remote chain."},"requestExecution(uint256,uint256,bytes32,uint256,bytes)":{"notice":"Request the execution of an Interchain Transaction on a remote chain. Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient event with the same transactionId, then execute the transaction on the remote chain: `dstInterchainClient.executeTransaction(transactionPayload)` Once the execution is confirmed on the source chain, the off-chain actor will be able to claim `executionFee` in the ExecutionFees contract."}},"version":1},"developerDoc":{"kind":"dev","methods":{"getExecutionFee(uint256,uint256,bytes)":{"params":{"dstChainId":"The chain id of the destination chain.","options":"The options to use for the execution.","txPayloadSize":"The size of the transaction payload to use for the execution."}},"requestExecution(uint256,uint256,bytes32,uint256,bytes)":{"details":"Could only be called by `InterchainClient` contracts. Will revert if the execution fee is not big enough.","params":{"dstChainId":"The chain id of the destination chain.","executionFee":"The fee paid for the execution.","options":"The options to use for the execution.","transactionId":"The id of the transaction to execute.","txPayloadSize":"The size of the transaction payload to use for the execution."}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"txPayloadSize\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"}],\"name\":\"getExecutionFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"txPayloadSize\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"executionFee\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"}],\"name\":\"requestExecution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getExecutionFee(uint256,uint256,bytes)\":{\"params\":{\"dstChainId\":\"The chain id of the destination chain.\",\"options\":\"The options to use for the execution.\",\"txPayloadSize\":\"The size of the transaction payload to use for the execution.\"}},\"requestExecution(uint256,uint256,bytes32,uint256,bytes)\":{\"details\":\"Could only be called by `InterchainClient` contracts. Will revert if the execution fee is not big enough.\",\"params\":{\"dstChainId\":\"The chain id of the destination chain.\",\"executionFee\":\"The fee paid for the execution.\",\"options\":\"The options to use for the execution.\",\"transactionId\":\"The id of the transaction to execute.\",\"txPayloadSize\":\"The size of the transaction payload to use for the execution.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getExecutionFee(uint256,uint256,bytes)\":{\"notice\":\"Get the execution fee for executing an Interchain Transaction on a remote chain.\"},\"requestExecution(uint256,uint256,bytes32,uint256,bytes)\":{\"notice\":\"Request the execution of an Interchain Transaction on a remote chain. Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient event with the same transactionId, then execute the transaction on the remote chain: `dstInterchainClient.executeTransaction(transactionPayload)` Once the execution is confirmed on the source chain, the off-chain actor will be able to claim `executionFee` in the ExecutionFees contract.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"IExecutionService\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0xb1820886ef923c4c065c5baff37b5df87b8df1e6d6b4c15efa8656e6bf9bab55\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://d5135fd5a15dd9be50d78f48a77d63d2477f99180a88a45d658259fa89e992a9\",\"dweb:/ipfs/QmeHcqSVFPtKYu1XVd751xBixEPBV2b3rN2jMUYAMKTKqN\"]}},\"version\":1}"},"hashes":{"getExecutionFee(uint256,uint256,bytes)":"c473e7e8","requestExecution(uint256,uint256,bytes32,uint256,bytes)":"e4e06522"}},"solidity/InterchainClientV1.sol:IInterchainApp":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainClientV1Events.sol\n\nabstract contract InterchainClientV1Events {\n    // TODO: figure out indexing\n\n    event InterchainTransactionSent(\n        bytes32 indexed transactionId,\n        uint256 indexed dbNonce,\n        uint256 dstChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver,\n        uint256 verificationFee,\n        uint256 executionFee,\n        bytes options,\n        bytes message\n    );\n\n    event InterchainTransactionReceived(\n        bytes32 indexed transactionId,\n        uint256 indexed dbNonce,\n        uint256 srcChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver\n    );\n}\n\n// contracts/interfaces/IExecutionFees.sol\n\ninterface IExecutionFees {\n    /// @notice Add the execution fee for a transaction. The attached value will be added to the\n    /// rewards for the executor completing the transaction.\n    /// Note: this could be used to store the execution fee for a new transaction, or to add more\n    /// funds to the execution fee of an existing transaction. Therefore this function is payable,\n    /// and does not implement any caller restrictions.\n    /// @dev Will revert if the executor is already recorded for the transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to add the execution fee to.\n    function addExecutionFee(uint256 dstChainId, bytes32 transactionId) external payable;\n\n    /// @notice Record the executor (who completed the transaction) for a transaction,\n    /// and update the accumulated rewards for the executor.\n    /// @dev Could only be called by the Recorder.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to record the executor for.\n    /// @param executor             The address of the executor who completed the transaction.\n    function recordExecutor(uint256 dstChainId, bytes32 transactionId, address executor) external;\n\n    /// @notice Allows the executor to claim their unclaimed rewards.\n    /// @dev Will revert if the executor has no unclaimed rewards.\n    function claimExecutionFees() external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the accumulated rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function getAccumulatedRewards(address executor) external view returns (uint256 accumulated);\n\n    /// @notice Get the unclaimed rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function getUnclaimedRewards(address executor) external view returns (uint256 unclaimed);\n}\n\n// contracts/interfaces/IExecutionService.sol\n\ninterface IExecutionService {\n    /// @notice Request the execution of an Interchain Transaction on a remote chain.\n    /// Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient\n    /// event with the same transactionId, then execute the transaction on the remote chain:\n    /// `dstInterchainClient.executeTransaction(transactionPayload)`\n    /// Once the execution is confirmed on the source chain, the off-chain actor will be able\n    /// to claim `executionFee` in the ExecutionFees contract.\n    /// @dev Could only be called by `InterchainClient` contracts.\n    /// Will revert if the execution fee is not big enough.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param transactionId        The id of the transaction to execute.\n    /// @param executionFee         The fee paid for the execution.\n    /// @param options              The options to use for the execution.\n    function requestExecution(\n        uint256 dstChainId,\n        uint256 txPayloadSize,\n        bytes32 transactionId,\n        uint256 executionFee,\n        bytes memory options\n    )\n        external;\n\n    /// @notice Get the execution fee for executing an Interchain Transaction on a remote chain.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param options              The options to use for the execution.\n    function getExecutionFee(\n        uint256 dstChainId,\n        uint256 txPayloadSize,\n        bytes memory options\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\ninterface IInterchainApp {\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory sendingModules,\n        address[] memory receivingModules,\n        uint256 requiredResponses,\n        uint64 optimisticTimePeriod\n    )\n        external;\n\n    function getLinkedIApp(uint64 chainID) external view returns (address);\n\n    function getSendingModules() external view returns (address[] memory);\n\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable;\n\n    function appReceive(uint256 srcChainId, bytes32 sender, uint64 nonce, bytes calldata message) external payable;\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 expected);\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sets the address of the InterchainDB contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param _interchainDB The address of the InterchainDB contract.\n     */\n    function setInterchainDB(address _interchainDB) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently primarily gas limit + native gas drop.\n     * @param message The message being sent.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     */\n    function interchainExecute(uint256 gasLimit, bytes calldata transaction) external payable;\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction The InterchainTransaction struct to be checked.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction) external view returns (bool);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    uint8 constant OPTIONS_V1 = 1;\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the entry on the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint64 nonce;\n    uint256 dbNonce;\n    bytes options;\n    bytes message;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint64 nonce,\n        uint256 dbNonce,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            nonce: nonce,\n            dbNonce: dbNonce,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the local Interchain DataBase.\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    struct LocalEntry {\n        address writer;\n        bytes32 dataHash;\n    }\n\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param entryValue   The value of the entry: writer + dataHash hashed together\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 entryValue;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingEntryValue, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(uint256 dbNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the written entry on this chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(uint256 destChainId, uint256 dbNonce, address[] memory srcModules) external payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`\n    /// by providing the returned `dbNonce`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param dbNonce      The database nonce of the written entry on this chain\n    function getEntry(uint256 dbNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the database.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, InterchainClientV1Events, IInterchainClientV1 {\n    using AppConfigLib for bytes;\n    using OptionsLib for bytes;\n\n    uint64 public clientNonce;\n    address public interchainDB;\n    address public executionFees;\n    mapping(bytes32 =\u003e bool) public executedTransactions;\n\n    // Chain ID =\u003e Bytes32 Address of src clients\n    mapping(uint256 =\u003e bytes32) public linkedClients;\n\n    constructor() Ownable(msg.sender) {}\n\n    // @inheritdoc IInterchainClientV1\n    function setExecutionFees(address executionFees_) public onlyOwner {\n        executionFees = executionFees_;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setInterchainDB(address _interchainDB) public onlyOwner {\n        interchainDB = _interchainDB;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint256 chainId, bytes32 client) public onlyOwner {\n        linkedClients[chainId] = client;\n    }\n\n    // TODO: Calculate Gas Pricing per module and charge fees\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        public\n        payable\n    {\n        // TODO: should check options for being correctly formatted\n        uint256 verificationFee = IInterchainDB(interchainDB).getInterchainFee(dstChainId, srcModules);\n        // TODO: should check msg.value \u003e= verificationFee\n        uint256 executionFee = msg.value - verificationFee;\n\n        InterchainTransaction memory icTx = InterchainTransactionLib.constructLocalTransaction({\n            srcSender: msg.sender,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            nonce: clientNonce,\n            dbNonce: IInterchainDB(interchainDB).getDBNonce(),\n            options: options,\n            message: message\n        });\n\n        bytes32 transactionId = icTx.transactionId();\n        // Sanity check: nonce returned from DB should match the nonce used to construct the transaction\n        assert(\n            icTx.dbNonce\n                == IInterchainDB(interchainDB).writeEntryWithVerification{value: verificationFee}(\n                    icTx.dstChainId, transactionId, srcModules\n                )\n        );\n        if (srcExecutionService != address(0)) {\n            IExecutionService(srcExecutionService).requestExecution({\n                dstChainId: dstChainId,\n                // TODO: there should be a way to calculate the payload size without encoding the transaction\n                txPayloadSize: abi.encode(icTx).length,\n                transactionId: transactionId,\n                executionFee: executionFee,\n                options: options\n            });\n        }\n        IExecutionFees(executionFees).addExecutionFee{value: executionFee}(icTx.dstChainId, transactionId);\n        emit InterchainTransactionSent(\n            transactionId,\n            icTx.dbNonce,\n            icTx.dstChainId,\n            icTx.srcSender,\n            icTx.dstReceiver,\n            verificationFee,\n            executionFee,\n            options,\n            message\n        );\n        // Increment nonce for next message\n        clientNonce++;\n    }\n\n    // TODO: App Config Versioning\n    // TODO: What if receiver is not a contract / doesn't conform to interface?\n    /**\n     * @dev Retrieves the application configuration for a given receiver application.\n     * @param receiverApp The address of the receiver application.\n     * @return requiredResponses The number of required responses from the receiving modules.\n     * @return optimisticTimePeriod The time period within which responses are considered valid.\n     * @return approvedDstModules An array of addresses of the approved destination modules.\n     */\n    function _getAppConfig(address receiverApp)\n        internal\n        view\n        returns (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules)\n    {\n        bytes memory appConfig;\n        (appConfig, approvedDstModules) = IInterchainApp(receiverApp).getReceivingConfig();\n        AppConfigV1 memory decodedAppConfig = appConfig.decodeAppConfigV1();\n        requiredResponses = decodedAppConfig.requiredResponses;\n        optimisticTimePeriod = decodedAppConfig.optimisticPeriod;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata encodedTx) public view returns (bool) {\n        InterchainTransaction memory icTx = InterchainTransactionLib.decodeTransaction(encodedTx);\n        bytes32 transactionId = icTx.transactionId();\n        return _isExecutable(transactionId, icTx);\n    }\n\n    function _isExecutable(bytes32 transactionId, InterchainTransaction memory icTx) internal view returns (bool) {\n        require(executedTransactions[transactionId] == false, \"Transaction already executed\");\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            dbNonce: icTx.dbNonce,\n            srcWriter: linkedClients[icTx.srcChainId],\n            dataHash: transactionId\n        });\n\n        (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules) =\n            _getAppConfig(TypeCasts.bytes32ToAddress(icTx.dstReceiver));\n\n        uint256[] memory approvedResponses = _getApprovedResponses(approvedDstModules, icEntry);\n\n        uint256 finalizedResponses = _getFinalizedResponsesCount(approvedResponses, optimisticTimePeriod);\n        require(finalizedResponses \u003e= requiredResponses, \"Not enough valid responses to meet the threshold\");\n        return true;\n    }\n\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedResponses An array of timestamps when each approved response was recorded.\n     * @param optimisticTimePeriod The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses The count of responses that are finalized within the optimistic time period.\n     */\n    function _getFinalizedResponsesCount(\n        uint256[] memory approvedResponses,\n        uint256 optimisticTimePeriod\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 finalizedResponses = 0;\n        for (uint256 i = 0; i \u003c approvedResponses.length; i++) {\n            if (approvedResponses[i] + optimisticTimePeriod \u003c= block.timestamp) {\n                finalizedResponses++;\n            }\n        }\n        return finalizedResponses;\n    }\n    /**\n     * @dev Retrieves the responses from approved modules for a given InterchainEntry.\n     * This function iterates over all approved modules, querying the InterchainDB for each module's response\n     * to the provided InterchainEntry. It compiles these responses into an array of uint256, where each\n     * element represents the timestamp of a module's response.\n     *\n     * @param approvedModules An array of addresses representing the approved modules that can write responses.\n     * @param icEntry The InterchainEntry for which responses are being retrieved.\n     * @return approvedResponses An array of uint256 representing the timestamps of responses from approved modules.\n     */\n\n    function _getApprovedResponses(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry\n    )\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory approvedResponses = new uint256[](approvedModules.length);\n        for (uint256 i = 0; i \u003c approvedModules.length; i++) {\n            approvedResponses[i] = IInterchainDB(interchainDB).readEntry(approvedModules[i], icEntry);\n        }\n        return approvedResponses;\n    }\n\n    function encodeTransaction(InterchainTransaction memory icTx) public view returns (bytes memory) {\n        return abi.encode(icTx);\n    }\n\n    function encodeOptionsV1(OptionsV1 memory options) public view returns (bytes memory) {\n        return options.encodeOptionsV1();\n    }\n\n    // TODO: Gas Fee Consideration that is paid to executor\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(uint256 gasLimit, bytes calldata transaction) external payable {\n        InterchainTransaction memory icTx = InterchainTransactionLib.decodeTransaction(transaction);\n        bytes32 transactionId = icTx.transactionId();\n        require(_isExecutable(transactionId, icTx), \"Transaction is not executable\");\n        executedTransactions[transactionId] = true;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n        if (msg.value != decodedOptions.gasAirdrop) {\n            revert InterchainClientV1__IncorrectMsgValue(msg.value, decodedOptions.gasAirdrop);\n        }\n        // We should always use at least as much as the requested gas limit.\n        // The executor can specify a higher gas limit if they wanted.\n        if (decodedOptions.gasLimit \u003e gasLimit) gasLimit = decodedOptions.gasLimit;\n        // Pass the full msg.value to the app: we have already checked that it matches the requested gas airdrop.\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: gasLimit, value: msg.value}({\n            srcChainId: icTx.srcChainId,\n            sender: icTx.srcSender,\n            nonce: icTx.nonce,\n            message: icTx.message\n        });\n        emit InterchainTransactionReceived(\n            transactionId, icTx.dbNonce, icTx.srcChainId, icTx.srcSender, icTx.dstReceiver\n        );\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"sender","type":"bytes32"},{"internalType":"uint64","name":"nonce","type":"uint64"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"appReceive","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint64","name":"chainID","type":"uint64"}],"name":"getLinkedIApp","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getReceivingConfig","outputs":[{"internalType":"bytes","name":"appConfig","type":"bytes"},{"internalType":"address[]","name":"modules","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getSendingModules","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"receiver","type":"bytes32"},{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"send","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint64[]","name":"chainIDs","type":"uint64[]"},{"internalType":"address[]","name":"linkedIApps","type":"address[]"},{"internalType":"address[]","name":"sendingModules","type":"address[]"},{"internalType":"address[]","name":"receivingModules","type":"address[]"},{"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"internalType":"uint64","name":"optimisticTimePeriod","type":"uint64"}],"name":"setAppConfig","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"appReceive\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainID\",\"type\":\"uint64\"}],\"name\":\"getLinkedIApp\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReceivingConfig\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"appConfig\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"modules\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSendingModules\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"receiver\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"send\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64[]\",\"name\":\"chainIDs\",\"type\":\"uint64[]\"},{\"internalType\":\"address[]\",\"name\":\"linkedIApps\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"sendingModules\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"receivingModules\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"optimisticTimePeriod\",\"type\":\"uint64\"}],\"name\":\"setAppConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"IInterchainApp\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0xb1820886ef923c4c065c5baff37b5df87b8df1e6d6b4c15efa8656e6bf9bab55\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://d5135fd5a15dd9be50d78f48a77d63d2477f99180a88a45d658259fa89e992a9\",\"dweb:/ipfs/QmeHcqSVFPtKYu1XVd751xBixEPBV2b3rN2jMUYAMKTKqN\"]}},\"version\":1}"},"hashes":{"appReceive(uint256,bytes32,uint64,bytes)":"d1eb8bde","getLinkedIApp(uint64)":"bfc849ee","getReceivingConfig()":"287bc057","getSendingModules()":"ea13398f","send(bytes32,uint256,bytes)":"e1ef3b3f","setAppConfig(uint64[],address[],address[],address[],uint256,uint64)":"dd34f56a"}},"solidity/InterchainClientV1.sol:IInterchainClientV1":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainClientV1Events.sol\n\nabstract contract InterchainClientV1Events {\n    // TODO: figure out indexing\n\n    event InterchainTransactionSent(\n        bytes32 indexed transactionId,\n        uint256 indexed dbNonce,\n        uint256 dstChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver,\n        uint256 verificationFee,\n        uint256 executionFee,\n        bytes options,\n        bytes message\n    );\n\n    event InterchainTransactionReceived(\n        bytes32 indexed transactionId,\n        uint256 indexed dbNonce,\n        uint256 srcChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver\n    );\n}\n\n// contracts/interfaces/IExecutionFees.sol\n\ninterface IExecutionFees {\n    /// @notice Add the execution fee for a transaction. The attached value will be added to the\n    /// rewards for the executor completing the transaction.\n    /// Note: this could be used to store the execution fee for a new transaction, or to add more\n    /// funds to the execution fee of an existing transaction. Therefore this function is payable,\n    /// and does not implement any caller restrictions.\n    /// @dev Will revert if the executor is already recorded for the transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to add the execution fee to.\n    function addExecutionFee(uint256 dstChainId, bytes32 transactionId) external payable;\n\n    /// @notice Record the executor (who completed the transaction) for a transaction,\n    /// and update the accumulated rewards for the executor.\n    /// @dev Could only be called by the Recorder.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to record the executor for.\n    /// @param executor             The address of the executor who completed the transaction.\n    function recordExecutor(uint256 dstChainId, bytes32 transactionId, address executor) external;\n\n    /// @notice Allows the executor to claim their unclaimed rewards.\n    /// @dev Will revert if the executor has no unclaimed rewards.\n    function claimExecutionFees() external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the accumulated rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function getAccumulatedRewards(address executor) external view returns (uint256 accumulated);\n\n    /// @notice Get the unclaimed rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function getUnclaimedRewards(address executor) external view returns (uint256 unclaimed);\n}\n\n// contracts/interfaces/IExecutionService.sol\n\ninterface IExecutionService {\n    /// @notice Request the execution of an Interchain Transaction on a remote chain.\n    /// Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient\n    /// event with the same transactionId, then execute the transaction on the remote chain:\n    /// `dstInterchainClient.executeTransaction(transactionPayload)`\n    /// Once the execution is confirmed on the source chain, the off-chain actor will be able\n    /// to claim `executionFee` in the ExecutionFees contract.\n    /// @dev Could only be called by `InterchainClient` contracts.\n    /// Will revert if the execution fee is not big enough.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param transactionId        The id of the transaction to execute.\n    /// @param executionFee         The fee paid for the execution.\n    /// @param options              The options to use for the execution.\n    function requestExecution(\n        uint256 dstChainId,\n        uint256 txPayloadSize,\n        bytes32 transactionId,\n        uint256 executionFee,\n        bytes memory options\n    )\n        external;\n\n    /// @notice Get the execution fee for executing an Interchain Transaction on a remote chain.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param options              The options to use for the execution.\n    function getExecutionFee(\n        uint256 dstChainId,\n        uint256 txPayloadSize,\n        bytes memory options\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\ninterface IInterchainApp {\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory sendingModules,\n        address[] memory receivingModules,\n        uint256 requiredResponses,\n        uint64 optimisticTimePeriod\n    )\n        external;\n\n    function getLinkedIApp(uint64 chainID) external view returns (address);\n\n    function getSendingModules() external view returns (address[] memory);\n\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable;\n\n    function appReceive(uint256 srcChainId, bytes32 sender, uint64 nonce, bytes calldata message) external payable;\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 expected);\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sets the address of the InterchainDB contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param _interchainDB The address of the InterchainDB contract.\n     */\n    function setInterchainDB(address _interchainDB) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently primarily gas limit + native gas drop.\n     * @param message The message being sent.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     */\n    function interchainExecute(uint256 gasLimit, bytes calldata transaction) external payable;\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction The InterchainTransaction struct to be checked.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction) external view returns (bool);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    uint8 constant OPTIONS_V1 = 1;\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the entry on the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint64 nonce;\n    uint256 dbNonce;\n    bytes options;\n    bytes message;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint64 nonce,\n        uint256 dbNonce,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            nonce: nonce,\n            dbNonce: dbNonce,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the local Interchain DataBase.\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    struct LocalEntry {\n        address writer;\n        bytes32 dataHash;\n    }\n\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param entryValue   The value of the entry: writer + dataHash hashed together\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 entryValue;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingEntryValue, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(uint256 dbNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the written entry on this chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(uint256 destChainId, uint256 dbNonce, address[] memory srcModules) external payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`\n    /// by providing the returned `dbNonce`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param dbNonce      The database nonce of the written entry on this chain\n    function getEntry(uint256 dbNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the database.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, InterchainClientV1Events, IInterchainClientV1 {\n    using AppConfigLib for bytes;\n    using OptionsLib for bytes;\n\n    uint64 public clientNonce;\n    address public interchainDB;\n    address public executionFees;\n    mapping(bytes32 =\u003e bool) public executedTransactions;\n\n    // Chain ID =\u003e Bytes32 Address of src clients\n    mapping(uint256 =\u003e bytes32) public linkedClients;\n\n    constructor() Ownable(msg.sender) {}\n\n    // @inheritdoc IInterchainClientV1\n    function setExecutionFees(address executionFees_) public onlyOwner {\n        executionFees = executionFees_;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setInterchainDB(address _interchainDB) public onlyOwner {\n        interchainDB = _interchainDB;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint256 chainId, bytes32 client) public onlyOwner {\n        linkedClients[chainId] = client;\n    }\n\n    // TODO: Calculate Gas Pricing per module and charge fees\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        public\n        payable\n    {\n        // TODO: should check options for being correctly formatted\n        uint256 verificationFee = IInterchainDB(interchainDB).getInterchainFee(dstChainId, srcModules);\n        // TODO: should check msg.value \u003e= verificationFee\n        uint256 executionFee = msg.value - verificationFee;\n\n        InterchainTransaction memory icTx = InterchainTransactionLib.constructLocalTransaction({\n            srcSender: msg.sender,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            nonce: clientNonce,\n            dbNonce: IInterchainDB(interchainDB).getDBNonce(),\n            options: options,\n            message: message\n        });\n\n        bytes32 transactionId = icTx.transactionId();\n        // Sanity check: nonce returned from DB should match the nonce used to construct the transaction\n        assert(\n            icTx.dbNonce\n                == IInterchainDB(interchainDB).writeEntryWithVerification{value: verificationFee}(\n                    icTx.dstChainId, transactionId, srcModules\n                )\n        );\n        if (srcExecutionService != address(0)) {\n            IExecutionService(srcExecutionService).requestExecution({\n                dstChainId: dstChainId,\n                // TODO: there should be a way to calculate the payload size without encoding the transaction\n                txPayloadSize: abi.encode(icTx).length,\n                transactionId: transactionId,\n                executionFee: executionFee,\n                options: options\n            });\n        }\n        IExecutionFees(executionFees).addExecutionFee{value: executionFee}(icTx.dstChainId, transactionId);\n        emit InterchainTransactionSent(\n            transactionId,\n            icTx.dbNonce,\n            icTx.dstChainId,\n            icTx.srcSender,\n            icTx.dstReceiver,\n            verificationFee,\n            executionFee,\n            options,\n            message\n        );\n        // Increment nonce for next message\n        clientNonce++;\n    }\n\n    // TODO: App Config Versioning\n    // TODO: What if receiver is not a contract / doesn't conform to interface?\n    /**\n     * @dev Retrieves the application configuration for a given receiver application.\n     * @param receiverApp The address of the receiver application.\n     * @return requiredResponses The number of required responses from the receiving modules.\n     * @return optimisticTimePeriod The time period within which responses are considered valid.\n     * @return approvedDstModules An array of addresses of the approved destination modules.\n     */\n    function _getAppConfig(address receiverApp)\n        internal\n        view\n        returns (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules)\n    {\n        bytes memory appConfig;\n        (appConfig, approvedDstModules) = IInterchainApp(receiverApp).getReceivingConfig();\n        AppConfigV1 memory decodedAppConfig = appConfig.decodeAppConfigV1();\n        requiredResponses = decodedAppConfig.requiredResponses;\n        optimisticTimePeriod = decodedAppConfig.optimisticPeriod;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata encodedTx) public view returns (bool) {\n        InterchainTransaction memory icTx = InterchainTransactionLib.decodeTransaction(encodedTx);\n        bytes32 transactionId = icTx.transactionId();\n        return _isExecutable(transactionId, icTx);\n    }\n\n    function _isExecutable(bytes32 transactionId, InterchainTransaction memory icTx) internal view returns (bool) {\n        require(executedTransactions[transactionId] == false, \"Transaction already executed\");\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            dbNonce: icTx.dbNonce,\n            srcWriter: linkedClients[icTx.srcChainId],\n            dataHash: transactionId\n        });\n\n        (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules) =\n            _getAppConfig(TypeCasts.bytes32ToAddress(icTx.dstReceiver));\n\n        uint256[] memory approvedResponses = _getApprovedResponses(approvedDstModules, icEntry);\n\n        uint256 finalizedResponses = _getFinalizedResponsesCount(approvedResponses, optimisticTimePeriod);\n        require(finalizedResponses \u003e= requiredResponses, \"Not enough valid responses to meet the threshold\");\n        return true;\n    }\n\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedResponses An array of timestamps when each approved response was recorded.\n     * @param optimisticTimePeriod The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses The count of responses that are finalized within the optimistic time period.\n     */\n    function _getFinalizedResponsesCount(\n        uint256[] memory approvedResponses,\n        uint256 optimisticTimePeriod\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 finalizedResponses = 0;\n        for (uint256 i = 0; i \u003c approvedResponses.length; i++) {\n            if (approvedResponses[i] + optimisticTimePeriod \u003c= block.timestamp) {\n                finalizedResponses++;\n            }\n        }\n        return finalizedResponses;\n    }\n    /**\n     * @dev Retrieves the responses from approved modules for a given InterchainEntry.\n     * This function iterates over all approved modules, querying the InterchainDB for each module's response\n     * to the provided InterchainEntry. It compiles these responses into an array of uint256, where each\n     * element represents the timestamp of a module's response.\n     *\n     * @param approvedModules An array of addresses representing the approved modules that can write responses.\n     * @param icEntry The InterchainEntry for which responses are being retrieved.\n     * @return approvedResponses An array of uint256 representing the timestamps of responses from approved modules.\n     */\n\n    function _getApprovedResponses(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry\n    )\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory approvedResponses = new uint256[](approvedModules.length);\n        for (uint256 i = 0; i \u003c approvedModules.length; i++) {\n            approvedResponses[i] = IInterchainDB(interchainDB).readEntry(approvedModules[i], icEntry);\n        }\n        return approvedResponses;\n    }\n\n    function encodeTransaction(InterchainTransaction memory icTx) public view returns (bytes memory) {\n        return abi.encode(icTx);\n    }\n\n    function encodeOptionsV1(OptionsV1 memory options) public view returns (bytes memory) {\n        return options.encodeOptionsV1();\n    }\n\n    // TODO: Gas Fee Consideration that is paid to executor\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(uint256 gasLimit, bytes calldata transaction) external payable {\n        InterchainTransaction memory icTx = InterchainTransactionLib.decodeTransaction(transaction);\n        bytes32 transactionId = icTx.transactionId();\n        require(_isExecutable(transactionId, icTx), \"Transaction is not executable\");\n        executedTransactions[transactionId] = true;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n        if (msg.value != decodedOptions.gasAirdrop) {\n            revert InterchainClientV1__IncorrectMsgValue(msg.value, decodedOptions.gasAirdrop);\n        }\n        // We should always use at least as much as the requested gas limit.\n        // The executor can specify a higher gas limit if they wanted.\n        if (decodedOptions.gasLimit \u003e gasLimit) gasLimit = decodedOptions.gasLimit;\n        // Pass the full msg.value to the app: we have already checked that it matches the requested gas airdrop.\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: gasLimit, value: msg.value}({\n            srcChainId: icTx.srcChainId,\n            sender: icTx.srcSender,\n            nonce: icTx.nonce,\n            message: icTx.message\n        });\n        emit InterchainTransactionReceived(\n            transactionId, icTx.dbNonce, icTx.srcChainId, icTx.srcSender, icTx.dstReceiver\n        );\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"expected","type":"uint256"}],"name":"InterchainClientV1__IncorrectMsgValue","type":"error"},{"inputs":[{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"bytes","name":"transaction","type":"bytes"}],"name":"interchainExecute","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"bytes32","name":"receiver","type":"bytes32"},{"internalType":"address","name":"srcExecutionService","type":"address"},{"internalType":"address[]","name":"srcModules","type":"address[]"},{"internalType":"bytes","name":"options","type":"bytes"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"interchainSend","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes","name":"transaction","type":"bytes"}],"name":"isExecutable","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"executionFees_","type":"address"}],"name":"setExecutionFees","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_interchainDB","type":"address"}],"name":"setInterchainDB","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"bytes32","name":"client","type":"bytes32"}],"name":"setLinkedClient","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"interchainExecute(uint256,bytes)":{"notice":"Executes a transaction that has been sent via the Interchain."},"interchainSend(uint256,bytes32,address,address[],bytes,bytes)":{"notice":"Sends a message to another chain via the Interchain Communication Protocol."},"isExecutable(bytes)":{"notice":"Checks if a transaction is executable."},"setExecutionFees(address)":{"notice":"Sets the address of the ExecutionFees contract."},"setInterchainDB(address)":{"notice":"Sets the address of the InterchainDB contract."},"setLinkedClient(uint256,bytes32)":{"notice":"Sets the linked client for a specific chain ID."}},"version":1},"developerDoc":{"kind":"dev","methods":{"interchainExecute(uint256,bytes)":{"details":"The transaction must have been previously sent and recorded. Transaction data includes the requested gas limit, but the executors could specify a different gas limit. If the specified gas limit is lower than requested, the requested gas limit will be used. Otherwise, the specified gas limit will be used. This allows to execute the transactions with requested gas limit set too low.","params":{"gasLimit":"The gas limit to use for the execution.","transaction":"The transaction data."}},"interchainSend(uint256,bytes32,address,address[],bytes,bytes)":{"details":"Charges a fee for the message, which is payable upon calling this function: - Verification fees: paid to every module that verifies the message. - Execution fee: paid to the executor that executes the message. Note: while a specific execution service is specified to request the execution of the message, any executor is able to execute the message on destination chain, earning the execution fee.","params":{"dstChainId":"The chain ID of the destination chain.","message":"The message being sent.","options":"Execution options for the message sent, encoded as bytes, currently primarily gas limit + native gas drop.","receiver":"The address of the receiver on the destination chain.","srcExecutionService":"The address of the execution service to use for the message.","srcModules":"The source modules involved in the message sending."}},"isExecutable(bytes)":{"details":"Determines if a transaction meets the criteria to be executed based on: - If approved modules have written to the InterchainDB - If the threshold of approved modules have been met - If the optimistic window has passed for all modules","params":{"transaction":"The InterchainTransaction struct to be checked."},"returns":{"_0":"bool Returns true if the transaction is executable, false otherwise."}},"setExecutionFees(address)":{"details":"Only callable by the contract owner or an authorized account.","params":{"executionFees_":"The address of the ExecutionFees contract."}},"setInterchainDB(address)":{"details":"Only callable by the contract owner or an authorized account.","params":{"_interchainDB":"The address of the InterchainDB contract."}},"setLinkedClient(uint256,bytes32)":{"details":"Stores the address of the linked client in a mapping with the chain ID as the key.","params":{"chainId":"The chain ID for which the client is being set.","client":"The address of the client being linked."}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"}],\"name\":\"InterchainClientV1__IncorrectMsgValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"transaction\",\"type\":\"bytes\"}],\"name\":\"interchainExecute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"receiver\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"srcExecutionService\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"interchainSend\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"transaction\",\"type\":\"bytes\"}],\"name\":\"isExecutable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"executionFees_\",\"type\":\"address\"}],\"name\":\"setExecutionFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_interchainDB\",\"type\":\"address\"}],\"name\":\"setInterchainDB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"client\",\"type\":\"bytes32\"}],\"name\":\"setLinkedClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"interchainExecute(uint256,bytes)\":{\"details\":\"The transaction must have been previously sent and recorded. Transaction data includes the requested gas limit, but the executors could specify a different gas limit. If the specified gas limit is lower than requested, the requested gas limit will be used. Otherwise, the specified gas limit will be used. This allows to execute the transactions with requested gas limit set too low.\",\"params\":{\"gasLimit\":\"The gas limit to use for the execution.\",\"transaction\":\"The transaction data.\"}},\"interchainSend(uint256,bytes32,address,address[],bytes,bytes)\":{\"details\":\"Charges a fee for the message, which is payable upon calling this function: - Verification fees: paid to every module that verifies the message. - Execution fee: paid to the executor that executes the message. Note: while a specific execution service is specified to request the execution of the message, any executor is able to execute the message on destination chain, earning the execution fee.\",\"params\":{\"dstChainId\":\"The chain ID of the destination chain.\",\"message\":\"The message being sent.\",\"options\":\"Execution options for the message sent, encoded as bytes, currently primarily gas limit + native gas drop.\",\"receiver\":\"The address of the receiver on the destination chain.\",\"srcExecutionService\":\"The address of the execution service to use for the message.\",\"srcModules\":\"The source modules involved in the message sending.\"}},\"isExecutable(bytes)\":{\"details\":\"Determines if a transaction meets the criteria to be executed based on: - If approved modules have written to the InterchainDB - If the threshold of approved modules have been met - If the optimistic window has passed for all modules\",\"params\":{\"transaction\":\"The InterchainTransaction struct to be checked.\"},\"returns\":{\"_0\":\"bool Returns true if the transaction is executable, false otherwise.\"}},\"setExecutionFees(address)\":{\"details\":\"Only callable by the contract owner or an authorized account.\",\"params\":{\"executionFees_\":\"The address of the ExecutionFees contract.\"}},\"setInterchainDB(address)\":{\"details\":\"Only callable by the contract owner or an authorized account.\",\"params\":{\"_interchainDB\":\"The address of the InterchainDB contract.\"}},\"setLinkedClient(uint256,bytes32)\":{\"details\":\"Stores the address of the linked client in a mapping with the chain ID as the key.\",\"params\":{\"chainId\":\"The chain ID for which the client is being set.\",\"client\":\"The address of the client being linked.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"interchainExecute(uint256,bytes)\":{\"notice\":\"Executes a transaction that has been sent via the Interchain.\"},\"interchainSend(uint256,bytes32,address,address[],bytes,bytes)\":{\"notice\":\"Sends a message to another chain via the Interchain Communication Protocol.\"},\"isExecutable(bytes)\":{\"notice\":\"Checks if a transaction is executable.\"},\"setExecutionFees(address)\":{\"notice\":\"Sets the address of the ExecutionFees contract.\"},\"setInterchainDB(address)\":{\"notice\":\"Sets the address of the InterchainDB contract.\"},\"setLinkedClient(uint256,bytes32)\":{\"notice\":\"Sets the linked client for a specific chain ID.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"IInterchainClientV1\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0xb1820886ef923c4c065c5baff37b5df87b8df1e6d6b4c15efa8656e6bf9bab55\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://d5135fd5a15dd9be50d78f48a77d63d2477f99180a88a45d658259fa89e992a9\",\"dweb:/ipfs/QmeHcqSVFPtKYu1XVd751xBixEPBV2b3rN2jMUYAMKTKqN\"]}},\"version\":1}"},"hashes":{"interchainExecute(uint256,bytes)":"80efe777","interchainSend(uint256,bytes32,address,address[],bytes,bytes)":"98939d28","isExecutable(bytes)":"31afa7de","setExecutionFees(address)":"3dc68b87","setInterchainDB(address)":"b7ce2078","setLinkedClient(uint256,bytes32)":"f34234c8"}},"solidity/InterchainClientV1.sol:IInterchainDB":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainClientV1Events.sol\n\nabstract contract InterchainClientV1Events {\n    // TODO: figure out indexing\n\n    event InterchainTransactionSent(\n        bytes32 indexed transactionId,\n        uint256 indexed dbNonce,\n        uint256 dstChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver,\n        uint256 verificationFee,\n        uint256 executionFee,\n        bytes options,\n        bytes message\n    );\n\n    event InterchainTransactionReceived(\n        bytes32 indexed transactionId,\n        uint256 indexed dbNonce,\n        uint256 srcChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver\n    );\n}\n\n// contracts/interfaces/IExecutionFees.sol\n\ninterface IExecutionFees {\n    /// @notice Add the execution fee for a transaction. The attached value will be added to the\n    /// rewards for the executor completing the transaction.\n    /// Note: this could be used to store the execution fee for a new transaction, or to add more\n    /// funds to the execution fee of an existing transaction. Therefore this function is payable,\n    /// and does not implement any caller restrictions.\n    /// @dev Will revert if the executor is already recorded for the transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to add the execution fee to.\n    function addExecutionFee(uint256 dstChainId, bytes32 transactionId) external payable;\n\n    /// @notice Record the executor (who completed the transaction) for a transaction,\n    /// and update the accumulated rewards for the executor.\n    /// @dev Could only be called by the Recorder.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to record the executor for.\n    /// @param executor             The address of the executor who completed the transaction.\n    function recordExecutor(uint256 dstChainId, bytes32 transactionId, address executor) external;\n\n    /// @notice Allows the executor to claim their unclaimed rewards.\n    /// @dev Will revert if the executor has no unclaimed rewards.\n    function claimExecutionFees() external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the accumulated rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function getAccumulatedRewards(address executor) external view returns (uint256 accumulated);\n\n    /// @notice Get the unclaimed rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function getUnclaimedRewards(address executor) external view returns (uint256 unclaimed);\n}\n\n// contracts/interfaces/IExecutionService.sol\n\ninterface IExecutionService {\n    /// @notice Request the execution of an Interchain Transaction on a remote chain.\n    /// Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient\n    /// event with the same transactionId, then execute the transaction on the remote chain:\n    /// `dstInterchainClient.executeTransaction(transactionPayload)`\n    /// Once the execution is confirmed on the source chain, the off-chain actor will be able\n    /// to claim `executionFee` in the ExecutionFees contract.\n    /// @dev Could only be called by `InterchainClient` contracts.\n    /// Will revert if the execution fee is not big enough.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param transactionId        The id of the transaction to execute.\n    /// @param executionFee         The fee paid for the execution.\n    /// @param options              The options to use for the execution.\n    function requestExecution(\n        uint256 dstChainId,\n        uint256 txPayloadSize,\n        bytes32 transactionId,\n        uint256 executionFee,\n        bytes memory options\n    )\n        external;\n\n    /// @notice Get the execution fee for executing an Interchain Transaction on a remote chain.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param options              The options to use for the execution.\n    function getExecutionFee(\n        uint256 dstChainId,\n        uint256 txPayloadSize,\n        bytes memory options\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\ninterface IInterchainApp {\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory sendingModules,\n        address[] memory receivingModules,\n        uint256 requiredResponses,\n        uint64 optimisticTimePeriod\n    )\n        external;\n\n    function getLinkedIApp(uint64 chainID) external view returns (address);\n\n    function getSendingModules() external view returns (address[] memory);\n\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable;\n\n    function appReceive(uint256 srcChainId, bytes32 sender, uint64 nonce, bytes calldata message) external payable;\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 expected);\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sets the address of the InterchainDB contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param _interchainDB The address of the InterchainDB contract.\n     */\n    function setInterchainDB(address _interchainDB) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently primarily gas limit + native gas drop.\n     * @param message The message being sent.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     */\n    function interchainExecute(uint256 gasLimit, bytes calldata transaction) external payable;\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction The InterchainTransaction struct to be checked.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction) external view returns (bool);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    uint8 constant OPTIONS_V1 = 1;\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the entry on the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint64 nonce;\n    uint256 dbNonce;\n    bytes options;\n    bytes message;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint64 nonce,\n        uint256 dbNonce,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            nonce: nonce,\n            dbNonce: dbNonce,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the local Interchain DataBase.\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    struct LocalEntry {\n        address writer;\n        bytes32 dataHash;\n    }\n\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param entryValue   The value of the entry: writer + dataHash hashed together\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 entryValue;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingEntryValue, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(uint256 dbNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the written entry on this chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(uint256 destChainId, uint256 dbNonce, address[] memory srcModules) external payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`\n    /// by providing the returned `dbNonce`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param dbNonce      The database nonce of the written entry on this chain\n    function getEntry(uint256 dbNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the database.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, InterchainClientV1Events, IInterchainClientV1 {\n    using AppConfigLib for bytes;\n    using OptionsLib for bytes;\n\n    uint64 public clientNonce;\n    address public interchainDB;\n    address public executionFees;\n    mapping(bytes32 =\u003e bool) public executedTransactions;\n\n    // Chain ID =\u003e Bytes32 Address of src clients\n    mapping(uint256 =\u003e bytes32) public linkedClients;\n\n    constructor() Ownable(msg.sender) {}\n\n    // @inheritdoc IInterchainClientV1\n    function setExecutionFees(address executionFees_) public onlyOwner {\n        executionFees = executionFees_;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setInterchainDB(address _interchainDB) public onlyOwner {\n        interchainDB = _interchainDB;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint256 chainId, bytes32 client) public onlyOwner {\n        linkedClients[chainId] = client;\n    }\n\n    // TODO: Calculate Gas Pricing per module and charge fees\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        public\n        payable\n    {\n        // TODO: should check options for being correctly formatted\n        uint256 verificationFee = IInterchainDB(interchainDB).getInterchainFee(dstChainId, srcModules);\n        // TODO: should check msg.value \u003e= verificationFee\n        uint256 executionFee = msg.value - verificationFee;\n\n        InterchainTransaction memory icTx = InterchainTransactionLib.constructLocalTransaction({\n            srcSender: msg.sender,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            nonce: clientNonce,\n            dbNonce: IInterchainDB(interchainDB).getDBNonce(),\n            options: options,\n            message: message\n        });\n\n        bytes32 transactionId = icTx.transactionId();\n        // Sanity check: nonce returned from DB should match the nonce used to construct the transaction\n        assert(\n            icTx.dbNonce\n                == IInterchainDB(interchainDB).writeEntryWithVerification{value: verificationFee}(\n                    icTx.dstChainId, transactionId, srcModules\n                )\n        );\n        if (srcExecutionService != address(0)) {\n            IExecutionService(srcExecutionService).requestExecution({\n                dstChainId: dstChainId,\n                // TODO: there should be a way to calculate the payload size without encoding the transaction\n                txPayloadSize: abi.encode(icTx).length,\n                transactionId: transactionId,\n                executionFee: executionFee,\n                options: options\n            });\n        }\n        IExecutionFees(executionFees).addExecutionFee{value: executionFee}(icTx.dstChainId, transactionId);\n        emit InterchainTransactionSent(\n            transactionId,\n            icTx.dbNonce,\n            icTx.dstChainId,\n            icTx.srcSender,\n            icTx.dstReceiver,\n            verificationFee,\n            executionFee,\n            options,\n            message\n        );\n        // Increment nonce for next message\n        clientNonce++;\n    }\n\n    // TODO: App Config Versioning\n    // TODO: What if receiver is not a contract / doesn't conform to interface?\n    /**\n     * @dev Retrieves the application configuration for a given receiver application.\n     * @param receiverApp The address of the receiver application.\n     * @return requiredResponses The number of required responses from the receiving modules.\n     * @return optimisticTimePeriod The time period within which responses are considered valid.\n     * @return approvedDstModules An array of addresses of the approved destination modules.\n     */\n    function _getAppConfig(address receiverApp)\n        internal\n        view\n        returns (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules)\n    {\n        bytes memory appConfig;\n        (appConfig, approvedDstModules) = IInterchainApp(receiverApp).getReceivingConfig();\n        AppConfigV1 memory decodedAppConfig = appConfig.decodeAppConfigV1();\n        requiredResponses = decodedAppConfig.requiredResponses;\n        optimisticTimePeriod = decodedAppConfig.optimisticPeriod;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata encodedTx) public view returns (bool) {\n        InterchainTransaction memory icTx = InterchainTransactionLib.decodeTransaction(encodedTx);\n        bytes32 transactionId = icTx.transactionId();\n        return _isExecutable(transactionId, icTx);\n    }\n\n    function _isExecutable(bytes32 transactionId, InterchainTransaction memory icTx) internal view returns (bool) {\n        require(executedTransactions[transactionId] == false, \"Transaction already executed\");\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            dbNonce: icTx.dbNonce,\n            srcWriter: linkedClients[icTx.srcChainId],\n            dataHash: transactionId\n        });\n\n        (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules) =\n            _getAppConfig(TypeCasts.bytes32ToAddress(icTx.dstReceiver));\n\n        uint256[] memory approvedResponses = _getApprovedResponses(approvedDstModules, icEntry);\n\n        uint256 finalizedResponses = _getFinalizedResponsesCount(approvedResponses, optimisticTimePeriod);\n        require(finalizedResponses \u003e= requiredResponses, \"Not enough valid responses to meet the threshold\");\n        return true;\n    }\n\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedResponses An array of timestamps when each approved response was recorded.\n     * @param optimisticTimePeriod The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses The count of responses that are finalized within the optimistic time period.\n     */\n    function _getFinalizedResponsesCount(\n        uint256[] memory approvedResponses,\n        uint256 optimisticTimePeriod\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 finalizedResponses = 0;\n        for (uint256 i = 0; i \u003c approvedResponses.length; i++) {\n            if (approvedResponses[i] + optimisticTimePeriod \u003c= block.timestamp) {\n                finalizedResponses++;\n            }\n        }\n        return finalizedResponses;\n    }\n    /**\n     * @dev Retrieves the responses from approved modules for a given InterchainEntry.\n     * This function iterates over all approved modules, querying the InterchainDB for each module's response\n     * to the provided InterchainEntry. It compiles these responses into an array of uint256, where each\n     * element represents the timestamp of a module's response.\n     *\n     * @param approvedModules An array of addresses representing the approved modules that can write responses.\n     * @param icEntry The InterchainEntry for which responses are being retrieved.\n     * @return approvedResponses An array of uint256 representing the timestamps of responses from approved modules.\n     */\n\n    function _getApprovedResponses(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry\n    )\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory approvedResponses = new uint256[](approvedModules.length);\n        for (uint256 i = 0; i \u003c approvedModules.length; i++) {\n            approvedResponses[i] = IInterchainDB(interchainDB).readEntry(approvedModules[i], icEntry);\n        }\n        return approvedResponses;\n    }\n\n    function encodeTransaction(InterchainTransaction memory icTx) public view returns (bytes memory) {\n        return abi.encode(icTx);\n    }\n\n    function encodeOptionsV1(OptionsV1 memory options) public view returns (bytes memory) {\n        return options.encodeOptionsV1();\n    }\n\n    // TODO: Gas Fee Consideration that is paid to executor\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(uint256 gasLimit, bytes calldata transaction) external payable {\n        InterchainTransaction memory icTx = InterchainTransactionLib.decodeTransaction(transaction);\n        bytes32 transactionId = icTx.transactionId();\n        require(_isExecutable(transactionId, icTx), \"Transaction is not executable\");\n        executedTransactions[transactionId] = true;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n        if (msg.value != decodedOptions.gasAirdrop) {\n            revert InterchainClientV1__IncorrectMsgValue(msg.value, decodedOptions.gasAirdrop);\n        }\n        // We should always use at least as much as the requested gas limit.\n        // The executor can specify a higher gas limit if they wanted.\n        if (decodedOptions.gasLimit \u003e gasLimit) gasLimit = decodedOptions.gasLimit;\n        // Pass the full msg.value to the app: we have already checked that it matches the requested gas airdrop.\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: gasLimit, value: msg.value}({\n            srcChainId: icTx.srcChainId,\n            sender: icTx.srcSender,\n            nonce: icTx.nonce,\n            message: icTx.message\n        });\n        emit InterchainTransactionReceived(\n            transactionId, icTx.dbNonce, icTx.srcChainId, icTx.srcSender, icTx.dstReceiver\n        );\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"bytes32","name":"existingEntryValue","type":"bytes32"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"newEntry","type":"tuple"}],"name":"InterchainDB__ConflictingEntries","type":"error"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"name":"InterchainDB__EntryDoesNotExist","type":"error"},{"inputs":[{"internalType":"uint256","name":"actualFee","type":"uint256"},{"internalType":"uint256","name":"expectedFee","type":"uint256"}],"name":"InterchainDB__IncorrectFeeAmount","type":"error"},{"inputs":[],"name":"InterchainDB__NoModulesSpecified","type":"error"},{"inputs":[],"name":"InterchainDB__SameChainId","type":"error"},{"inputs":[],"name":"getDBNonce","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"name":"getEntry","outputs":[{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"getInterchainFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"dstModule","type":"address"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"entry","type":"tuple"}],"name":"readEntry","outputs":[{"internalType":"uint256","name":"moduleVerifiedAt","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"requestVerification","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"entry","type":"tuple"}],"name":"verifyEntry","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"name":"writeEntry","outputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"writeEntryWithVerification","outputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"stateMutability":"payable","type":"function"}],"userDoc":{"kind":"user","methods":{"getDBNonce()":{"notice":"Get the nonce of the database."},"getEntry(uint256)":{"notice":"Get the Interchain Entry by the writer and the writer nonce."},"getInterchainFee(uint256,address[])":{"notice":"Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain using the provided Interchain Modules."},"readEntry(address,(uint256,uint256,bytes32,bytes32))":{"notice":"Read the data written on specific source chain by a specific writer, and verify it on the destination chain using the provided Interchain Module. Note: returned zero value indicates that the module has not verified the entry."},"requestVerification(uint256,uint256,address[])":{"notice":"Request the given Interchain Modules to verify the already written entry on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: this method is permissionless, and anyone can request verification for any entry."},"verifyEntry((uint256,uint256,bytes32,bytes32))":{"notice":"Allows the Interchain Module to verify the entry coming from a remote source chain."},"writeEntry(bytes32)":{"notice":"Write data to the Interchain DataBase as a new entry. Note: there are no guarantees that this entry will be available for reading on any of the remote chains. Use `verifyEntry` to ensure that the entry is available for reading on the destination chain."},"writeEntryWithVerification(uint256,bytes32,address[])":{"notice":"Write data to the Interchain DataBase, and request the given Interchain Modules to verify it on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: additional verification for the same entry could be later done using `requestVerification` by providing the returned `dbNonce`."}},"version":1},"developerDoc":{"kind":"dev","methods":{"getEntry(uint256)":{"details":"Will revert if the entry with the given nonce does not exist.","params":{"dbNonce":"The database nonce of the written entry on this chain"}},"getInterchainFee(uint256,address[])":{"details":"Will revert if the empty array of modules is provided.","params":{"destChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"}},"readEntry(address,(uint256,uint256,bytes32,bytes32))":{"params":{"dstModule":"The destination chain addresses of the Interchain Modules to use for verification","entry":"The Interchain Entry to read"},"returns":{"moduleVerifiedAt":"  The block timestamp at which the entry was verified by the module,                             or zero if the module has not verified the entry."}},"requestVerification(uint256,uint256,address[])":{"details":"Will revert if the entry with the given nonce does not exist.","params":{"dbNonce":"The database nonce of the written entry on this chain","destChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"}},"verifyEntry((uint256,uint256,bytes32,bytes32))":{"params":{"entry":"The Interchain Entry to confirm"}},"writeEntry(bytes32)":{"params":{"dataHash":"The hash of the data to be written to the Interchain DataBase as a new entry"},"returns":{"dbNonce":"    The database nonce of the written entry on this chain"}},"writeEntryWithVerification(uint256,bytes32,address[])":{"details":"Will revert if the empty array of modules is provided.","params":{"dataHash":"The hash of the data to be written to the Interchain DataBase as a new entry","destChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"},"returns":{"dbNonce":"    The database nonce of the written entry on this chain"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"existingEntryValue\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"newEntry\",\"type\":\"tuple\"}],\"name\":\"InterchainDB__ConflictingEntries\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__EntryDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actualFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedFee\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__IncorrectFeeAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainDB__NoModulesSpecified\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainDB__SameChainId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"getDBNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"name\":\"getEntry\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"getInterchainFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dstModule\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"entry\",\"type\":\"tuple\"}],\"name\":\"readEntry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"moduleVerifiedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"requestVerification\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"entry\",\"type\":\"tuple\"}],\"name\":\"verifyEntry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"writeEntry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"writeEntryWithVerification\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getEntry(uint256)\":{\"details\":\"Will revert if the entry with the given nonce does not exist.\",\"params\":{\"dbNonce\":\"The database nonce of the written entry on this chain\"}},\"getInterchainFee(uint256,address[])\":{\"details\":\"Will revert if the empty array of modules is provided.\",\"params\":{\"destChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"}},\"readEntry(address,(uint256,uint256,bytes32,bytes32))\":{\"params\":{\"dstModule\":\"The destination chain addresses of the Interchain Modules to use for verification\",\"entry\":\"The Interchain Entry to read\"},\"returns\":{\"moduleVerifiedAt\":\"  The block timestamp at which the entry was verified by the module,                             or zero if the module has not verified the entry.\"}},\"requestVerification(uint256,uint256,address[])\":{\"details\":\"Will revert if the entry with the given nonce does not exist.\",\"params\":{\"dbNonce\":\"The database nonce of the written entry on this chain\",\"destChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"}},\"verifyEntry((uint256,uint256,bytes32,bytes32))\":{\"params\":{\"entry\":\"The Interchain Entry to confirm\"}},\"writeEntry(bytes32)\":{\"params\":{\"dataHash\":\"The hash of the data to be written to the Interchain DataBase as a new entry\"},\"returns\":{\"dbNonce\":\"    The database nonce of the written entry on this chain\"}},\"writeEntryWithVerification(uint256,bytes32,address[])\":{\"details\":\"Will revert if the empty array of modules is provided.\",\"params\":{\"dataHash\":\"The hash of the data to be written to the Interchain DataBase as a new entry\",\"destChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"},\"returns\":{\"dbNonce\":\"    The database nonce of the written entry on this chain\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getDBNonce()\":{\"notice\":\"Get the nonce of the database.\"},\"getEntry(uint256)\":{\"notice\":\"Get the Interchain Entry by the writer and the writer nonce.\"},\"getInterchainFee(uint256,address[])\":{\"notice\":\"Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain using the provided Interchain Modules.\"},\"readEntry(address,(uint256,uint256,bytes32,bytes32))\":{\"notice\":\"Read the data written on specific source chain by a specific writer, and verify it on the destination chain using the provided Interchain Module. Note: returned zero value indicates that the module has not verified the entry.\"},\"requestVerification(uint256,uint256,address[])\":{\"notice\":\"Request the given Interchain Modules to verify the already written entry on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: this method is permissionless, and anyone can request verification for any entry.\"},\"verifyEntry((uint256,uint256,bytes32,bytes32))\":{\"notice\":\"Allows the Interchain Module to verify the entry coming from a remote source chain.\"},\"writeEntry(bytes32)\":{\"notice\":\"Write data to the Interchain DataBase as a new entry. Note: there are no guarantees that this entry will be available for reading on any of the remote chains. Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\"},\"writeEntryWithVerification(uint256,bytes32,address[])\":{\"notice\":\"Write data to the Interchain DataBase, and request the given Interchain Modules to verify it on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: additional verification for the same entry could be later done using `requestVerification` by providing the returned `dbNonce`.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"IInterchainDB\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0xb1820886ef923c4c065c5baff37b5df87b8df1e6d6b4c15efa8656e6bf9bab55\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://d5135fd5a15dd9be50d78f48a77d63d2477f99180a88a45d658259fa89e992a9\",\"dweb:/ipfs/QmeHcqSVFPtKYu1XVd751xBixEPBV2b3rN2jMUYAMKTKqN\"]}},\"version\":1}"},"hashes":{"getDBNonce()":"f338140e","getEntry(uint256)":"bae78d7b","getInterchainFee(uint256,address[])":"fc7686ec","readEntry(address,(uint256,uint256,bytes32,bytes32))":"a9c9cff1","requestVerification(uint256,uint256,address[])":"81ab5b5a","verifyEntry((uint256,uint256,bytes32,bytes32))":"54941dfa","writeEntry(bytes32)":"2ad8c706","writeEntryWithVerification(uint256,bytes32,address[])":"67c769af"}},"solidity/InterchainClientV1.sol:InterchainClientV1":{"code":"0x608060405234801561001057600080fd5b50338061003757604051631e4fbdf760e01b81526000600482015260240160405180910390fd5b61004081610046565b50610096565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b611f33806100a56000396000f3fe6080604052600436106100f35760003560e01c806380efe7771161008a578063b7ce207811610059578063b7ce20781461031e578063d219d1131461033e578063f2fde38b1461035e578063f34234c81461037e57600080fd5b806380efe7771461029d5780638691d34c146102b05780638da5cb5b146102e057806398939d281461030b57600080fd5b80634d84cc11116100c65780634d84cc11146101f3578063715018a6146102205780637268b08f146102355780637341eaf91461027057600080fd5b80630d898416146100f85780630e785ce01461014f57806331afa7de146101a15780633dc68b87146101d1575b600080fd5b34801561010457600080fd5b506000546101319074010000000000000000000000000000000000000000900467ffffffffffffffff1681565b60405167ffffffffffffffff90911681526020015b60405180910390f35b34801561015b57600080fd5b5060015461017c9073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610146565b3480156101ad57600080fd5b506101c16101bc36600461145f565b61039e565b6040519015158152602001610146565b3480156101dd57600080fd5b506101f16101ec3660046114c3565b610404565b005b3480156101ff57600080fd5b5061021361020e366004611638565b610453565b604051610146919061175d565b34801561022c57600080fd5b506101f161047c565b34801561024157600080fd5b50610262610250366004611770565b60046020526000908152604090205481565b604051908152602001610146565b34801561027c57600080fd5b5060025461017c9073ffffffffffffffffffffffffffffffffffffffff1681565b6101f16102ab366004611789565b610490565b3480156102bc57600080fd5b506101c16102cb366004611770565b60036020526000908152604090205460ff1681565b3480156102ec57600080fd5b5060005473ffffffffffffffffffffffffffffffffffffffff1661017c565b6101f16103193660046117d5565b6106e2565b34801561032a57600080fd5b506101f16103393660046114c3565b610b8f565b34801561034a57600080fd5b506102136103593660046118c8565b610bde565b34801561036a57600080fd5b506101f16103793660046114c3565b610be9565b34801561038a57600080fd5b506101f16103993660046118fa565b610c4d565b6000806103e084848080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610c6792505050565b905060006103ed82610cd3565b90506103f98183610d03565b925050505b92915050565b61040c610e99565b600280547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b606081604051602001610466919061191c565b6040516020818303038152906040529050919050565b610484610e99565b61048e6000610eec565b565b60006104d183838080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610c6792505050565b905060006104de82610cd3565b90506104ea8183610d03565b610555576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f5472616e73616374696f6e206973206e6f742065786563757461626c6500000060448201526064015b60405180910390fd5b600081815260036020526040812080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016600117905560c083015161059a90610f61565b9050806020015134146105e85760208101516040517f2b361025000000000000000000000000000000000000000000000000000000008152346004820152602481019190915260440161054c565b80518610156105f657805195505b606083015173ffffffffffffffffffffffffffffffffffffffff1663d1eb8bde87348660000151876020015188608001518960e001516040518763ffffffff1660e01b815260040161064b94939291906119a7565b6000604051808303818589803b15801561066457600080fd5b5088f1158015610678573d6000803e3d6000fd5b50505060a08601518651602088015160608901516040519396508895507fdb272c7b2f65161c0573b8b7c21bc3e25cf53bcd8c1524fb3fb78bac8c7df94e94506106d2939283526020830191909152604082015260600190565b60405180910390a3505050505050565b6001546040517ffc7686ec00000000000000000000000000000000000000000000000000000000815260009173ffffffffffffffffffffffffffffffffffffffff169063fc7686ec9061073d908d908b908b90600401611a2c565b602060405180830381865afa15801561075a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061077e9190611a4f565b9050600061078c8234611a97565b905060006108bf338d8d600060149054906101000a900467ffffffffffffffff16600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663f338140e6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561081a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061083e9190611a4f565b8c8c8080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050508b8b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610fe592505050565b905060006108cc82610cd3565b9050600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166367c769af858460400151848e8e6040518663ffffffff1660e01b81526004016109349493929190611aaa565b60206040518083038185885af1158015610952573d6000803e3d6000fd5b50505050506040513d601f19601f820116820180604052508101906109779190611a4f565b8260a001511461098957610989611aca565b73ffffffffffffffffffffffffffffffffffffffff8b1615610a3b578a73ffffffffffffffffffffffffffffffffffffffff1663e4e065228e846040516020016109d3919061191c565b6040516020818303038152906040525184878d8d6040518763ffffffff1660e01b8152600401610a0896959493929190611b24565b600060405180830381600087803b158015610a2257600080fd5b505af1158015610a36573d6000803e3d6000fd5b505050505b60025460408381015190517fffecec7e00000000000000000000000000000000000000000000000000000000815260048101919091526024810183905273ffffffffffffffffffffffffffffffffffffffff9091169063ffecec7e9085906044016000604051808303818588803b158015610ab557600080fd5b505af1158015610ac9573d6000803e3d6000fd5b50505050508160a00151817f1e88c89e51d85a8c4b383cced79b9e9f26ef41f4719f5bee6e758f76e3c0450984604001518560200151866060015189898f8f8f8f604051610b1f99989796959493929190611b5c565b60405180910390a36000805474010000000000000000000000000000000000000000900467ffffffffffffffff16906014610b5983611bb1565b91906101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055505050505050505050505050505050565b610b97610e99565b600180547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b60606103fe826110aa565b610bf1610e99565b73ffffffffffffffffffffffffffffffffffffffff8116610c41576040517f1e4fbdf70000000000000000000000000000000000000000000000000000000081526000600482015260240161054c565b610c4a81610eec565b50565b610c55610e99565b60009182526004602052604090912055565b610cbf60405180610100016040528060008152602001600080191681526020016000815260200160008019168152602001600067ffffffffffffffff1681526020016000815260200160608152602001606081525090565b818060200190518101906103fe9190611c28565b600081604051602001610ce6919061191c565b604051602081830303815290604052805190602001209050919050565b60008281526003602052604081205460ff1615610d7c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f5472616e73616374696f6e20616c726561647920657865637574656400000000604482015260640161054c565b60006040518060800160405280846000015181526020018460a00151815260200160046000866000015181526020019081526020016000205481526020018581525090506000806000610dd8610dd3876060015190565b6110e8565b9250925092506000610dea8286611187565b90506000610df88285611307565b905084811015610e8a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603060248201527f4e6f7420656e6f7567682076616c696420726573706f6e73657320746f206d6560448201527f657420746865207468726573686f6c6400000000000000000000000000000000606482015260840161054c565b50600198975050505050505050565b60005473ffffffffffffffffffffffffffffffffffffffff16331461048e576040517f118cdaa700000000000000000000000000000000000000000000000000000000815233600482015260240161054c565b6000805473ffffffffffffffffffffffffffffffffffffffff8381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6040805180820190915260008082526020820152600080610f8184611360565b9092509050600160ff83161015610fc9576040517fbd91a21500000000000000000000000000000000000000000000000000000000815260ff8316600482015260240161054c565b80806020019051810190610fdd9190611d1e565b949350505050565b61103d60405180610100016040528060008152602001600080191681526020016000815260200160008019168152602001600067ffffffffffffffff1681526020016000815260200160608152602001606081525090565b60405180610100016040528046815260200161106c8a73ffffffffffffffffffffffffffffffffffffffff1690565b81526020018881526020018781526020018667ffffffffffffffff168152602001858152602001848152602001838152509050979650505050505050565b60606103fe6001836040516020016110d49190815181526020918201519181019190915260400190565b604051602081830303815290604052611382565b6000806060808473ffffffffffffffffffffffffffffffffffffffff1663287bc0576040518163ffffffff1660e01b8152600401600060405180830381865afa158015611139573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526111619190810190611d3a565b925090506000611170826113ae565b805160209091015190979096509294509192505050565b60606000835167ffffffffffffffff8111156111a5576111a56114e7565b6040519080825280602002602001820160405280156111ce578160200160208202803683370190505b50905060005b84518110156112ff57600154855173ffffffffffffffffffffffffffffffffffffffff9091169063a9c9cff19087908490811061121357611213611e10565b602090810291909101810151604080517fffffffff0000000000000000000000000000000000000000000000000000000060e086901b16815273ffffffffffffffffffffffffffffffffffffffff9092166004830152885160248301529188015160448201529087015160648201526060870151608482015260a401602060405180830381865afa1580156112ac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112d09190611a4f565b8282815181106112e2576112e2611e10565b6020908102919091010152806112f781611e3f565b9150506111d4565b509392505050565b600080805b84518110156112ff57428486838151811061132957611329611e10565b602002602001015161133b9190611e77565b1161134e578161134a81611e3f565b9250505b8061135881611e3f565b91505061130c565b60006060828060200190518101906113789190611e8a565b9094909350915050565b60608282604051602001611397929190611ee1565b604051602081830303815290604052905092915050565b60408051808201909152600080825260208201526000806113ce84611360565b9092509050600160ff83161015610fc9576040517fc3e3b66600000000000000000000000000000000000000000000000000000000815260ff8316600482015260240161054c565b60008083601f84011261142857600080fd5b50813567ffffffffffffffff81111561144057600080fd5b60208301915083602082850101111561145857600080fd5b9250929050565b6000806020838503121561147257600080fd5b823567ffffffffffffffff81111561148957600080fd5b61149585828601611416565b90969095509350505050565b73ffffffffffffffffffffffffffffffffffffffff81168114610c4a57600080fd5b6000602082840312156114d557600080fd5b81356114e0816114a1565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051610100810167ffffffffffffffff8111828210171561153a5761153a6114e7565b60405290565b6040805190810167ffffffffffffffff8111828210171561153a5761153a6114e7565b604051601f8201601f1916810167ffffffffffffffff8111828210171561158c5761158c6114e7565b604052919050565b67ffffffffffffffff81168114610c4a57600080fd5b80356115b581611594565b919050565b600067ffffffffffffffff8211156115d4576115d46114e7565b50601f01601f191660200190565b600082601f8301126115f357600080fd5b8135611606611601826115ba565b611563565b81815284602083860101111561161b57600080fd5b816020850160208301376000918101602001919091529392505050565b60006020828403121561164a57600080fd5b813567ffffffffffffffff8082111561166257600080fd5b90830190610100828603121561167757600080fd5b61167f611516565b823581526020830135602082015260408301356040820152606083013560608201526116ad608084016115aa565b608082015260a083013560a082015260c0830135828111156116ce57600080fd5b6116da878286016115e2565b60c08301525060e0830135828111156116f257600080fd5b6116fe878286016115e2565b60e08301525095945050505050565b60005b83811015611728578181015183820152602001611710565b50506000910152565b6000815180845261174981602086016020860161170d565b601f01601f19169290920160200192915050565b6020815260006114e06020830184611731565b60006020828403121561178257600080fd5b5035919050565b60008060006040848603121561179e57600080fd5b83359250602084013567ffffffffffffffff8111156117bc57600080fd5b6117c886828701611416565b9497909650939450505050565b600080600080600080600080600060c08a8c0312156117f357600080fd5b8935985060208a0135975060408a013561180c816114a1565b965060608a013567ffffffffffffffff8082111561182957600080fd5b818c0191508c601f83011261183d57600080fd5b81358181111561184c57600080fd5b8d60208260051b850101111561186157600080fd5b6020830198508097505060808c013591508082111561187f57600080fd5b61188b8d838e01611416565b909650945060a08c01359150808211156118a457600080fd5b506118b18c828d01611416565b915080935050809150509295985092959850929598565b6000604082840312156118da57600080fd5b6118e2611540565b82358152602083013560208201528091505092915050565b6000806040838503121561190d57600080fd5b50508035926020909101359150565b602081528151602082015260208201516040820152604082015160608201526060820151608082015267ffffffffffffffff60808301511660a082015260a082015160c0820152600060c08301516101008060e0850152611981610120850183611731565b915060e0850151601f19858403018286015261199d8382611731565b9695505050505050565b84815283602082015267ffffffffffffffff8316604082015260806060820152600061199d6080830184611731565b8183526000602080850194508260005b85811015611a215781356119f9816114a1565b73ffffffffffffffffffffffffffffffffffffffff16875295820195908201906001016119e6565b509495945050505050565b838152604060208201526000611a466040830184866119d6565b95945050505050565b600060208284031215611a6157600080fd5b5051919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b818103818111156103fe576103fe611a68565b84815283602082015260606040820152600061199d6060830184866119d6565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052600160045260246000fd5b818352818160208501375060006020828401015260006020601f19601f840116840101905092915050565b86815285602082015284604082015283606082015260a060808201526000611b5060a083018486611af9565b98975050505050505050565b89815288602082015287604082015286606082015285608082015260e060a08201526000611b8e60e083018688611af9565b82810360c0840152611ba1818587611af9565b9c9b505050505050505050505050565b600067ffffffffffffffff808316818103611bce57611bce611a68565b6001019392505050565b80516115b581611594565b600082601f830112611bf457600080fd5b8151611c02611601826115ba565b818152846020838601011115611c1757600080fd5b610fdd82602083016020870161170d565b600060208284031215611c3a57600080fd5b815167ffffffffffffffff80821115611c5257600080fd5b908301906101008286031215611c6757600080fd5b611c6f611516565b82518152602083015160208201526040830151604082015260608301516060820152611c9d60808401611bd8565b608082015260a083015160a082015260c083015182811115611cbe57600080fd5b611cca87828601611be3565b60c08301525060e083015182811115611ce257600080fd5b6116fe87828601611be3565b600060408284031215611d0057600080fd5b611d08611540565b9050815181526020820151602082015292915050565b600060408284031215611d3057600080fd5b6114e08383611cee565b60008060408385031215611d4d57600080fd5b825167ffffffffffffffff80821115611d6557600080fd5b611d7186838701611be3565b9350602091508185015181811115611d8857600080fd5b8501601f81018713611d9957600080fd5b805182811115611dab57611dab6114e7565b8060051b9250611dbc848401611563565b8181529282018401928481019089851115611dd657600080fd5b928501925b84841015611e005783519250611df0836114a1565b8282529285019290850190611ddb565b8096505050505050509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203611e7057611e70611a68565b5060010190565b808201808211156103fe576103fe611a68565b60008060408385031215611e9d57600080fd5b825160ff81168114611eae57600080fd5b602084015190925067ffffffffffffffff811115611ecb57600080fd5b611ed785828601611be3565b9150509250929050565b60ff83168152604060208201526000610fdd604083018461173156fea26469706673582212205285d04181e53ac1cc93dea15c0961cee831b1534a411279c185450a476a309264736f6c63430008140033","runtime-code":"0x6080604052600436106100f35760003560e01c806380efe7771161008a578063b7ce207811610059578063b7ce20781461031e578063d219d1131461033e578063f2fde38b1461035e578063f34234c81461037e57600080fd5b806380efe7771461029d5780638691d34c146102b05780638da5cb5b146102e057806398939d281461030b57600080fd5b80634d84cc11116100c65780634d84cc11146101f3578063715018a6146102205780637268b08f146102355780637341eaf91461027057600080fd5b80630d898416146100f85780630e785ce01461014f57806331afa7de146101a15780633dc68b87146101d1575b600080fd5b34801561010457600080fd5b506000546101319074010000000000000000000000000000000000000000900467ffffffffffffffff1681565b60405167ffffffffffffffff90911681526020015b60405180910390f35b34801561015b57600080fd5b5060015461017c9073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610146565b3480156101ad57600080fd5b506101c16101bc36600461145f565b61039e565b6040519015158152602001610146565b3480156101dd57600080fd5b506101f16101ec3660046114c3565b610404565b005b3480156101ff57600080fd5b5061021361020e366004611638565b610453565b604051610146919061175d565b34801561022c57600080fd5b506101f161047c565b34801561024157600080fd5b50610262610250366004611770565b60046020526000908152604090205481565b604051908152602001610146565b34801561027c57600080fd5b5060025461017c9073ffffffffffffffffffffffffffffffffffffffff1681565b6101f16102ab366004611789565b610490565b3480156102bc57600080fd5b506101c16102cb366004611770565b60036020526000908152604090205460ff1681565b3480156102ec57600080fd5b5060005473ffffffffffffffffffffffffffffffffffffffff1661017c565b6101f16103193660046117d5565b6106e2565b34801561032a57600080fd5b506101f16103393660046114c3565b610b8f565b34801561034a57600080fd5b506102136103593660046118c8565b610bde565b34801561036a57600080fd5b506101f16103793660046114c3565b610be9565b34801561038a57600080fd5b506101f16103993660046118fa565b610c4d565b6000806103e084848080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610c6792505050565b905060006103ed82610cd3565b90506103f98183610d03565b925050505b92915050565b61040c610e99565b600280547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b606081604051602001610466919061191c565b6040516020818303038152906040529050919050565b610484610e99565b61048e6000610eec565b565b60006104d183838080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610c6792505050565b905060006104de82610cd3565b90506104ea8183610d03565b610555576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f5472616e73616374696f6e206973206e6f742065786563757461626c6500000060448201526064015b60405180910390fd5b600081815260036020526040812080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016600117905560c083015161059a90610f61565b9050806020015134146105e85760208101516040517f2b361025000000000000000000000000000000000000000000000000000000008152346004820152602481019190915260440161054c565b80518610156105f657805195505b606083015173ffffffffffffffffffffffffffffffffffffffff1663d1eb8bde87348660000151876020015188608001518960e001516040518763ffffffff1660e01b815260040161064b94939291906119a7565b6000604051808303818589803b15801561066457600080fd5b5088f1158015610678573d6000803e3d6000fd5b50505060a08601518651602088015160608901516040519396508895507fdb272c7b2f65161c0573b8b7c21bc3e25cf53bcd8c1524fb3fb78bac8c7df94e94506106d2939283526020830191909152604082015260600190565b60405180910390a3505050505050565b6001546040517ffc7686ec00000000000000000000000000000000000000000000000000000000815260009173ffffffffffffffffffffffffffffffffffffffff169063fc7686ec9061073d908d908b908b90600401611a2c565b602060405180830381865afa15801561075a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061077e9190611a4f565b9050600061078c8234611a97565b905060006108bf338d8d600060149054906101000a900467ffffffffffffffff16600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663f338140e6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561081a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061083e9190611a4f565b8c8c8080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050508b8b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610fe592505050565b905060006108cc82610cd3565b9050600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166367c769af858460400151848e8e6040518663ffffffff1660e01b81526004016109349493929190611aaa565b60206040518083038185885af1158015610952573d6000803e3d6000fd5b50505050506040513d601f19601f820116820180604052508101906109779190611a4f565b8260a001511461098957610989611aca565b73ffffffffffffffffffffffffffffffffffffffff8b1615610a3b578a73ffffffffffffffffffffffffffffffffffffffff1663e4e065228e846040516020016109d3919061191c565b6040516020818303038152906040525184878d8d6040518763ffffffff1660e01b8152600401610a0896959493929190611b24565b600060405180830381600087803b158015610a2257600080fd5b505af1158015610a36573d6000803e3d6000fd5b505050505b60025460408381015190517fffecec7e00000000000000000000000000000000000000000000000000000000815260048101919091526024810183905273ffffffffffffffffffffffffffffffffffffffff9091169063ffecec7e9085906044016000604051808303818588803b158015610ab557600080fd5b505af1158015610ac9573d6000803e3d6000fd5b50505050508160a00151817f1e88c89e51d85a8c4b383cced79b9e9f26ef41f4719f5bee6e758f76e3c0450984604001518560200151866060015189898f8f8f8f604051610b1f99989796959493929190611b5c565b60405180910390a36000805474010000000000000000000000000000000000000000900467ffffffffffffffff16906014610b5983611bb1565b91906101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055505050505050505050505050505050565b610b97610e99565b600180547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b60606103fe826110aa565b610bf1610e99565b73ffffffffffffffffffffffffffffffffffffffff8116610c41576040517f1e4fbdf70000000000000000000000000000000000000000000000000000000081526000600482015260240161054c565b610c4a81610eec565b50565b610c55610e99565b60009182526004602052604090912055565b610cbf60405180610100016040528060008152602001600080191681526020016000815260200160008019168152602001600067ffffffffffffffff1681526020016000815260200160608152602001606081525090565b818060200190518101906103fe9190611c28565b600081604051602001610ce6919061191c565b604051602081830303815290604052805190602001209050919050565b60008281526003602052604081205460ff1615610d7c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f5472616e73616374696f6e20616c726561647920657865637574656400000000604482015260640161054c565b60006040518060800160405280846000015181526020018460a00151815260200160046000866000015181526020019081526020016000205481526020018581525090506000806000610dd8610dd3876060015190565b6110e8565b9250925092506000610dea8286611187565b90506000610df88285611307565b905084811015610e8a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603060248201527f4e6f7420656e6f7567682076616c696420726573706f6e73657320746f206d6560448201527f657420746865207468726573686f6c6400000000000000000000000000000000606482015260840161054c565b50600198975050505050505050565b60005473ffffffffffffffffffffffffffffffffffffffff16331461048e576040517f118cdaa700000000000000000000000000000000000000000000000000000000815233600482015260240161054c565b6000805473ffffffffffffffffffffffffffffffffffffffff8381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6040805180820190915260008082526020820152600080610f8184611360565b9092509050600160ff83161015610fc9576040517fbd91a21500000000000000000000000000000000000000000000000000000000815260ff8316600482015260240161054c565b80806020019051810190610fdd9190611d1e565b949350505050565b61103d60405180610100016040528060008152602001600080191681526020016000815260200160008019168152602001600067ffffffffffffffff1681526020016000815260200160608152602001606081525090565b60405180610100016040528046815260200161106c8a73ffffffffffffffffffffffffffffffffffffffff1690565b81526020018881526020018781526020018667ffffffffffffffff168152602001858152602001848152602001838152509050979650505050505050565b60606103fe6001836040516020016110d49190815181526020918201519181019190915260400190565b604051602081830303815290604052611382565b6000806060808473ffffffffffffffffffffffffffffffffffffffff1663287bc0576040518163ffffffff1660e01b8152600401600060405180830381865afa158015611139573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526111619190810190611d3a565b925090506000611170826113ae565b805160209091015190979096509294509192505050565b60606000835167ffffffffffffffff8111156111a5576111a56114e7565b6040519080825280602002602001820160405280156111ce578160200160208202803683370190505b50905060005b84518110156112ff57600154855173ffffffffffffffffffffffffffffffffffffffff9091169063a9c9cff19087908490811061121357611213611e10565b602090810291909101810151604080517fffffffff0000000000000000000000000000000000000000000000000000000060e086901b16815273ffffffffffffffffffffffffffffffffffffffff9092166004830152885160248301529188015160448201529087015160648201526060870151608482015260a401602060405180830381865afa1580156112ac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112d09190611a4f565b8282815181106112e2576112e2611e10565b6020908102919091010152806112f781611e3f565b9150506111d4565b509392505050565b600080805b84518110156112ff57428486838151811061132957611329611e10565b602002602001015161133b9190611e77565b1161134e578161134a81611e3f565b9250505b8061135881611e3f565b91505061130c565b60006060828060200190518101906113789190611e8a565b9094909350915050565b60608282604051602001611397929190611ee1565b604051602081830303815290604052905092915050565b60408051808201909152600080825260208201526000806113ce84611360565b9092509050600160ff83161015610fc9576040517fc3e3b66600000000000000000000000000000000000000000000000000000000815260ff8316600482015260240161054c565b60008083601f84011261142857600080fd5b50813567ffffffffffffffff81111561144057600080fd5b60208301915083602082850101111561145857600080fd5b9250929050565b6000806020838503121561147257600080fd5b823567ffffffffffffffff81111561148957600080fd5b61149585828601611416565b90969095509350505050565b73ffffffffffffffffffffffffffffffffffffffff81168114610c4a57600080fd5b6000602082840312156114d557600080fd5b81356114e0816114a1565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051610100810167ffffffffffffffff8111828210171561153a5761153a6114e7565b60405290565b6040805190810167ffffffffffffffff8111828210171561153a5761153a6114e7565b604051601f8201601f1916810167ffffffffffffffff8111828210171561158c5761158c6114e7565b604052919050565b67ffffffffffffffff81168114610c4a57600080fd5b80356115b581611594565b919050565b600067ffffffffffffffff8211156115d4576115d46114e7565b50601f01601f191660200190565b600082601f8301126115f357600080fd5b8135611606611601826115ba565b611563565b81815284602083860101111561161b57600080fd5b816020850160208301376000918101602001919091529392505050565b60006020828403121561164a57600080fd5b813567ffffffffffffffff8082111561166257600080fd5b90830190610100828603121561167757600080fd5b61167f611516565b823581526020830135602082015260408301356040820152606083013560608201526116ad608084016115aa565b608082015260a083013560a082015260c0830135828111156116ce57600080fd5b6116da878286016115e2565b60c08301525060e0830135828111156116f257600080fd5b6116fe878286016115e2565b60e08301525095945050505050565b60005b83811015611728578181015183820152602001611710565b50506000910152565b6000815180845261174981602086016020860161170d565b601f01601f19169290920160200192915050565b6020815260006114e06020830184611731565b60006020828403121561178257600080fd5b5035919050565b60008060006040848603121561179e57600080fd5b83359250602084013567ffffffffffffffff8111156117bc57600080fd5b6117c886828701611416565b9497909650939450505050565b600080600080600080600080600060c08a8c0312156117f357600080fd5b8935985060208a0135975060408a013561180c816114a1565b965060608a013567ffffffffffffffff8082111561182957600080fd5b818c0191508c601f83011261183d57600080fd5b81358181111561184c57600080fd5b8d60208260051b850101111561186157600080fd5b6020830198508097505060808c013591508082111561187f57600080fd5b61188b8d838e01611416565b909650945060a08c01359150808211156118a457600080fd5b506118b18c828d01611416565b915080935050809150509295985092959850929598565b6000604082840312156118da57600080fd5b6118e2611540565b82358152602083013560208201528091505092915050565b6000806040838503121561190d57600080fd5b50508035926020909101359150565b602081528151602082015260208201516040820152604082015160608201526060820151608082015267ffffffffffffffff60808301511660a082015260a082015160c0820152600060c08301516101008060e0850152611981610120850183611731565b915060e0850151601f19858403018286015261199d8382611731565b9695505050505050565b84815283602082015267ffffffffffffffff8316604082015260806060820152600061199d6080830184611731565b8183526000602080850194508260005b85811015611a215781356119f9816114a1565b73ffffffffffffffffffffffffffffffffffffffff16875295820195908201906001016119e6565b509495945050505050565b838152604060208201526000611a466040830184866119d6565b95945050505050565b600060208284031215611a6157600080fd5b5051919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b818103818111156103fe576103fe611a68565b84815283602082015260606040820152600061199d6060830184866119d6565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052600160045260246000fd5b818352818160208501375060006020828401015260006020601f19601f840116840101905092915050565b86815285602082015284604082015283606082015260a060808201526000611b5060a083018486611af9565b98975050505050505050565b89815288602082015287604082015286606082015285608082015260e060a08201526000611b8e60e083018688611af9565b82810360c0840152611ba1818587611af9565b9c9b505050505050505050505050565b600067ffffffffffffffff808316818103611bce57611bce611a68565b6001019392505050565b80516115b581611594565b600082601f830112611bf457600080fd5b8151611c02611601826115ba565b818152846020838601011115611c1757600080fd5b610fdd82602083016020870161170d565b600060208284031215611c3a57600080fd5b815167ffffffffffffffff80821115611c5257600080fd5b908301906101008286031215611c6757600080fd5b611c6f611516565b82518152602083015160208201526040830151604082015260608301516060820152611c9d60808401611bd8565b608082015260a083015160a082015260c083015182811115611cbe57600080fd5b611cca87828601611be3565b60c08301525060e083015182811115611ce257600080fd5b6116fe87828601611be3565b600060408284031215611d0057600080fd5b611d08611540565b9050815181526020820151602082015292915050565b600060408284031215611d3057600080fd5b6114e08383611cee565b60008060408385031215611d4d57600080fd5b825167ffffffffffffffff80821115611d6557600080fd5b611d7186838701611be3565b9350602091508185015181811115611d8857600080fd5b8501601f81018713611d9957600080fd5b805182811115611dab57611dab6114e7565b8060051b9250611dbc848401611563565b8181529282018401928481019089851115611dd657600080fd5b928501925b84841015611e005783519250611df0836114a1565b8282529285019290850190611ddb565b8096505050505050509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203611e7057611e70611a68565b5060010190565b808201808211156103fe576103fe611a68565b60008060408385031215611e9d57600080fd5b825160ff81168114611eae57600080fd5b602084015190925067ffffffffffffffff811115611ecb57600080fd5b611ed785828601611be3565b9150509250929050565b60ff83168152604060208201526000610fdd604083018461173156fea26469706673582212205285d04181e53ac1cc93dea15c0961cee831b1534a411279c185450a476a309264736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainClientV1Events.sol\n\nabstract contract InterchainClientV1Events {\n    // TODO: figure out indexing\n\n    event InterchainTransactionSent(\n        bytes32 indexed transactionId,\n        uint256 indexed dbNonce,\n        uint256 dstChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver,\n        uint256 verificationFee,\n        uint256 executionFee,\n        bytes options,\n        bytes message\n    );\n\n    event InterchainTransactionReceived(\n        bytes32 indexed transactionId,\n        uint256 indexed dbNonce,\n        uint256 srcChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver\n    );\n}\n\n// contracts/interfaces/IExecutionFees.sol\n\ninterface IExecutionFees {\n    /// @notice Add the execution fee for a transaction. The attached value will be added to the\n    /// rewards for the executor completing the transaction.\n    /// Note: this could be used to store the execution fee for a new transaction, or to add more\n    /// funds to the execution fee of an existing transaction. Therefore this function is payable,\n    /// and does not implement any caller restrictions.\n    /// @dev Will revert if the executor is already recorded for the transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to add the execution fee to.\n    function addExecutionFee(uint256 dstChainId, bytes32 transactionId) external payable;\n\n    /// @notice Record the executor (who completed the transaction) for a transaction,\n    /// and update the accumulated rewards for the executor.\n    /// @dev Could only be called by the Recorder.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to record the executor for.\n    /// @param executor             The address of the executor who completed the transaction.\n    function recordExecutor(uint256 dstChainId, bytes32 transactionId, address executor) external;\n\n    /// @notice Allows the executor to claim their unclaimed rewards.\n    /// @dev Will revert if the executor has no unclaimed rewards.\n    function claimExecutionFees() external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the accumulated rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function getAccumulatedRewards(address executor) external view returns (uint256 accumulated);\n\n    /// @notice Get the unclaimed rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function getUnclaimedRewards(address executor) external view returns (uint256 unclaimed);\n}\n\n// contracts/interfaces/IExecutionService.sol\n\ninterface IExecutionService {\n    /// @notice Request the execution of an Interchain Transaction on a remote chain.\n    /// Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient\n    /// event with the same transactionId, then execute the transaction on the remote chain:\n    /// `dstInterchainClient.executeTransaction(transactionPayload)`\n    /// Once the execution is confirmed on the source chain, the off-chain actor will be able\n    /// to claim `executionFee` in the ExecutionFees contract.\n    /// @dev Could only be called by `InterchainClient` contracts.\n    /// Will revert if the execution fee is not big enough.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param transactionId        The id of the transaction to execute.\n    /// @param executionFee         The fee paid for the execution.\n    /// @param options              The options to use for the execution.\n    function requestExecution(\n        uint256 dstChainId,\n        uint256 txPayloadSize,\n        bytes32 transactionId,\n        uint256 executionFee,\n        bytes memory options\n    )\n        external;\n\n    /// @notice Get the execution fee for executing an Interchain Transaction on a remote chain.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param options              The options to use for the execution.\n    function getExecutionFee(\n        uint256 dstChainId,\n        uint256 txPayloadSize,\n        bytes memory options\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\ninterface IInterchainApp {\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory sendingModules,\n        address[] memory receivingModules,\n        uint256 requiredResponses,\n        uint64 optimisticTimePeriod\n    )\n        external;\n\n    function getLinkedIApp(uint64 chainID) external view returns (address);\n\n    function getSendingModules() external view returns (address[] memory);\n\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable;\n\n    function appReceive(uint256 srcChainId, bytes32 sender, uint64 nonce, bytes calldata message) external payable;\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 expected);\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sets the address of the InterchainDB contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param _interchainDB The address of the InterchainDB contract.\n     */\n    function setInterchainDB(address _interchainDB) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently primarily gas limit + native gas drop.\n     * @param message The message being sent.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     */\n    function interchainExecute(uint256 gasLimit, bytes calldata transaction) external payable;\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction The InterchainTransaction struct to be checked.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction) external view returns (bool);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    uint8 constant OPTIONS_V1 = 1;\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the entry on the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint64 nonce;\n    uint256 dbNonce;\n    bytes options;\n    bytes message;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint64 nonce,\n        uint256 dbNonce,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            nonce: nonce,\n            dbNonce: dbNonce,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the local Interchain DataBase.\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    struct LocalEntry {\n        address writer;\n        bytes32 dataHash;\n    }\n\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param entryValue   The value of the entry: writer + dataHash hashed together\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 entryValue;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingEntryValue, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(uint256 dbNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the written entry on this chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(uint256 destChainId, uint256 dbNonce, address[] memory srcModules) external payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`\n    /// by providing the returned `dbNonce`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param dbNonce      The database nonce of the written entry on this chain\n    function getEntry(uint256 dbNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the database.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, InterchainClientV1Events, IInterchainClientV1 {\n    using AppConfigLib for bytes;\n    using OptionsLib for bytes;\n\n    uint64 public clientNonce;\n    address public interchainDB;\n    address public executionFees;\n    mapping(bytes32 =\u003e bool) public executedTransactions;\n\n    // Chain ID =\u003e Bytes32 Address of src clients\n    mapping(uint256 =\u003e bytes32) public linkedClients;\n\n    constructor() Ownable(msg.sender) {}\n\n    // @inheritdoc IInterchainClientV1\n    function setExecutionFees(address executionFees_) public onlyOwner {\n        executionFees = executionFees_;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setInterchainDB(address _interchainDB) public onlyOwner {\n        interchainDB = _interchainDB;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint256 chainId, bytes32 client) public onlyOwner {\n        linkedClients[chainId] = client;\n    }\n\n    // TODO: Calculate Gas Pricing per module and charge fees\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        public\n        payable\n    {\n        // TODO: should check options for being correctly formatted\n        uint256 verificationFee = IInterchainDB(interchainDB).getInterchainFee(dstChainId, srcModules);\n        // TODO: should check msg.value \u003e= verificationFee\n        uint256 executionFee = msg.value - verificationFee;\n\n        InterchainTransaction memory icTx = InterchainTransactionLib.constructLocalTransaction({\n            srcSender: msg.sender,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            nonce: clientNonce,\n            dbNonce: IInterchainDB(interchainDB).getDBNonce(),\n            options: options,\n            message: message\n        });\n\n        bytes32 transactionId = icTx.transactionId();\n        // Sanity check: nonce returned from DB should match the nonce used to construct the transaction\n        assert(\n            icTx.dbNonce\n                == IInterchainDB(interchainDB).writeEntryWithVerification{value: verificationFee}(\n                    icTx.dstChainId, transactionId, srcModules\n                )\n        );\n        if (srcExecutionService != address(0)) {\n            IExecutionService(srcExecutionService).requestExecution({\n                dstChainId: dstChainId,\n                // TODO: there should be a way to calculate the payload size without encoding the transaction\n                txPayloadSize: abi.encode(icTx).length,\n                transactionId: transactionId,\n                executionFee: executionFee,\n                options: options\n            });\n        }\n        IExecutionFees(executionFees).addExecutionFee{value: executionFee}(icTx.dstChainId, transactionId);\n        emit InterchainTransactionSent(\n            transactionId,\n            icTx.dbNonce,\n            icTx.dstChainId,\n            icTx.srcSender,\n            icTx.dstReceiver,\n            verificationFee,\n            executionFee,\n            options,\n            message\n        );\n        // Increment nonce for next message\n        clientNonce++;\n    }\n\n    // TODO: App Config Versioning\n    // TODO: What if receiver is not a contract / doesn't conform to interface?\n    /**\n     * @dev Retrieves the application configuration for a given receiver application.\n     * @param receiverApp The address of the receiver application.\n     * @return requiredResponses The number of required responses from the receiving modules.\n     * @return optimisticTimePeriod The time period within which responses are considered valid.\n     * @return approvedDstModules An array of addresses of the approved destination modules.\n     */\n    function _getAppConfig(address receiverApp)\n        internal\n        view\n        returns (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules)\n    {\n        bytes memory appConfig;\n        (appConfig, approvedDstModules) = IInterchainApp(receiverApp).getReceivingConfig();\n        AppConfigV1 memory decodedAppConfig = appConfig.decodeAppConfigV1();\n        requiredResponses = decodedAppConfig.requiredResponses;\n        optimisticTimePeriod = decodedAppConfig.optimisticPeriod;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata encodedTx) public view returns (bool) {\n        InterchainTransaction memory icTx = InterchainTransactionLib.decodeTransaction(encodedTx);\n        bytes32 transactionId = icTx.transactionId();\n        return _isExecutable(transactionId, icTx);\n    }\n\n    function _isExecutable(bytes32 transactionId, InterchainTransaction memory icTx) internal view returns (bool) {\n        require(executedTransactions[transactionId] == false, \"Transaction already executed\");\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            dbNonce: icTx.dbNonce,\n            srcWriter: linkedClients[icTx.srcChainId],\n            dataHash: transactionId\n        });\n\n        (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules) =\n            _getAppConfig(TypeCasts.bytes32ToAddress(icTx.dstReceiver));\n\n        uint256[] memory approvedResponses = _getApprovedResponses(approvedDstModules, icEntry);\n\n        uint256 finalizedResponses = _getFinalizedResponsesCount(approvedResponses, optimisticTimePeriod);\n        require(finalizedResponses \u003e= requiredResponses, \"Not enough valid responses to meet the threshold\");\n        return true;\n    }\n\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedResponses An array of timestamps when each approved response was recorded.\n     * @param optimisticTimePeriod The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses The count of responses that are finalized within the optimistic time period.\n     */\n    function _getFinalizedResponsesCount(\n        uint256[] memory approvedResponses,\n        uint256 optimisticTimePeriod\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 finalizedResponses = 0;\n        for (uint256 i = 0; i \u003c approvedResponses.length; i++) {\n            if (approvedResponses[i] + optimisticTimePeriod \u003c= block.timestamp) {\n                finalizedResponses++;\n            }\n        }\n        return finalizedResponses;\n    }\n    /**\n     * @dev Retrieves the responses from approved modules for a given InterchainEntry.\n     * This function iterates over all approved modules, querying the InterchainDB for each module's response\n     * to the provided InterchainEntry. It compiles these responses into an array of uint256, where each\n     * element represents the timestamp of a module's response.\n     *\n     * @param approvedModules An array of addresses representing the approved modules that can write responses.\n     * @param icEntry The InterchainEntry for which responses are being retrieved.\n     * @return approvedResponses An array of uint256 representing the timestamps of responses from approved modules.\n     */\n\n    function _getApprovedResponses(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry\n    )\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory approvedResponses = new uint256[](approvedModules.length);\n        for (uint256 i = 0; i \u003c approvedModules.length; i++) {\n            approvedResponses[i] = IInterchainDB(interchainDB).readEntry(approvedModules[i], icEntry);\n        }\n        return approvedResponses;\n    }\n\n    function encodeTransaction(InterchainTransaction memory icTx) public view returns (bytes memory) {\n        return abi.encode(icTx);\n    }\n\n    function encodeOptionsV1(OptionsV1 memory options) public view returns (bytes memory) {\n        return options.encodeOptionsV1();\n    }\n\n    // TODO: Gas Fee Consideration that is paid to executor\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(uint256 gasLimit, bytes calldata transaction) external payable {\n        InterchainTransaction memory icTx = InterchainTransactionLib.decodeTransaction(transaction);\n        bytes32 transactionId = icTx.transactionId();\n        require(_isExecutable(transactionId, icTx), \"Transaction is not executable\");\n        executedTransactions[transactionId] = true;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n        if (msg.value != decodedOptions.gasAirdrop) {\n            revert InterchainClientV1__IncorrectMsgValue(msg.value, decodedOptions.gasAirdrop);\n        }\n        // We should always use at least as much as the requested gas limit.\n        // The executor can specify a higher gas limit if they wanted.\n        if (decodedOptions.gasLimit \u003e gasLimit) gasLimit = decodedOptions.gasLimit;\n        // Pass the full msg.value to the app: we have already checked that it matches the requested gas airdrop.\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: gasLimit, value: msg.value}({\n            srcChainId: icTx.srcChainId,\n            sender: icTx.srcSender,\n            nonce: icTx.nonce,\n            message: icTx.message\n        });\n        emit InterchainTransactionReceived(\n            transactionId, icTx.dbNonce, icTx.srcChainId, icTx.srcSender, icTx.dstReceiver\n        );\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"27666:9667:0:-:0;;;28087:36;;;;;;;;;-1:-1:-1;28109:10:0;;20190:95;;20243:31;;-1:-1:-1;;;20243:31:0;;20271:1;20243:31;;;160:51:1;133:18;;20243:31:0;;;;;;;20190:95;20294:32;20313:12;20294:18;:32::i;:::-;20146:187;27666:9667;;21833:187;21906:16;21925:6;;-1:-1:-1;;;;;21941:17:0;;;-1:-1:-1;;;;;;21941:17:0;;;;;;21973:40;;21925:6;;;;;;;21973:40;;21906:16;21973:40;21896:124;21833:187;:::o;14:203:1:-;27666:9667:0;;;;;;","srcMapRuntime":"27666:9667:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;27825:25;;;;;;;;;;-1:-1:-1;27825:25:0;;;;;;;;;;;;;;188:18:1;176:31;;;158:50;;146:2;131:18;27825:25:0;;;;;;;;27856:27;;;;;;;;;;-1:-1:-1;27856:27:0;;;;;;;;;;;395:42:1;383:55;;;365:74;;353:2;338:18;27856:27:0;219:226:1;32113:286:0;;;;;;;;;;-1:-1:-1;32113:286:0;;;;;:::i;:::-;;:::i;:::-;;;1381:14:1;;1374:22;1356:41;;1344:2;1329:18;32113:286:0;1216:187:1;28168:114:0;;;;;;;;;;-1:-1:-1;28168:114:0;;;;;:::i;:::-;;:::i;:::-;;35562:137;;;;;;;;;;-1:-1:-1;35562:137:0;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;21214:101::-;;;;;;;;;;;;;:::i;28032:48::-;;;;;;;;;;-1:-1:-1;28032:48:0;;;;;:::i;:::-;;;;;;;;;;;;;;;;;6154:25:1;;;6142:2;6127:18;28032:48:0;6008:177:1;27889:28:0;;;;;;;;;;-1:-1:-1;27889:28:0;;;;;;;;35945:1386;;;;;;:::i;:::-;;:::i;27923:52::-;;;;;;;;;;-1:-1:-1;27923:52:0;;;;;:::i;:::-;;;;;;;;;;;;;;;;20559:85;;;;;;;;;;-1:-1:-1;20605:7:0;20631:6;;;20559:85;;28712:2255;;;;;;:::i;:::-;;:::i;28327:110::-;;;;;;;;;;-1:-1:-1;28327:110:0;;;;;:::i;:::-;;:::i;35705:135::-;;;;;;;;;;-1:-1:-1;35705:135:0;;;;;:::i;:::-;;:::i;21464:215::-;;;;;;;;;;-1:-1:-1;21464:215:0;;;;;:::i;:::-;;:::i;28482:123::-;;;;;;;;;;-1:-1:-1;28482:123:0;;;;;:::i;:::-;;:::i;32113:286::-;32182:4;32198:33;32234:53;32277:9;;32234:53;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;32234:42:0;;-1:-1:-1;;;32234:53:0:i;:::-;32198:89;;32297:21;32321:20;:4;:18;:20::i;:::-;32297:44;;32358:34;32372:13;32387:4;32358:13;:34::i;:::-;32351:41;;;;32113:286;;;;;:::o;28168:114::-;20452:13;:11;:13::i;:::-;28245::::1;:30:::0;;;::::1;;::::0;;;::::1;::::0;;;::::1;::::0;;28168:114::o;35562:137::-;35645:12;35687:4;35676:16;;;;;;;;:::i;:::-;;;;;;;;;;;;;35669:23;;35562:137;;;:::o;21214:101::-;20452:13;:11;:13::i;:::-;21278:30:::1;21305:1;21278:18;:30::i;:::-;21214:101::o:0;35945:1386::-;36045:33;36081:55;36124:11;;36081:55;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;36081:42:0;;-1:-1:-1;;;36081:55:0:i;:::-;36045:91;;36146:21;36170:20;:4;:18;:20::i;:::-;36146:44;;36208:34;36222:13;36237:4;36208:13;:34::i;:::-;36200:76;;;;;;;10157:2:1;36200:76:0;;;10139:21:1;10196:2;10176:18;;;10169:30;10235:31;10215:18;;;10208:59;10284:18;;36200:76:0;;;;;;;;;36286:35;;;;:20;:35;;;;;:42;;;;36324:4;36286:42;;;36373:12;;;;:30;;:28;:30::i;:::-;36339:64;;36430:14;:25;;;36417:9;:38;36413:151;;36527:25;;;;36478:75;;;;;36516:9;36478:75;;;10487:25:1;10528:18;;;10521:34;;;;10460:18;;36478:75:0;10313:248:1;36413:151:0;36725:23;;:34;-1:-1:-1;36721:74:0;;;36772:23;;;-1:-1:-1;36721:74:0;36961:16;;;;36919:71;;;36996:8;37013:9;37050:4;:15;;;37087:4;:14;;;37122:4;:10;;;37155:4;:12;;;36919:259;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;37251:12:0;;;;37265:15;;37282:14;;;;37298:16;;;;37193:131;;37251:12;;-1:-1:-1;37236:13:0;;-1:-1:-1;37193:131:0;;-1:-1:-1;37193:131:0;;11228:25:1;;;11284:2;11269:18;;11262:34;;;;11327:2;11312:18;;11305:34;11216:2;11201:18;;11026:319;37193:131:0;;;;;;;;36035:1296;;;35945:1386;;;:::o;28712:2255::-;29089:12;;29075:68;;;;;29049:23;;29089:12;;;29075:44;;:68;;29120:10;;29132;;;;29075:68;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;29049:94;-1:-1:-1;29212:20:0;29235:27;29049:94;29235:9;:27;:::i;:::-;29212:50;;29273:33;29309:323;29385:10;29456;29422:8;29487:11;;;;;;;;;;;29535:12;;;;;;;;;;;29521:38;;;:40;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;29584:7;;29309:323;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;29614:7;;29309:323;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;29309:50:0;;-1:-1:-1;;;29309:323:0:i;:::-;29273:359;;29643:21;29667:20;:4;:18;:20::i;:::-;29643:44;;29868:12;;;;;;;;;;;29854:54;;;29916:15;29954:4;:15;;;29971:13;29986:10;;29854:160;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;29822:4;:12;;;:192;29802:222;;;;:::i;:::-;30038:33;;;;30034:465;;30105:19;30087:55;;;30173:10;30337:4;30326:16;;;;;;;;:::i;:::-;;;;;;;;;;;;;:23;30382:13;30427:12;30466:7;;30087:401;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;30034:465;30523:13;;30575:15;;;;;30508:98;;;;;;;;10487:25:1;;;;10528:18;;;10521:34;;;30523:13:0;;;;;30508:45;;30561:12;;10460:18:1;;30508:98:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;30687:4;:12;;;30660:13;30621:272;30713:4;:15;;;30742:4;:14;;;30770:4;:16;;;30800:15;30829:12;30855:7;;30876;;30621:272;;;;;;;;;;;;;;:::i;:::-;;;;;;;;30947:11;:13;;;;;;;;:11;:13;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;28971:1996;;;;28712:2255;;;;;;;;;:::o;28327:110::-;20452:13;:11;:13::i;:::-;28402:12:::1;:28:::0;;;::::1;;::::0;;;::::1;::::0;;;::::1;::::0;;28327:110::o;35705:135::-;35777:12;35808:25;:7;:23;:25::i;21464:215::-;20452:13;:11;:13::i;:::-;21548:22:::1;::::0;::::1;21544:91;;21593:31;::::0;::::1;::::0;;21621:1:::1;21593:31;::::0;::::1;365:74:1::0;338:18;;21593:31:0::1;219:226:1::0;21544:91:0::1;21644:28;21663:8;21644:18;:28::i;:::-;21464:215:::0;:::o;28482:123::-;20452:13;:11;:13::i;:::-;28567:22:::1;::::0;;;:13:::1;:22;::::0;;;;;:31;28482:123::o;18627:174::-;18701:28;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;18701:28:0;18759:9;18748:46;;;;;;;;;;;;:::i;18807:155::-;18895:7;18942:11;18931:23;;;;;;;;:::i;:::-;;;;;;;;;;;;;18921:34;;;;;;18914:41;;18807:155;;;:::o;32405:1030::-;32509:4;32533:35;;;:20;:35;;;;;;;;:44;32525:85;;;;;;;17466:2:1;32525:85:0;;;17448:21:1;17505:2;17485:18;;;17478:30;17544;17524:18;;;17517:58;17592:18;;32525:85:0;17264:352:1;32525:85:0;32684:30;32717:195;;;;;;;;32759:4;:15;;;32717:195;;;;32797:4;:12;;;32717:195;;;;32834:13;:30;32848:4;:15;;;32834:30;;;;;;;;;;;;32717:195;;;;32888:13;32717:195;;;32684:228;;32924:25;32951:28;32981:35;33032:59;33046:44;33073:4;:16;;;14521:1;14411:121;33046:44;33032:13;:59::i;:::-;32923:168;;;;;;33102:34;33139:50;33161:18;33181:7;33139:21;:50::i;:::-;33102:87;;33200:26;33229:68;33257:17;33276:20;33229:27;:68::i;:::-;33200:97;;33337:17;33315:18;:39;;33307:100;;;;;;;17823:2:1;33307:100:0;;;17805:21:1;17862:2;17842:18;;;17835:30;17901:34;17881:18;;;17874:62;17972:18;17952;;;17945:46;18008:19;;33307:100:0;17621:412:1;33307:100:0;-1:-1:-1;33424:4:0;;32405:1030;-1:-1:-1;;;;;;;;32405:1030:0:o;20717:162::-;20605:7;20631:6;20776:23;20631:6;15272:10;20776:23;20772:101;;20822:40;;;;;15272:10;20822:40;;;365:74:1;338:18;;20822:40:0;219:226:1;21833:187:0;21906:16;21925:6;;;21941:17;;;;;;;;;;21973:40;;21925:6;;;;;;;21973:40;;21906:16;21973:40;21896:124;21833:187;:::o;13614:603::-;-1:-1:-1;;;;;;;;;;;;;;;;;13710:13:0;13725:20;13749:28;13772:4;13749:22;:28::i;:::-;13709:68;;-1:-1:-1;13709:68:0;-1:-1:-1;12370:1:0;13791:20;;;;13787:95;;;13834:37;;;;;18210:4:1;18198:17;;13834:37:0;;;18180:36:1;18153:18;;13834:37:0;18038:184:1;13787:95:0;14189:7;14178:32;;;;;;;;;;;;:::i;:::-;14171:39;13614:603;-1:-1:-1;;;;13614:603:0:o;17789:673::-;18068:40;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;18068:40:0;18131:324;;;;;;;;18179:13;18131:324;;;;18217:37;18244:9;14375:22;;;14278:127;18217:37;18131:324;;;;18280:10;18131:324;;;;18317:11;18131:324;;;;18349:5;18131:324;;;;;;18377:7;18131:324;;;;18407:7;18131:324;;;;18437:7;18131:324;;;18124:331;;17789:673;;;;;;;;;:::o;13281:167::-;13355:12;13386:55;12370:1;13432:7;13421:19;;;;;;;18986:13:1;;18968:32;;19056:4;19044:17;;;19038:24;19016:20;;;19009:54;;;;18956:2;18941:18;;18770:299;13421:19:0;;;;;;;;;;;;;13386:22;:55::i;31541:527::-;31632:25;31659:28;31689:35;31740:22;31821:11;31806:46;;;:48;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;31806:48:0;;;;;;;;;;;;:::i;:::-;31772:82;-1:-1:-1;31772:82:0;-1:-1:-1;31864:35:0;31902:29;31772:82;31902:27;:29::i;:::-;31961:34;;32028:33;;;;;31961:34;;32028:33;;-1:-1:-1;31541:527:0;;-1:-1:-1;31541:527:0;;-1:-1:-1;;;31541:527:0:o;35067:489::-;35233:16;35265:34;35316:15;:22;35302:37;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;35302:37:0;;35265:74;;35354:9;35349:167;35373:15;:22;35369:1;:26;35349:167;;;35453:12;;35477:18;;35453:12;;;;;35439:37;;35477:15;;35493:1;;35477:18;;;;;;:::i;:::-;;;;;;;;;;;;35439:66;;;;;;;;;;;20750:42:1;20738:55;;;35439:66:0;;;20720:74:1;20830:13;;20810:18;;;20803:41;20886:15;;;20880:22;20860:18;;;20853:50;20945:15;;;20939:22;20919:18;;;20912:50;20934:2;21005:15;;20999:22;20978:19;;;20971:51;20692:19;;35439:66:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;35416:17;35434:1;35416:20;;;;;;;;:::i;:::-;;;;;;;;;;:89;35397:3;;;;:::i;:::-;;;;35349:167;;;-1:-1:-1;35532:17:0;35067:489;-1:-1:-1;;;35067:489:0:o;33884:476::-;34056:7;;;34119:200;34143:17;:24;34139:1;:28;34119:200;;;34239:15;34215:20;34192:17;34210:1;34192:20;;;;;;;;:::i;:::-;;;;;;;:43;;;;:::i;:::-;:62;34188:121;;34274:20;;;;:::i;:::-;;;;34188:121;34169:3;;;;:::i;:::-;;;;34119:200;;12985:181;13059:13;13074:20;13138:4;13127:32;;;;;;;;;;;;:::i;:::-;13106:53;;;;-1:-1:-1;12985:181:0;-1:-1:-1;;12985:181:0:o;12548:158::-;12640:12;12682:7;12691;12671:28;;;;;;;;;:::i;:::-;;;;;;;;;;;;;12664:35;;12548:158;;;;:::o;11120:620::-;-1:-1:-1;;;;;;;;;;;;;;;;;11220:13:0;11235:22;11261:30;11286:4;11261:24;:30::i;:::-;11219:72;;-1:-1:-1;11219:72:0;-1:-1:-1;9786:1:0;11305:23;;;;11301:100;;;11351:39;;;;;18210:4:1;18198:17;;11351:39:0;;;18180:36:1;18153:18;;11351:39:0;18038:184:1;450:347;501:8;511:6;565:3;558:4;550:6;546:17;542:27;532:55;;583:1;580;573:12;532:55;-1:-1:-1;606:20:1;;649:18;638:30;;635:50;;;681:1;678;671:12;635:50;718:4;710:6;706:17;694:29;;770:3;763:4;754:6;746;742:19;738:30;735:39;732:59;;;787:1;784;777:12;732:59;450:347;;;;;:::o;802:409::-;872:6;880;933:2;921:9;912:7;908:23;904:32;901:52;;;949:1;946;939:12;901:52;989:9;976:23;1022:18;1014:6;1011:30;1008:50;;;1054:1;1051;1044:12;1008:50;1093:58;1143:7;1134:6;1123:9;1119:22;1093:58;:::i;:::-;1170:8;;1067:84;;-1:-1:-1;802:409:1;-1:-1:-1;;;;802:409:1:o;1408:154::-;1494:42;1487:5;1483:54;1476:5;1473:65;1463:93;;1552:1;1549;1542:12;1567:247;1626:6;1679:2;1667:9;1658:7;1654:23;1650:32;1647:52;;;1695:1;1692;1685:12;1647:52;1734:9;1721:23;1753:31;1778:5;1753:31;:::i;:::-;1803:5;1567:247;-1:-1:-1;;;1567:247:1:o;1819:184::-;1871:77;1868:1;1861:88;1968:4;1965:1;1958:15;1992:4;1989:1;1982:15;2008:255;2080:2;2074:9;2122:6;2110:19;;2159:18;2144:34;;2180:22;;;2141:62;2138:88;;;2206:18;;:::i;:::-;2242:2;2235:22;2008:255;:::o;2268:251::-;2340:2;2334:9;;;2370:15;;2415:18;2400:34;;2436:22;;;2397:62;2394:88;;;2462:18;;:::i;2524:334::-;2595:2;2589:9;2651:2;2641:13;;-1:-1:-1;;2637:86:1;2625:99;;2754:18;2739:34;;2775:22;;;2736:62;2733:88;;;2801:18;;:::i;:::-;2837:2;2830:22;2524:334;;-1:-1:-1;2524:334:1:o;2863:129::-;2948:18;2941:5;2937:30;2930:5;2927:41;2917:69;;2982:1;2979;2972:12;2997:132;3064:20;;3093:30;3064:20;3093:30;:::i;:::-;2997:132;;;:::o;3134:245::-;3182:4;3215:18;3207:6;3204:30;3201:56;;;3237:18;;:::i;:::-;-1:-1:-1;3294:2:1;3282:15;-1:-1:-1;;3278:88:1;3368:4;3274:99;;3134:245::o;3384:462::-;3426:5;3479:3;3472:4;3464:6;3460:17;3456:27;3446:55;;3497:1;3494;3487:12;3446:55;3533:6;3520:20;3564:48;3580:31;3608:2;3580:31;:::i;:::-;3564:48;:::i;:::-;3637:2;3628:7;3621:19;3683:3;3676:4;3671:2;3663:6;3659:15;3655:26;3652:35;3649:55;;;3700:1;3697;3690:12;3649:55;3765:2;3758:4;3750:6;3746:17;3739:4;3730:7;3726:18;3713:55;3813:1;3788:16;;;3806:4;3784:27;3777:38;;;;3792:7;3384:462;-1:-1:-1;;;3384:462:1:o;3851:1156::-;3948:6;4001:2;3989:9;3980:7;3976:23;3972:32;3969:52;;;4017:1;4014;4007:12;3969:52;4057:9;4044:23;4086:18;4127:2;4119:6;4116:14;4113:34;;;4143:1;4140;4133:12;4113:34;4166:22;;;;4222:6;4204:16;;;4200:29;4197:49;;;4242:1;4239;4232:12;4197:49;4268:22;;:::i;:::-;4326:2;4313:16;4306:5;4299:31;4383:2;4379;4375:11;4362:25;4357:2;4350:5;4346:14;4339:49;4441:2;4437;4433:11;4420:25;4415:2;4408:5;4404:14;4397:49;4499:2;4495;4491:11;4478:25;4473:2;4466:5;4462:14;4455:49;4537:31;4563:3;4559:2;4555:12;4537:31;:::i;:::-;4531:3;4524:5;4520:15;4513:56;4623:3;4619:2;4615:12;4602:26;4596:3;4589:5;4585:15;4578:51;4675:3;4671:2;4667:12;4654:26;4705:2;4695:8;4692:16;4689:36;;;4721:1;4718;4711:12;4689:36;4758:44;4794:7;4783:8;4779:2;4775:17;4758:44;:::i;:::-;4752:3;4745:5;4741:15;4734:69;;4849:3;4845:2;4841:12;4828:26;4879:2;4869:8;4866:16;4863:36;;;4895:1;4892;4885:12;4863:36;4932:44;4968:7;4957:8;4953:2;4949:17;4932:44;:::i;:::-;4926:3;4915:15;;4908:69;-1:-1:-1;4919:5:1;3851:1156;-1:-1:-1;;;;;3851:1156:1:o;5012:250::-;5097:1;5107:113;5121:6;5118:1;5115:13;5107:113;;;5197:11;;;5191:18;5178:11;;;5171:39;5143:2;5136:10;5107:113;;;-1:-1:-1;;5254:1:1;5236:16;;5229:27;5012:250::o;5267:329::-;5308:3;5346:5;5340:12;5373:6;5368:3;5361:19;5389:76;5458:6;5451:4;5446:3;5442:14;5435:4;5428:5;5424:16;5389:76;:::i;:::-;5510:2;5498:15;-1:-1:-1;;5494:88:1;5485:98;;;;5585:4;5481:109;;5267:329;-1:-1:-1;;5267:329:1:o;5601:217::-;5748:2;5737:9;5730:21;5711:4;5768:44;5808:2;5797:9;5793:18;5785:6;5768:44;:::i;5823:180::-;5882:6;5935:2;5923:9;5914:7;5910:23;5906:32;5903:52;;;5951:1;5948;5941:12;5903:52;-1:-1:-1;5974:23:1;;5823:180;-1:-1:-1;5823:180:1:o;6190:477::-;6269:6;6277;6285;6338:2;6326:9;6317:7;6313:23;6309:32;6306:52;;;6354:1;6351;6344:12;6306:52;6390:9;6377:23;6367:33;;6451:2;6440:9;6436:18;6423:32;6478:18;6470:6;6467:30;6464:50;;;6510:1;6507;6500:12;6464:50;6549:58;6599:7;6590:6;6579:9;6575:22;6549:58;:::i;:::-;6190:477;;6626:8;;-1:-1:-1;6523:84:1;;-1:-1:-1;;;;6190:477:1:o;6857:1463::-;7010:6;7018;7026;7034;7042;7050;7058;7066;7074;7127:3;7115:9;7106:7;7102:23;7098:33;7095:53;;;7144:1;7141;7134:12;7095:53;7180:9;7167:23;7157:33;;7237:2;7226:9;7222:18;7209:32;7199:42;;7291:2;7280:9;7276:18;7263:32;7304:31;7329:5;7304:31;:::i;:::-;7354:5;-1:-1:-1;7410:2:1;7395:18;;7382:32;7433:18;7463:14;;;7460:34;;;7490:1;7487;7480:12;7460:34;7528:6;7517:9;7513:22;7503:32;;7573:7;7566:4;7562:2;7558:13;7554:27;7544:55;;7595:1;7592;7585:12;7544:55;7635:2;7622:16;7661:2;7653:6;7650:14;7647:34;;;7677:1;7674;7667:12;7647:34;7730:7;7725:2;7715:6;7712:1;7708:14;7704:2;7700:23;7696:32;7693:45;7690:65;;;7751:1;7748;7741:12;7690:65;7782:2;7778;7774:11;7764:21;;7804:6;7794:16;;;7863:3;7852:9;7848:19;7835:33;7819:49;;7893:2;7883:8;7880:16;7877:36;;;7909:1;7906;7899:12;7877:36;7948:60;8000:7;7989:8;7978:9;7974:24;7948:60;:::i;:::-;8027:8;;-1:-1:-1;7922:86:1;-1:-1:-1;8115:3:1;8100:19;;8087:33;;-1:-1:-1;8132:16:1;;;8129:36;;;8161:1;8158;8151:12;8129:36;;8200:60;8252:7;8241:8;8230:9;8226:24;8200:60;:::i;:::-;8174:86;;8279:8;8269:18;;;8306:8;8296:18;;;6857:1463;;;;;;;;;;;:::o;8325:344::-;8410:6;8463:2;8451:9;8442:7;8438:23;8434:32;8431:52;;;8479:1;8476;8469:12;8431:52;8505:22;;:::i;:::-;8563:9;8550:23;8543:5;8536:38;8634:2;8623:9;8619:18;8606:32;8601:2;8594:5;8590:14;8583:56;8658:5;8648:15;;;8325:344;;;;:::o;8674:248::-;8742:6;8750;8803:2;8791:9;8782:7;8778:23;8774:32;8771:52;;;8819:1;8816;8809:12;8771:52;-1:-1:-1;;8842:23:1;;;8912:2;8897:18;;;8884:32;;-1:-1:-1;8674:248:1:o;8927:1023::-;9132:2;9121:9;9114:21;9177:6;9171:13;9166:2;9155:9;9151:18;9144:41;9239:2;9231:6;9227:15;9221:22;9216:2;9205:9;9201:18;9194:50;9298:2;9290:6;9286:15;9280:22;9275:2;9264:9;9260:18;9253:50;9358:2;9350:6;9346:15;9340:22;9334:3;9323:9;9319:19;9312:51;9429:18;9422:3;9414:6;9410:16;9404:23;9400:48;9394:3;9383:9;9379:19;9372:77;9504:3;9496:6;9492:16;9486:23;9480:3;9469:9;9465:19;9458:52;9095:4;9557:3;9549:6;9545:16;9539:23;9581:6;9624:2;9618:3;9607:9;9603:19;9596:31;9650:51;9696:3;9685:9;9681:19;9667:12;9650:51;:::i;:::-;9636:65;;9750:3;9742:6;9738:16;9732:23;-1:-1:-1;;9807:9:1;9799:6;9795:22;9791:95;9786:2;9775:9;9771:18;9764:123;9904:40;9937:6;9921:14;9904:40;:::i;:::-;9896:48;8927:1023;-1:-1:-1;;;;;;8927:1023:1:o;10566:455::-;10795:6;10784:9;10777:25;10838:6;10833:2;10822:9;10818:18;10811:34;10893:18;10885:6;10881:31;10876:2;10865:9;10861:18;10854:59;10949:3;10944:2;10933:9;10929:18;10922:31;10758:4;10970:45;11010:3;10999:9;10995:19;10987:6;10970:45;:::i;11350:545::-;11450:6;11445:3;11438:19;11420:3;11476:4;11505:2;11500:3;11496:12;11489:19;;11531:5;11554:1;11564:306;11578:6;11575:1;11572:13;11564:306;;;11655:6;11642:20;11675:33;11700:7;11675:33;:::i;:::-;11746:42;11733:56;11721:69;;11810:12;;;;11845:15;;;;11600:1;11593:9;11564:306;;;-1:-1:-1;11886:3:1;;11350:545;-1:-1:-1;;;;;11350:545:1:o;11900:359::-;12117:6;12106:9;12099:25;12160:2;12155;12144:9;12140:18;12133:30;12080:4;12180:73;12249:2;12238:9;12234:18;12226:6;12218;12180:73;:::i;:::-;12172:81;11900:359;-1:-1:-1;;;;;11900:359:1:o;12264:184::-;12334:6;12387:2;12375:9;12366:7;12362:23;12358:32;12355:52;;;12403:1;12400;12393:12;12355:52;-1:-1:-1;12426:16:1;;12264:184;-1:-1:-1;12264:184:1:o;12453:::-;12505:77;12502:1;12495:88;12602:4;12599:1;12592:15;12626:4;12623:1;12616:15;12642:128;12709:9;;;12730:11;;;12727:37;;;12744:18;;:::i;12775:430::-;13020:6;13009:9;13002:25;13063:6;13058:2;13047:9;13043:18;13036:34;13106:2;13101;13090:9;13086:18;13079:30;12983:4;13126:73;13195:2;13184:9;13180:18;13172:6;13164;13126:73;:::i;13210:184::-;13262:77;13259:1;13252:88;13359:4;13356:1;13349:15;13383:4;13380:1;13373:15;13399:325;13487:6;13482:3;13475:19;13539:6;13532:5;13525:4;13520:3;13516:14;13503:43;;13591:1;13584:4;13575:6;13570:3;13566:16;13562:27;13555:38;13457:3;13713:4;-1:-1:-1;;13638:2:1;13630:6;13626:15;13622:88;13617:3;13613:98;13609:109;13602:116;;13399:325;;;;:::o;13729:531::-;13998:6;13987:9;13980:25;14041:6;14036:2;14025:9;14021:18;14014:34;14084:6;14079:2;14068:9;14064:18;14057:34;14127:6;14122:2;14111:9;14107:18;14100:34;14171:3;14165;14154:9;14150:19;14143:32;13961:4;14192:62;14249:3;14238:9;14234:19;14226:6;14218;14192:62;:::i;:::-;14184:70;13729:531;-1:-1:-1;;;;;;;;13729:531:1:o;14518:791::-;14871:6;14860:9;14853:25;14914:6;14909:2;14898:9;14894:18;14887:34;14957:6;14952:2;14941:9;14937:18;14930:34;15000:6;14995:2;14984:9;14980:18;14973:34;15044:6;15038:3;15027:9;15023:19;15016:35;15088:3;15082;15071:9;15067:19;15060:32;14834:4;15115:62;15172:3;15161:9;15157:19;15149:6;15141;15115:62;:::i;:::-;15226:9;15218:6;15214:22;15208:3;15197:9;15193:19;15186:51;15254:49;15296:6;15288;15280;15254:49;:::i;:::-;15246:57;14518:791;-1:-1:-1;;;;;;;;;;;;14518:791:1:o;15314:209::-;15352:3;15380:18;15433:2;15426:5;15422:14;15460:2;15451:7;15448:15;15445:41;;15466:18;;:::i;:::-;15515:1;15502:15;;15314:209;-1:-1:-1;;;15314:209:1:o;15528:136::-;15606:13;;15628:30;15606:13;15628:30;:::i;15669:441::-;15722:5;15775:3;15768:4;15760:6;15756:17;15752:27;15742:55;;15793:1;15790;15783:12;15742:55;15822:6;15816:13;15853:48;15869:31;15897:2;15869:31;:::i;15853:48::-;15926:2;15917:7;15910:19;15972:3;15965:4;15960:2;15952:6;15948:15;15944:26;15941:35;15938:55;;;15989:1;15986;15979:12;15938:55;16002:77;16076:2;16069:4;16060:7;16056:18;16049:4;16041:6;16037:17;16002:77;:::i;16115:1144::-;16223:6;16276:2;16264:9;16255:7;16251:23;16247:32;16244:52;;;16292:1;16289;16282:12;16244:52;16325:9;16319:16;16354:18;16395:2;16387:6;16384:14;16381:34;;;16411:1;16408;16401:12;16381:34;16434:22;;;;16490:6;16472:16;;;16468:29;16465:49;;;16510:1;16507;16500:12;16465:49;16536:22;;:::i;:::-;16587:2;16581:9;16574:5;16567:24;16637:2;16633;16629:11;16623:18;16618:2;16611:5;16607:14;16600:42;16688:2;16684;16680:11;16674:18;16669:2;16662:5;16658:14;16651:42;16739:2;16735;16731:11;16725:18;16720:2;16713:5;16709:14;16702:42;16777;16814:3;16810:2;16806:12;16777:42;:::i;:::-;16771:3;16764:5;16760:15;16753:67;16867:3;16863:2;16859:12;16853:19;16847:3;16840:5;16836:15;16829:44;16912:3;16908:2;16904:12;16898:19;16942:2;16932:8;16929:16;16926:36;;;16958:1;16955;16948:12;16926:36;16995:55;17042:7;17031:8;17027:2;17023:17;16995:55;:::i;:::-;16989:3;16982:5;16978:15;16971:80;;17090:3;17086:2;17082:12;17076:19;17120:2;17110:8;17107:16;17104:36;;;17136:1;17133;17126:12;17104:36;17173:55;17220:7;17209:8;17205:2;17201:17;17173:55;:::i;18227:281::-;18294:5;18342:4;18330:9;18325:3;18321:19;18317:30;18314:50;;;18360:1;18357;18350:12;18314:50;18382:22;;:::i;:::-;18373:31;;18433:9;18427:16;18420:5;18413:31;18497:2;18486:9;18482:18;18476:25;18471:2;18464:5;18460:14;18453:49;18227:281;;;;:::o;18513:252::-;18609:6;18662:2;18650:9;18641:7;18637:23;18633:32;18630:52;;;18678:1;18675;18668:12;18630:52;18701:58;18751:7;18740:9;18701:58;:::i;19074:1213::-;19187:6;19195;19248:2;19236:9;19227:7;19223:23;19219:32;19216:52;;;19264:1;19261;19254:12;19216:52;19297:9;19291:16;19326:18;19367:2;19359:6;19356:14;19353:34;;;19383:1;19380;19373:12;19353:34;19406:60;19458:7;19449:6;19438:9;19434:22;19406:60;:::i;:::-;19396:70;;19485:2;19475:12;;19533:2;19522:9;19518:18;19512:25;19562:2;19552:8;19549:16;19546:36;;;19578:1;19575;19568:12;19546:36;19601:24;;19656:4;19648:13;;19644:27;-1:-1:-1;19634:55:1;;19685:1;19682;19675:12;19634:55;19714:2;19708:9;19736:2;19732;19729:10;19726:36;;;19742:18;;:::i;:::-;19788:2;19785:1;19781:10;19771:20;;19811:28;19835:2;19831;19827:11;19811:28;:::i;:::-;19873:15;;;19943:11;;;19939:20;;;19904:12;;;;19971:19;;;19968:39;;;20003:1;20000;19993:12;19968:39;20027:11;;;;20047:210;20063:6;20058:3;20055:15;20047:210;;;20136:3;20130:10;20117:23;;20153:31;20178:5;20153:31;:::i;:::-;20197:18;;;20080:12;;;;20235;;;;20047:210;;;20276:5;20266:15;;;;;;;;19074:1213;;;;;:::o;20292:184::-;20344:77;20341:1;20334:88;20441:4;20438:1;20431:15;20465:4;20462:1;20455:15;21033:195;21072:3;21103:66;21096:5;21093:77;21090:103;;21173:18;;:::i;:::-;-1:-1:-1;21220:1:1;21209:13;;21033:195::o;21233:125::-;21298:9;;;21319:10;;;21316:36;;;21332:18;;:::i;21363:485::-;21449:6;21457;21510:2;21498:9;21489:7;21485:23;21481:32;21478:52;;;21526:1;21523;21516:12;21478:52;21558:9;21552:16;21608:4;21601:5;21597:16;21590:5;21587:27;21577:55;;21628:1;21625;21618:12;21577:55;21700:2;21685:18;;21679:25;21651:5;;-1:-1:-1;21727:18:1;21716:30;;21713:50;;;21759:1;21756;21749:12;21713:50;21782:60;21834:7;21825:6;21814:9;21810:22;21782:60;:::i;:::-;21772:70;;;21363:485;;;;;:::o;21853:295::-;22036:4;22028:6;22024:17;22013:9;22006:36;22078:2;22073;22062:9;22058:18;22051:30;21987:4;22098:44;22138:2;22127:9;22123:18;22115:6;22098:44;:::i","abiDefinition":[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[{"internalType":"uint8","name":"version","type":"uint8"}],"name":"AppConfigLib__IncorrectVersion","type":"error"},{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"expected","type":"uint256"}],"name":"InterchainClientV1__IncorrectMsgValue","type":"error"},{"inputs":[{"internalType":"uint8","name":"version","type":"uint8"}],"name":"OptionsLib__IncorrectVersion","type":"error"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"uint256","name":"dbNonce","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"srcChainId","type":"uint256"},{"indexed":false,"internalType":"bytes32","name":"srcSender","type":"bytes32"},{"indexed":false,"internalType":"bytes32","name":"dstReceiver","type":"bytes32"}],"name":"InterchainTransactionReceived","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"uint256","name":"dbNonce","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"dstChainId","type":"uint256"},{"indexed":false,"internalType":"bytes32","name":"srcSender","type":"bytes32"},{"indexed":false,"internalType":"bytes32","name":"dstReceiver","type":"bytes32"},{"indexed":false,"internalType":"uint256","name":"verificationFee","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"executionFee","type":"uint256"},{"indexed":false,"internalType":"bytes","name":"options","type":"bytes"},{"indexed":false,"internalType":"bytes","name":"message","type":"bytes"}],"name":"InterchainTransactionSent","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[],"name":"clientNonce","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"uint256","name":"gasAirdrop","type":"uint256"}],"internalType":"struct OptionsV1","name":"options","type":"tuple"}],"name":"encodeOptionsV1","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"srcSender","type":"bytes32"},{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"bytes32","name":"dstReceiver","type":"bytes32"},{"internalType":"uint64","name":"nonce","type":"uint64"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes","name":"options","type":"bytes"},{"internalType":"bytes","name":"message","type":"bytes"}],"internalType":"struct InterchainTransaction","name":"icTx","type":"tuple"}],"name":"encodeTransaction","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"name":"executedTransactions","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"executionFees","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"interchainDB","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"bytes","name":"transaction","type":"bytes"}],"name":"interchainExecute","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"bytes32","name":"receiver","type":"bytes32"},{"internalType":"address","name":"srcExecutionService","type":"address"},{"internalType":"address[]","name":"srcModules","type":"address[]"},{"internalType":"bytes","name":"options","type":"bytes"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"interchainSend","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes","name":"encodedTx","type":"bytes"}],"name":"isExecutable","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"linkedClients","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"executionFees_","type":"address"}],"name":"setExecutionFees","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_interchainDB","type":"address"}],"name":"setInterchainDB","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"bytes32","name":"client","type":"bytes32"}],"name":"setLinkedClient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"interchainExecute(uint256,bytes)":{"notice":"Executes a transaction that has been sent via the Interchain."},"interchainSend(uint256,bytes32,address,address[],bytes,bytes)":{"notice":"Sends a message to another chain via the Interchain Communication Protocol."},"setExecutionFees(address)":{"notice":"Sets the address of the ExecutionFees contract."},"setInterchainDB(address)":{"notice":"Sets the address of the InterchainDB contract."},"setLinkedClient(uint256,bytes32)":{"notice":"Sets the linked client for a specific chain ID."}},"version":1},"developerDoc":{"details":"Implements the operations of the Interchain Execution Layer.","errors":{"OwnableInvalidOwner(address)":[{"details":"The owner is not a valid owner account. (eg. `address(0)`)"}],"OwnableUnauthorizedAccount(address)":[{"details":"The caller account is not authorized to perform an operation."}]},"kind":"dev","methods":{"interchainExecute(uint256,bytes)":{"details":"The transaction must have been previously sent and recorded. Transaction data includes the requested gas limit, but the executors could specify a different gas limit. If the specified gas limit is lower than requested, the requested gas limit will be used. Otherwise, the specified gas limit will be used. This allows to execute the transactions with requested gas limit set too low.","params":{"gasLimit":"The gas limit to use for the execution.","transaction":"The transaction data."}},"interchainSend(uint256,bytes32,address,address[],bytes,bytes)":{"details":"Charges a fee for the message, which is payable upon calling this function: - Verification fees: paid to every module that verifies the message. - Execution fee: paid to the executor that executes the message. Note: while a specific execution service is specified to request the execution of the message, any executor is able to execute the message on destination chain, earning the execution fee.","params":{"dstChainId":"The chain ID of the destination chain.","message":"The message being sent.","options":"Execution options for the message sent, encoded as bytes, currently primarily gas limit + native gas drop.","receiver":"The address of the receiver on the destination chain.","srcExecutionService":"The address of the execution service to use for the message.","srcModules":"The source modules involved in the message sending."}},"owner()":{"details":"Returns the address of the current owner."},"renounceOwnership()":{"details":"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."},"setExecutionFees(address)":{"details":"Only callable by the contract owner or an authorized account.","params":{"executionFees_":"The address of the ExecutionFees contract."}},"setInterchainDB(address)":{"details":"Only callable by the contract owner or an authorized account.","params":{"_interchainDB":"The address of the InterchainDB contract."}},"setLinkedClient(uint256,bytes32)":{"details":"Stores the address of the linked client in a mapping with the chain ID as the key.","params":{"chainId":"The chain ID for which the client is being set.","client":"The address of the client being linked."}},"transferOwnership(address)":{"details":"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}},"title":"InterchainClientV1","version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"AppConfigLib__IncorrectVersion\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"}],\"name\":\"InterchainClientV1__IncorrectMsgValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"OptionsLib__IncorrectVersion\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"srcSender\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dstReceiver\",\"type\":\"bytes32\"}],\"name\":\"InterchainTransactionReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"srcSender\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dstReceiver\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"verificationFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"executionFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"InterchainTransactionSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"clientNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasAirdrop\",\"type\":\"uint256\"}],\"internalType\":\"struct OptionsV1\",\"name\":\"options\",\"type\":\"tuple\"}],\"name\":\"encodeOptionsV1\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcSender\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dstReceiver\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"internalType\":\"struct InterchainTransaction\",\"name\":\"icTx\",\"type\":\"tuple\"}],\"name\":\"encodeTransaction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"executedTransactions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"executionFees\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interchainDB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"transaction\",\"type\":\"bytes\"}],\"name\":\"interchainExecute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"receiver\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"srcExecutionService\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"interchainSend\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedTx\",\"type\":\"bytes\"}],\"name\":\"isExecutable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"linkedClients\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"executionFees_\",\"type\":\"address\"}],\"name\":\"setExecutionFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_interchainDB\",\"type\":\"address\"}],\"name\":\"setInterchainDB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"client\",\"type\":\"bytes32\"}],\"name\":\"setLinkedClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Implements the operations of the Interchain Execution Layer.\",\"errors\":{\"OwnableInvalidOwner(address)\":[{\"details\":\"The owner is not a valid owner account. (eg. `address(0)`)\"}],\"OwnableUnauthorizedAccount(address)\":[{\"details\":\"The caller account is not authorized to perform an operation.\"}]},\"kind\":\"dev\",\"methods\":{\"interchainExecute(uint256,bytes)\":{\"details\":\"The transaction must have been previously sent and recorded. Transaction data includes the requested gas limit, but the executors could specify a different gas limit. If the specified gas limit is lower than requested, the requested gas limit will be used. Otherwise, the specified gas limit will be used. This allows to execute the transactions with requested gas limit set too low.\",\"params\":{\"gasLimit\":\"The gas limit to use for the execution.\",\"transaction\":\"The transaction data.\"}},\"interchainSend(uint256,bytes32,address,address[],bytes,bytes)\":{\"details\":\"Charges a fee for the message, which is payable upon calling this function: - Verification fees: paid to every module that verifies the message. - Execution fee: paid to the executor that executes the message. Note: while a specific execution service is specified to request the execution of the message, any executor is able to execute the message on destination chain, earning the execution fee.\",\"params\":{\"dstChainId\":\"The chain ID of the destination chain.\",\"message\":\"The message being sent.\",\"options\":\"Execution options for the message sent, encoded as bytes, currently primarily gas limit + native gas drop.\",\"receiver\":\"The address of the receiver on the destination chain.\",\"srcExecutionService\":\"The address of the execution service to use for the message.\",\"srcModules\":\"The source modules involved in the message sending.\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"setExecutionFees(address)\":{\"details\":\"Only callable by the contract owner or an authorized account.\",\"params\":{\"executionFees_\":\"The address of the ExecutionFees contract.\"}},\"setInterchainDB(address)\":{\"details\":\"Only callable by the contract owner or an authorized account.\",\"params\":{\"_interchainDB\":\"The address of the InterchainDB contract.\"}},\"setLinkedClient(uint256,bytes32)\":{\"details\":\"Stores the address of the linked client in a mapping with the chain ID as the key.\",\"params\":{\"chainId\":\"The chain ID for which the client is being set.\",\"client\":\"The address of the client being linked.\"}},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"title\":\"InterchainClientV1\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"interchainExecute(uint256,bytes)\":{\"notice\":\"Executes a transaction that has been sent via the Interchain.\"},\"interchainSend(uint256,bytes32,address,address[],bytes,bytes)\":{\"notice\":\"Sends a message to another chain via the Interchain Communication Protocol.\"},\"setExecutionFees(address)\":{\"notice\":\"Sets the address of the ExecutionFees contract.\"},\"setInterchainDB(address)\":{\"notice\":\"Sets the address of the InterchainDB contract.\"},\"setLinkedClient(uint256,bytes32)\":{\"notice\":\"Sets the linked client for a specific chain ID.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"InterchainClientV1\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0xb1820886ef923c4c065c5baff37b5df87b8df1e6d6b4c15efa8656e6bf9bab55\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://d5135fd5a15dd9be50d78f48a77d63d2477f99180a88a45d658259fa89e992a9\",\"dweb:/ipfs/QmeHcqSVFPtKYu1XVd751xBixEPBV2b3rN2jMUYAMKTKqN\"]}},\"version\":1}"},"hashes":{"clientNonce()":"0d898416","encodeOptionsV1((uint256,uint256))":"d219d113","encodeTransaction((uint256,bytes32,uint256,bytes32,uint64,uint256,bytes,bytes))":"4d84cc11","executedTransactions(bytes32)":"8691d34c","executionFees()":"7341eaf9","interchainDB()":"0e785ce0","interchainExecute(uint256,bytes)":"80efe777","interchainSend(uint256,bytes32,address,address[],bytes,bytes)":"98939d28","isExecutable(bytes)":"31afa7de","linkedClients(uint256)":"7268b08f","owner()":"8da5cb5b","renounceOwnership()":"715018a6","setExecutionFees(address)":"3dc68b87","setInterchainDB(address)":"b7ce2078","setLinkedClient(uint256,bytes32)":"f34234c8","transferOwnership(address)":"f2fde38b"}},"solidity/InterchainClientV1.sol:InterchainClientV1Events":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainClientV1Events.sol\n\nabstract contract InterchainClientV1Events {\n    // TODO: figure out indexing\n\n    event InterchainTransactionSent(\n        bytes32 indexed transactionId,\n        uint256 indexed dbNonce,\n        uint256 dstChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver,\n        uint256 verificationFee,\n        uint256 executionFee,\n        bytes options,\n        bytes message\n    );\n\n    event InterchainTransactionReceived(\n        bytes32 indexed transactionId,\n        uint256 indexed dbNonce,\n        uint256 srcChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver\n    );\n}\n\n// contracts/interfaces/IExecutionFees.sol\n\ninterface IExecutionFees {\n    /// @notice Add the execution fee for a transaction. The attached value will be added to the\n    /// rewards for the executor completing the transaction.\n    /// Note: this could be used to store the execution fee for a new transaction, or to add more\n    /// funds to the execution fee of an existing transaction. Therefore this function is payable,\n    /// and does not implement any caller restrictions.\n    /// @dev Will revert if the executor is already recorded for the transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to add the execution fee to.\n    function addExecutionFee(uint256 dstChainId, bytes32 transactionId) external payable;\n\n    /// @notice Record the executor (who completed the transaction) for a transaction,\n    /// and update the accumulated rewards for the executor.\n    /// @dev Could only be called by the Recorder.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to record the executor for.\n    /// @param executor             The address of the executor who completed the transaction.\n    function recordExecutor(uint256 dstChainId, bytes32 transactionId, address executor) external;\n\n    /// @notice Allows the executor to claim their unclaimed rewards.\n    /// @dev Will revert if the executor has no unclaimed rewards.\n    function claimExecutionFees() external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the accumulated rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function getAccumulatedRewards(address executor) external view returns (uint256 accumulated);\n\n    /// @notice Get the unclaimed rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function getUnclaimedRewards(address executor) external view returns (uint256 unclaimed);\n}\n\n// contracts/interfaces/IExecutionService.sol\n\ninterface IExecutionService {\n    /// @notice Request the execution of an Interchain Transaction on a remote chain.\n    /// Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient\n    /// event with the same transactionId, then execute the transaction on the remote chain:\n    /// `dstInterchainClient.executeTransaction(transactionPayload)`\n    /// Once the execution is confirmed on the source chain, the off-chain actor will be able\n    /// to claim `executionFee` in the ExecutionFees contract.\n    /// @dev Could only be called by `InterchainClient` contracts.\n    /// Will revert if the execution fee is not big enough.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param transactionId        The id of the transaction to execute.\n    /// @param executionFee         The fee paid for the execution.\n    /// @param options              The options to use for the execution.\n    function requestExecution(\n        uint256 dstChainId,\n        uint256 txPayloadSize,\n        bytes32 transactionId,\n        uint256 executionFee,\n        bytes memory options\n    )\n        external;\n\n    /// @notice Get the execution fee for executing an Interchain Transaction on a remote chain.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param options              The options to use for the execution.\n    function getExecutionFee(\n        uint256 dstChainId,\n        uint256 txPayloadSize,\n        bytes memory options\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\ninterface IInterchainApp {\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory sendingModules,\n        address[] memory receivingModules,\n        uint256 requiredResponses,\n        uint64 optimisticTimePeriod\n    )\n        external;\n\n    function getLinkedIApp(uint64 chainID) external view returns (address);\n\n    function getSendingModules() external view returns (address[] memory);\n\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable;\n\n    function appReceive(uint256 srcChainId, bytes32 sender, uint64 nonce, bytes calldata message) external payable;\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 expected);\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sets the address of the InterchainDB contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param _interchainDB The address of the InterchainDB contract.\n     */\n    function setInterchainDB(address _interchainDB) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently primarily gas limit + native gas drop.\n     * @param message The message being sent.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     */\n    function interchainExecute(uint256 gasLimit, bytes calldata transaction) external payable;\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction The InterchainTransaction struct to be checked.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction) external view returns (bool);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    uint8 constant OPTIONS_V1 = 1;\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the entry on the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint64 nonce;\n    uint256 dbNonce;\n    bytes options;\n    bytes message;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint64 nonce,\n        uint256 dbNonce,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            nonce: nonce,\n            dbNonce: dbNonce,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the local Interchain DataBase.\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    struct LocalEntry {\n        address writer;\n        bytes32 dataHash;\n    }\n\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param entryValue   The value of the entry: writer + dataHash hashed together\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 entryValue;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingEntryValue, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(uint256 dbNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the written entry on this chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(uint256 destChainId, uint256 dbNonce, address[] memory srcModules) external payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`\n    /// by providing the returned `dbNonce`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param dbNonce      The database nonce of the written entry on this chain\n    function getEntry(uint256 dbNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the database.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, InterchainClientV1Events, IInterchainClientV1 {\n    using AppConfigLib for bytes;\n    using OptionsLib for bytes;\n\n    uint64 public clientNonce;\n    address public interchainDB;\n    address public executionFees;\n    mapping(bytes32 =\u003e bool) public executedTransactions;\n\n    // Chain ID =\u003e Bytes32 Address of src clients\n    mapping(uint256 =\u003e bytes32) public linkedClients;\n\n    constructor() Ownable(msg.sender) {}\n\n    // @inheritdoc IInterchainClientV1\n    function setExecutionFees(address executionFees_) public onlyOwner {\n        executionFees = executionFees_;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setInterchainDB(address _interchainDB) public onlyOwner {\n        interchainDB = _interchainDB;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint256 chainId, bytes32 client) public onlyOwner {\n        linkedClients[chainId] = client;\n    }\n\n    // TODO: Calculate Gas Pricing per module and charge fees\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        public\n        payable\n    {\n        // TODO: should check options for being correctly formatted\n        uint256 verificationFee = IInterchainDB(interchainDB).getInterchainFee(dstChainId, srcModules);\n        // TODO: should check msg.value \u003e= verificationFee\n        uint256 executionFee = msg.value - verificationFee;\n\n        InterchainTransaction memory icTx = InterchainTransactionLib.constructLocalTransaction({\n            srcSender: msg.sender,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            nonce: clientNonce,\n            dbNonce: IInterchainDB(interchainDB).getDBNonce(),\n            options: options,\n            message: message\n        });\n\n        bytes32 transactionId = icTx.transactionId();\n        // Sanity check: nonce returned from DB should match the nonce used to construct the transaction\n        assert(\n            icTx.dbNonce\n                == IInterchainDB(interchainDB).writeEntryWithVerification{value: verificationFee}(\n                    icTx.dstChainId, transactionId, srcModules\n                )\n        );\n        if (srcExecutionService != address(0)) {\n            IExecutionService(srcExecutionService).requestExecution({\n                dstChainId: dstChainId,\n                // TODO: there should be a way to calculate the payload size without encoding the transaction\n                txPayloadSize: abi.encode(icTx).length,\n                transactionId: transactionId,\n                executionFee: executionFee,\n                options: options\n            });\n        }\n        IExecutionFees(executionFees).addExecutionFee{value: executionFee}(icTx.dstChainId, transactionId);\n        emit InterchainTransactionSent(\n            transactionId,\n            icTx.dbNonce,\n            icTx.dstChainId,\n            icTx.srcSender,\n            icTx.dstReceiver,\n            verificationFee,\n            executionFee,\n            options,\n            message\n        );\n        // Increment nonce for next message\n        clientNonce++;\n    }\n\n    // TODO: App Config Versioning\n    // TODO: What if receiver is not a contract / doesn't conform to interface?\n    /**\n     * @dev Retrieves the application configuration for a given receiver application.\n     * @param receiverApp The address of the receiver application.\n     * @return requiredResponses The number of required responses from the receiving modules.\n     * @return optimisticTimePeriod The time period within which responses are considered valid.\n     * @return approvedDstModules An array of addresses of the approved destination modules.\n     */\n    function _getAppConfig(address receiverApp)\n        internal\n        view\n        returns (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules)\n    {\n        bytes memory appConfig;\n        (appConfig, approvedDstModules) = IInterchainApp(receiverApp).getReceivingConfig();\n        AppConfigV1 memory decodedAppConfig = appConfig.decodeAppConfigV1();\n        requiredResponses = decodedAppConfig.requiredResponses;\n        optimisticTimePeriod = decodedAppConfig.optimisticPeriod;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata encodedTx) public view returns (bool) {\n        InterchainTransaction memory icTx = InterchainTransactionLib.decodeTransaction(encodedTx);\n        bytes32 transactionId = icTx.transactionId();\n        return _isExecutable(transactionId, icTx);\n    }\n\n    function _isExecutable(bytes32 transactionId, InterchainTransaction memory icTx) internal view returns (bool) {\n        require(executedTransactions[transactionId] == false, \"Transaction already executed\");\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            dbNonce: icTx.dbNonce,\n            srcWriter: linkedClients[icTx.srcChainId],\n            dataHash: transactionId\n        });\n\n        (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules) =\n            _getAppConfig(TypeCasts.bytes32ToAddress(icTx.dstReceiver));\n\n        uint256[] memory approvedResponses = _getApprovedResponses(approvedDstModules, icEntry);\n\n        uint256 finalizedResponses = _getFinalizedResponsesCount(approvedResponses, optimisticTimePeriod);\n        require(finalizedResponses \u003e= requiredResponses, \"Not enough valid responses to meet the threshold\");\n        return true;\n    }\n\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedResponses An array of timestamps when each approved response was recorded.\n     * @param optimisticTimePeriod The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses The count of responses that are finalized within the optimistic time period.\n     */\n    function _getFinalizedResponsesCount(\n        uint256[] memory approvedResponses,\n        uint256 optimisticTimePeriod\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 finalizedResponses = 0;\n        for (uint256 i = 0; i \u003c approvedResponses.length; i++) {\n            if (approvedResponses[i] + optimisticTimePeriod \u003c= block.timestamp) {\n                finalizedResponses++;\n            }\n        }\n        return finalizedResponses;\n    }\n    /**\n     * @dev Retrieves the responses from approved modules for a given InterchainEntry.\n     * This function iterates over all approved modules, querying the InterchainDB for each module's response\n     * to the provided InterchainEntry. It compiles these responses into an array of uint256, where each\n     * element represents the timestamp of a module's response.\n     *\n     * @param approvedModules An array of addresses representing the approved modules that can write responses.\n     * @param icEntry The InterchainEntry for which responses are being retrieved.\n     * @return approvedResponses An array of uint256 representing the timestamps of responses from approved modules.\n     */\n\n    function _getApprovedResponses(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry\n    )\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory approvedResponses = new uint256[](approvedModules.length);\n        for (uint256 i = 0; i \u003c approvedModules.length; i++) {\n            approvedResponses[i] = IInterchainDB(interchainDB).readEntry(approvedModules[i], icEntry);\n        }\n        return approvedResponses;\n    }\n\n    function encodeTransaction(InterchainTransaction memory icTx) public view returns (bytes memory) {\n        return abi.encode(icTx);\n    }\n\n    function encodeOptionsV1(OptionsV1 memory options) public view returns (bytes memory) {\n        return options.encodeOptionsV1();\n    }\n\n    // TODO: Gas Fee Consideration that is paid to executor\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(uint256 gasLimit, bytes calldata transaction) external payable {\n        InterchainTransaction memory icTx = InterchainTransactionLib.decodeTransaction(transaction);\n        bytes32 transactionId = icTx.transactionId();\n        require(_isExecutable(transactionId, icTx), \"Transaction is not executable\");\n        executedTransactions[transactionId] = true;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n        if (msg.value != decodedOptions.gasAirdrop) {\n            revert InterchainClientV1__IncorrectMsgValue(msg.value, decodedOptions.gasAirdrop);\n        }\n        // We should always use at least as much as the requested gas limit.\n        // The executor can specify a higher gas limit if they wanted.\n        if (decodedOptions.gasLimit \u003e gasLimit) gasLimit = decodedOptions.gasLimit;\n        // Pass the full msg.value to the app: we have already checked that it matches the requested gas airdrop.\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: gasLimit, value: msg.value}({\n            srcChainId: icTx.srcChainId,\n            sender: icTx.srcSender,\n            nonce: icTx.nonce,\n            message: icTx.message\n        });\n        emit InterchainTransactionReceived(\n            transactionId, icTx.dbNonce, icTx.srcChainId, icTx.srcSender, icTx.dstReceiver\n        );\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"uint256","name":"dbNonce","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"srcChainId","type":"uint256"},{"indexed":false,"internalType":"bytes32","name":"srcSender","type":"bytes32"},{"indexed":false,"internalType":"bytes32","name":"dstReceiver","type":"bytes32"}],"name":"InterchainTransactionReceived","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"uint256","name":"dbNonce","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"dstChainId","type":"uint256"},{"indexed":false,"internalType":"bytes32","name":"srcSender","type":"bytes32"},{"indexed":false,"internalType":"bytes32","name":"dstReceiver","type":"bytes32"},{"indexed":false,"internalType":"uint256","name":"verificationFee","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"executionFee","type":"uint256"},{"indexed":false,"internalType":"bytes","name":"options","type":"bytes"},{"indexed":false,"internalType":"bytes","name":"message","type":"bytes"}],"name":"InterchainTransactionSent","type":"event"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"srcSender\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dstReceiver\",\"type\":\"bytes32\"}],\"name\":\"InterchainTransactionReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"srcSender\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dstReceiver\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"verificationFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"executionFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"InterchainTransactionSent\",\"type\":\"event\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"InterchainClientV1Events\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0xb1820886ef923c4c065c5baff37b5df87b8df1e6d6b4c15efa8656e6bf9bab55\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://d5135fd5a15dd9be50d78f48a77d63d2477f99180a88a45d658259fa89e992a9\",\"dweb:/ipfs/QmeHcqSVFPtKYu1XVd751xBixEPBV2b3rN2jMUYAMKTKqN\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainClientV1.sol:InterchainEntryLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220dcc1f3e07d541e52279a29a04d884c203966460c3cbb9e9cf190ef28dd88971764736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220dcc1f3e07d541e52279a29a04d884c203966460c3cbb9e9cf190ef28dd88971764736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainClientV1Events.sol\n\nabstract contract InterchainClientV1Events {\n    // TODO: figure out indexing\n\n    event InterchainTransactionSent(\n        bytes32 indexed transactionId,\n        uint256 indexed dbNonce,\n        uint256 dstChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver,\n        uint256 verificationFee,\n        uint256 executionFee,\n        bytes options,\n        bytes message\n    );\n\n    event InterchainTransactionReceived(\n        bytes32 indexed transactionId,\n        uint256 indexed dbNonce,\n        uint256 srcChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver\n    );\n}\n\n// contracts/interfaces/IExecutionFees.sol\n\ninterface IExecutionFees {\n    /// @notice Add the execution fee for a transaction. The attached value will be added to the\n    /// rewards for the executor completing the transaction.\n    /// Note: this could be used to store the execution fee for a new transaction, or to add more\n    /// funds to the execution fee of an existing transaction. Therefore this function is payable,\n    /// and does not implement any caller restrictions.\n    /// @dev Will revert if the executor is already recorded for the transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to add the execution fee to.\n    function addExecutionFee(uint256 dstChainId, bytes32 transactionId) external payable;\n\n    /// @notice Record the executor (who completed the transaction) for a transaction,\n    /// and update the accumulated rewards for the executor.\n    /// @dev Could only be called by the Recorder.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to record the executor for.\n    /// @param executor             The address of the executor who completed the transaction.\n    function recordExecutor(uint256 dstChainId, bytes32 transactionId, address executor) external;\n\n    /// @notice Allows the executor to claim their unclaimed rewards.\n    /// @dev Will revert if the executor has no unclaimed rewards.\n    function claimExecutionFees() external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the accumulated rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function getAccumulatedRewards(address executor) external view returns (uint256 accumulated);\n\n    /// @notice Get the unclaimed rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function getUnclaimedRewards(address executor) external view returns (uint256 unclaimed);\n}\n\n// contracts/interfaces/IExecutionService.sol\n\ninterface IExecutionService {\n    /// @notice Request the execution of an Interchain Transaction on a remote chain.\n    /// Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient\n    /// event with the same transactionId, then execute the transaction on the remote chain:\n    /// `dstInterchainClient.executeTransaction(transactionPayload)`\n    /// Once the execution is confirmed on the source chain, the off-chain actor will be able\n    /// to claim `executionFee` in the ExecutionFees contract.\n    /// @dev Could only be called by `InterchainClient` contracts.\n    /// Will revert if the execution fee is not big enough.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param transactionId        The id of the transaction to execute.\n    /// @param executionFee         The fee paid for the execution.\n    /// @param options              The options to use for the execution.\n    function requestExecution(\n        uint256 dstChainId,\n        uint256 txPayloadSize,\n        bytes32 transactionId,\n        uint256 executionFee,\n        bytes memory options\n    )\n        external;\n\n    /// @notice Get the execution fee for executing an Interchain Transaction on a remote chain.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param options              The options to use for the execution.\n    function getExecutionFee(\n        uint256 dstChainId,\n        uint256 txPayloadSize,\n        bytes memory options\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\ninterface IInterchainApp {\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory sendingModules,\n        address[] memory receivingModules,\n        uint256 requiredResponses,\n        uint64 optimisticTimePeriod\n    )\n        external;\n\n    function getLinkedIApp(uint64 chainID) external view returns (address);\n\n    function getSendingModules() external view returns (address[] memory);\n\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable;\n\n    function appReceive(uint256 srcChainId, bytes32 sender, uint64 nonce, bytes calldata message) external payable;\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 expected);\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sets the address of the InterchainDB contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param _interchainDB The address of the InterchainDB contract.\n     */\n    function setInterchainDB(address _interchainDB) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently primarily gas limit + native gas drop.\n     * @param message The message being sent.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     */\n    function interchainExecute(uint256 gasLimit, bytes calldata transaction) external payable;\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction The InterchainTransaction struct to be checked.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction) external view returns (bool);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    uint8 constant OPTIONS_V1 = 1;\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the entry on the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint64 nonce;\n    uint256 dbNonce;\n    bytes options;\n    bytes message;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint64 nonce,\n        uint256 dbNonce,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            nonce: nonce,\n            dbNonce: dbNonce,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the local Interchain DataBase.\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    struct LocalEntry {\n        address writer;\n        bytes32 dataHash;\n    }\n\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param entryValue   The value of the entry: writer + dataHash hashed together\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 entryValue;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingEntryValue, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(uint256 dbNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the written entry on this chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(uint256 destChainId, uint256 dbNonce, address[] memory srcModules) external payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`\n    /// by providing the returned `dbNonce`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param dbNonce      The database nonce of the written entry on this chain\n    function getEntry(uint256 dbNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the database.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, InterchainClientV1Events, IInterchainClientV1 {\n    using AppConfigLib for bytes;\n    using OptionsLib for bytes;\n\n    uint64 public clientNonce;\n    address public interchainDB;\n    address public executionFees;\n    mapping(bytes32 =\u003e bool) public executedTransactions;\n\n    // Chain ID =\u003e Bytes32 Address of src clients\n    mapping(uint256 =\u003e bytes32) public linkedClients;\n\n    constructor() Ownable(msg.sender) {}\n\n    // @inheritdoc IInterchainClientV1\n    function setExecutionFees(address executionFees_) public onlyOwner {\n        executionFees = executionFees_;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setInterchainDB(address _interchainDB) public onlyOwner {\n        interchainDB = _interchainDB;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint256 chainId, bytes32 client) public onlyOwner {\n        linkedClients[chainId] = client;\n    }\n\n    // TODO: Calculate Gas Pricing per module and charge fees\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        public\n        payable\n    {\n        // TODO: should check options for being correctly formatted\n        uint256 verificationFee = IInterchainDB(interchainDB).getInterchainFee(dstChainId, srcModules);\n        // TODO: should check msg.value \u003e= verificationFee\n        uint256 executionFee = msg.value - verificationFee;\n\n        InterchainTransaction memory icTx = InterchainTransactionLib.constructLocalTransaction({\n            srcSender: msg.sender,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            nonce: clientNonce,\n            dbNonce: IInterchainDB(interchainDB).getDBNonce(),\n            options: options,\n            message: message\n        });\n\n        bytes32 transactionId = icTx.transactionId();\n        // Sanity check: nonce returned from DB should match the nonce used to construct the transaction\n        assert(\n            icTx.dbNonce\n                == IInterchainDB(interchainDB).writeEntryWithVerification{value: verificationFee}(\n                    icTx.dstChainId, transactionId, srcModules\n                )\n        );\n        if (srcExecutionService != address(0)) {\n            IExecutionService(srcExecutionService).requestExecution({\n                dstChainId: dstChainId,\n                // TODO: there should be a way to calculate the payload size without encoding the transaction\n                txPayloadSize: abi.encode(icTx).length,\n                transactionId: transactionId,\n                executionFee: executionFee,\n                options: options\n            });\n        }\n        IExecutionFees(executionFees).addExecutionFee{value: executionFee}(icTx.dstChainId, transactionId);\n        emit InterchainTransactionSent(\n            transactionId,\n            icTx.dbNonce,\n            icTx.dstChainId,\n            icTx.srcSender,\n            icTx.dstReceiver,\n            verificationFee,\n            executionFee,\n            options,\n            message\n        );\n        // Increment nonce for next message\n        clientNonce++;\n    }\n\n    // TODO: App Config Versioning\n    // TODO: What if receiver is not a contract / doesn't conform to interface?\n    /**\n     * @dev Retrieves the application configuration for a given receiver application.\n     * @param receiverApp The address of the receiver application.\n     * @return requiredResponses The number of required responses from the receiving modules.\n     * @return optimisticTimePeriod The time period within which responses are considered valid.\n     * @return approvedDstModules An array of addresses of the approved destination modules.\n     */\n    function _getAppConfig(address receiverApp)\n        internal\n        view\n        returns (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules)\n    {\n        bytes memory appConfig;\n        (appConfig, approvedDstModules) = IInterchainApp(receiverApp).getReceivingConfig();\n        AppConfigV1 memory decodedAppConfig = appConfig.decodeAppConfigV1();\n        requiredResponses = decodedAppConfig.requiredResponses;\n        optimisticTimePeriod = decodedAppConfig.optimisticPeriod;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata encodedTx) public view returns (bool) {\n        InterchainTransaction memory icTx = InterchainTransactionLib.decodeTransaction(encodedTx);\n        bytes32 transactionId = icTx.transactionId();\n        return _isExecutable(transactionId, icTx);\n    }\n\n    function _isExecutable(bytes32 transactionId, InterchainTransaction memory icTx) internal view returns (bool) {\n        require(executedTransactions[transactionId] == false, \"Transaction already executed\");\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            dbNonce: icTx.dbNonce,\n            srcWriter: linkedClients[icTx.srcChainId],\n            dataHash: transactionId\n        });\n\n        (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules) =\n            _getAppConfig(TypeCasts.bytes32ToAddress(icTx.dstReceiver));\n\n        uint256[] memory approvedResponses = _getApprovedResponses(approvedDstModules, icEntry);\n\n        uint256 finalizedResponses = _getFinalizedResponsesCount(approvedResponses, optimisticTimePeriod);\n        require(finalizedResponses \u003e= requiredResponses, \"Not enough valid responses to meet the threshold\");\n        return true;\n    }\n\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedResponses An array of timestamps when each approved response was recorded.\n     * @param optimisticTimePeriod The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses The count of responses that are finalized within the optimistic time period.\n     */\n    function _getFinalizedResponsesCount(\n        uint256[] memory approvedResponses,\n        uint256 optimisticTimePeriod\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 finalizedResponses = 0;\n        for (uint256 i = 0; i \u003c approvedResponses.length; i++) {\n            if (approvedResponses[i] + optimisticTimePeriod \u003c= block.timestamp) {\n                finalizedResponses++;\n            }\n        }\n        return finalizedResponses;\n    }\n    /**\n     * @dev Retrieves the responses from approved modules for a given InterchainEntry.\n     * This function iterates over all approved modules, querying the InterchainDB for each module's response\n     * to the provided InterchainEntry. It compiles these responses into an array of uint256, where each\n     * element represents the timestamp of a module's response.\n     *\n     * @param approvedModules An array of addresses representing the approved modules that can write responses.\n     * @param icEntry The InterchainEntry for which responses are being retrieved.\n     * @return approvedResponses An array of uint256 representing the timestamps of responses from approved modules.\n     */\n\n    function _getApprovedResponses(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry\n    )\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory approvedResponses = new uint256[](approvedModules.length);\n        for (uint256 i = 0; i \u003c approvedModules.length; i++) {\n            approvedResponses[i] = IInterchainDB(interchainDB).readEntry(approvedModules[i], icEntry);\n        }\n        return approvedResponses;\n    }\n\n    function encodeTransaction(InterchainTransaction memory icTx) public view returns (bytes memory) {\n        return abi.encode(icTx);\n    }\n\n    function encodeOptionsV1(OptionsV1 memory options) public view returns (bytes memory) {\n        return options.encodeOptionsV1();\n    }\n\n    // TODO: Gas Fee Consideration that is paid to executor\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(uint256 gasLimit, bytes calldata transaction) external payable {\n        InterchainTransaction memory icTx = InterchainTransactionLib.decodeTransaction(transaction);\n        bytes32 transactionId = icTx.transactionId();\n        require(_isExecutable(transactionId, icTx), \"Transaction is not executable\");\n        executedTransactions[transactionId] = true;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n        if (msg.value != decodedOptions.gasAirdrop) {\n            revert InterchainClientV1__IncorrectMsgValue(msg.value, decodedOptions.gasAirdrop);\n        }\n        // We should always use at least as much as the requested gas limit.\n        // The executor can specify a higher gas limit if they wanted.\n        if (decodedOptions.gasLimit \u003e gasLimit) gasLimit = decodedOptions.gasLimit;\n        // Pass the full msg.value to the app: we have already checked that it matches the requested gas airdrop.\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: gasLimit, value: msg.value}({\n            srcChainId: icTx.srcChainId,\n            sender: icTx.srcSender,\n            nonce: icTx.nonce,\n            message: icTx.message\n        });\n        emit InterchainTransactionReceived(\n            transactionId, icTx.dbNonce, icTx.srcChainId, icTx.srcSender, icTx.dstReceiver\n        );\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"16131:1299:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;16131:1299:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"16131:1299:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"InterchainEntryLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0xb1820886ef923c4c065c5baff37b5df87b8df1e6d6b4c15efa8656e6bf9bab55\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://d5135fd5a15dd9be50d78f48a77d63d2477f99180a88a45d658259fa89e992a9\",\"dweb:/ipfs/QmeHcqSVFPtKYu1XVd751xBixEPBV2b3rN2jMUYAMKTKqN\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainClientV1.sol:InterchainTransactionLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220f1a7aa55d864a4ef3105d5486af668e30a83e462bda0a2e6c89b4c06b0db1e0c64736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220f1a7aa55d864a4ef3105d5486af668e30a83e462bda0a2e6c89b4c06b0db1e0c64736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainClientV1Events.sol\n\nabstract contract InterchainClientV1Events {\n    // TODO: figure out indexing\n\n    event InterchainTransactionSent(\n        bytes32 indexed transactionId,\n        uint256 indexed dbNonce,\n        uint256 dstChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver,\n        uint256 verificationFee,\n        uint256 executionFee,\n        bytes options,\n        bytes message\n    );\n\n    event InterchainTransactionReceived(\n        bytes32 indexed transactionId,\n        uint256 indexed dbNonce,\n        uint256 srcChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver\n    );\n}\n\n// contracts/interfaces/IExecutionFees.sol\n\ninterface IExecutionFees {\n    /// @notice Add the execution fee for a transaction. The attached value will be added to the\n    /// rewards for the executor completing the transaction.\n    /// Note: this could be used to store the execution fee for a new transaction, or to add more\n    /// funds to the execution fee of an existing transaction. Therefore this function is payable,\n    /// and does not implement any caller restrictions.\n    /// @dev Will revert if the executor is already recorded for the transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to add the execution fee to.\n    function addExecutionFee(uint256 dstChainId, bytes32 transactionId) external payable;\n\n    /// @notice Record the executor (who completed the transaction) for a transaction,\n    /// and update the accumulated rewards for the executor.\n    /// @dev Could only be called by the Recorder.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to record the executor for.\n    /// @param executor             The address of the executor who completed the transaction.\n    function recordExecutor(uint256 dstChainId, bytes32 transactionId, address executor) external;\n\n    /// @notice Allows the executor to claim their unclaimed rewards.\n    /// @dev Will revert if the executor has no unclaimed rewards.\n    function claimExecutionFees() external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the accumulated rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function getAccumulatedRewards(address executor) external view returns (uint256 accumulated);\n\n    /// @notice Get the unclaimed rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function getUnclaimedRewards(address executor) external view returns (uint256 unclaimed);\n}\n\n// contracts/interfaces/IExecutionService.sol\n\ninterface IExecutionService {\n    /// @notice Request the execution of an Interchain Transaction on a remote chain.\n    /// Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient\n    /// event with the same transactionId, then execute the transaction on the remote chain:\n    /// `dstInterchainClient.executeTransaction(transactionPayload)`\n    /// Once the execution is confirmed on the source chain, the off-chain actor will be able\n    /// to claim `executionFee` in the ExecutionFees contract.\n    /// @dev Could only be called by `InterchainClient` contracts.\n    /// Will revert if the execution fee is not big enough.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param transactionId        The id of the transaction to execute.\n    /// @param executionFee         The fee paid for the execution.\n    /// @param options              The options to use for the execution.\n    function requestExecution(\n        uint256 dstChainId,\n        uint256 txPayloadSize,\n        bytes32 transactionId,\n        uint256 executionFee,\n        bytes memory options\n    )\n        external;\n\n    /// @notice Get the execution fee for executing an Interchain Transaction on a remote chain.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param options              The options to use for the execution.\n    function getExecutionFee(\n        uint256 dstChainId,\n        uint256 txPayloadSize,\n        bytes memory options\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\ninterface IInterchainApp {\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory sendingModules,\n        address[] memory receivingModules,\n        uint256 requiredResponses,\n        uint64 optimisticTimePeriod\n    )\n        external;\n\n    function getLinkedIApp(uint64 chainID) external view returns (address);\n\n    function getSendingModules() external view returns (address[] memory);\n\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable;\n\n    function appReceive(uint256 srcChainId, bytes32 sender, uint64 nonce, bytes calldata message) external payable;\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 expected);\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sets the address of the InterchainDB contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param _interchainDB The address of the InterchainDB contract.\n     */\n    function setInterchainDB(address _interchainDB) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently primarily gas limit + native gas drop.\n     * @param message The message being sent.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     */\n    function interchainExecute(uint256 gasLimit, bytes calldata transaction) external payable;\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction The InterchainTransaction struct to be checked.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction) external view returns (bool);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    uint8 constant OPTIONS_V1 = 1;\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the entry on the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint64 nonce;\n    uint256 dbNonce;\n    bytes options;\n    bytes message;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint64 nonce,\n        uint256 dbNonce,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            nonce: nonce,\n            dbNonce: dbNonce,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the local Interchain DataBase.\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    struct LocalEntry {\n        address writer;\n        bytes32 dataHash;\n    }\n\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param entryValue   The value of the entry: writer + dataHash hashed together\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 entryValue;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingEntryValue, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(uint256 dbNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the written entry on this chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(uint256 destChainId, uint256 dbNonce, address[] memory srcModules) external payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`\n    /// by providing the returned `dbNonce`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param dbNonce      The database nonce of the written entry on this chain\n    function getEntry(uint256 dbNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the database.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, InterchainClientV1Events, IInterchainClientV1 {\n    using AppConfigLib for bytes;\n    using OptionsLib for bytes;\n\n    uint64 public clientNonce;\n    address public interchainDB;\n    address public executionFees;\n    mapping(bytes32 =\u003e bool) public executedTransactions;\n\n    // Chain ID =\u003e Bytes32 Address of src clients\n    mapping(uint256 =\u003e bytes32) public linkedClients;\n\n    constructor() Ownable(msg.sender) {}\n\n    // @inheritdoc IInterchainClientV1\n    function setExecutionFees(address executionFees_) public onlyOwner {\n        executionFees = executionFees_;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setInterchainDB(address _interchainDB) public onlyOwner {\n        interchainDB = _interchainDB;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint256 chainId, bytes32 client) public onlyOwner {\n        linkedClients[chainId] = client;\n    }\n\n    // TODO: Calculate Gas Pricing per module and charge fees\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        public\n        payable\n    {\n        // TODO: should check options for being correctly formatted\n        uint256 verificationFee = IInterchainDB(interchainDB).getInterchainFee(dstChainId, srcModules);\n        // TODO: should check msg.value \u003e= verificationFee\n        uint256 executionFee = msg.value - verificationFee;\n\n        InterchainTransaction memory icTx = InterchainTransactionLib.constructLocalTransaction({\n            srcSender: msg.sender,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            nonce: clientNonce,\n            dbNonce: IInterchainDB(interchainDB).getDBNonce(),\n            options: options,\n            message: message\n        });\n\n        bytes32 transactionId = icTx.transactionId();\n        // Sanity check: nonce returned from DB should match the nonce used to construct the transaction\n        assert(\n            icTx.dbNonce\n                == IInterchainDB(interchainDB).writeEntryWithVerification{value: verificationFee}(\n                    icTx.dstChainId, transactionId, srcModules\n                )\n        );\n        if (srcExecutionService != address(0)) {\n            IExecutionService(srcExecutionService).requestExecution({\n                dstChainId: dstChainId,\n                // TODO: there should be a way to calculate the payload size without encoding the transaction\n                txPayloadSize: abi.encode(icTx).length,\n                transactionId: transactionId,\n                executionFee: executionFee,\n                options: options\n            });\n        }\n        IExecutionFees(executionFees).addExecutionFee{value: executionFee}(icTx.dstChainId, transactionId);\n        emit InterchainTransactionSent(\n            transactionId,\n            icTx.dbNonce,\n            icTx.dstChainId,\n            icTx.srcSender,\n            icTx.dstReceiver,\n            verificationFee,\n            executionFee,\n            options,\n            message\n        );\n        // Increment nonce for next message\n        clientNonce++;\n    }\n\n    // TODO: App Config Versioning\n    // TODO: What if receiver is not a contract / doesn't conform to interface?\n    /**\n     * @dev Retrieves the application configuration for a given receiver application.\n     * @param receiverApp The address of the receiver application.\n     * @return requiredResponses The number of required responses from the receiving modules.\n     * @return optimisticTimePeriod The time period within which responses are considered valid.\n     * @return approvedDstModules An array of addresses of the approved destination modules.\n     */\n    function _getAppConfig(address receiverApp)\n        internal\n        view\n        returns (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules)\n    {\n        bytes memory appConfig;\n        (appConfig, approvedDstModules) = IInterchainApp(receiverApp).getReceivingConfig();\n        AppConfigV1 memory decodedAppConfig = appConfig.decodeAppConfigV1();\n        requiredResponses = decodedAppConfig.requiredResponses;\n        optimisticTimePeriod = decodedAppConfig.optimisticPeriod;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata encodedTx) public view returns (bool) {\n        InterchainTransaction memory icTx = InterchainTransactionLib.decodeTransaction(encodedTx);\n        bytes32 transactionId = icTx.transactionId();\n        return _isExecutable(transactionId, icTx);\n    }\n\n    function _isExecutable(bytes32 transactionId, InterchainTransaction memory icTx) internal view returns (bool) {\n        require(executedTransactions[transactionId] == false, \"Transaction already executed\");\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            dbNonce: icTx.dbNonce,\n            srcWriter: linkedClients[icTx.srcChainId],\n            dataHash: transactionId\n        });\n\n        (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules) =\n            _getAppConfig(TypeCasts.bytes32ToAddress(icTx.dstReceiver));\n\n        uint256[] memory approvedResponses = _getApprovedResponses(approvedDstModules, icEntry);\n\n        uint256 finalizedResponses = _getFinalizedResponsesCount(approvedResponses, optimisticTimePeriod);\n        require(finalizedResponses \u003e= requiredResponses, \"Not enough valid responses to meet the threshold\");\n        return true;\n    }\n\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedResponses An array of timestamps when each approved response was recorded.\n     * @param optimisticTimePeriod The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses The count of responses that are finalized within the optimistic time period.\n     */\n    function _getFinalizedResponsesCount(\n        uint256[] memory approvedResponses,\n        uint256 optimisticTimePeriod\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 finalizedResponses = 0;\n        for (uint256 i = 0; i \u003c approvedResponses.length; i++) {\n            if (approvedResponses[i] + optimisticTimePeriod \u003c= block.timestamp) {\n                finalizedResponses++;\n            }\n        }\n        return finalizedResponses;\n    }\n    /**\n     * @dev Retrieves the responses from approved modules for a given InterchainEntry.\n     * This function iterates over all approved modules, querying the InterchainDB for each module's response\n     * to the provided InterchainEntry. It compiles these responses into an array of uint256, where each\n     * element represents the timestamp of a module's response.\n     *\n     * @param approvedModules An array of addresses representing the approved modules that can write responses.\n     * @param icEntry The InterchainEntry for which responses are being retrieved.\n     * @return approvedResponses An array of uint256 representing the timestamps of responses from approved modules.\n     */\n\n    function _getApprovedResponses(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry\n    )\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory approvedResponses = new uint256[](approvedModules.length);\n        for (uint256 i = 0; i \u003c approvedModules.length; i++) {\n            approvedResponses[i] = IInterchainDB(interchainDB).readEntry(approvedModules[i], icEntry);\n        }\n        return approvedResponses;\n    }\n\n    function encodeTransaction(InterchainTransaction memory icTx) public view returns (bytes memory) {\n        return abi.encode(icTx);\n    }\n\n    function encodeOptionsV1(OptionsV1 memory options) public view returns (bytes memory) {\n        return options.encodeOptionsV1();\n    }\n\n    // TODO: Gas Fee Consideration that is paid to executor\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(uint256 gasLimit, bytes calldata transaction) external payable {\n        InterchainTransaction memory icTx = InterchainTransactionLib.decodeTransaction(transaction);\n        bytes32 transactionId = icTx.transactionId();\n        require(_isExecutable(transactionId, icTx), \"Transaction is not executable\");\n        executedTransactions[transactionId] = true;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n        if (msg.value != decodedOptions.gasAirdrop) {\n            revert InterchainClientV1__IncorrectMsgValue(msg.value, decodedOptions.gasAirdrop);\n        }\n        // We should always use at least as much as the requested gas limit.\n        // The executor can specify a higher gas limit if they wanted.\n        if (decodedOptions.gasLimit \u003e gasLimit) gasLimit = decodedOptions.gasLimit;\n        // Pass the full msg.value to the app: we have already checked that it matches the requested gas airdrop.\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: gasLimit, value: msg.value}({\n            srcChainId: icTx.srcChainId,\n            sender: icTx.srcSender,\n            nonce: icTx.nonce,\n            message: icTx.message\n        });\n        emit InterchainTransactionReceived(\n            transactionId, icTx.dbNonce, icTx.srcChainId, icTx.srcSender, icTx.dstReceiver\n        );\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"17750:1214:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;17750:1214:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"17750:1214:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"InterchainTransactionLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0xb1820886ef923c4c065c5baff37b5df87b8df1e6d6b4c15efa8656e6bf9bab55\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://d5135fd5a15dd9be50d78f48a77d63d2477f99180a88a45d658259fa89e992a9\",\"dweb:/ipfs/QmeHcqSVFPtKYu1XVd751xBixEPBV2b3rN2jMUYAMKTKqN\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainClientV1.sol:OptionsLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220321e9e966d0fc78a732944e0be238aa47b5be2afecb5e0dae2e5f8005a97cb6164736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220321e9e966d0fc78a732944e0be238aa47b5be2afecb5e0dae2e5f8005a97cb6164736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainClientV1Events.sol\n\nabstract contract InterchainClientV1Events {\n    // TODO: figure out indexing\n\n    event InterchainTransactionSent(\n        bytes32 indexed transactionId,\n        uint256 indexed dbNonce,\n        uint256 dstChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver,\n        uint256 verificationFee,\n        uint256 executionFee,\n        bytes options,\n        bytes message\n    );\n\n    event InterchainTransactionReceived(\n        bytes32 indexed transactionId,\n        uint256 indexed dbNonce,\n        uint256 srcChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver\n    );\n}\n\n// contracts/interfaces/IExecutionFees.sol\n\ninterface IExecutionFees {\n    /// @notice Add the execution fee for a transaction. The attached value will be added to the\n    /// rewards for the executor completing the transaction.\n    /// Note: this could be used to store the execution fee for a new transaction, or to add more\n    /// funds to the execution fee of an existing transaction. Therefore this function is payable,\n    /// and does not implement any caller restrictions.\n    /// @dev Will revert if the executor is already recorded for the transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to add the execution fee to.\n    function addExecutionFee(uint256 dstChainId, bytes32 transactionId) external payable;\n\n    /// @notice Record the executor (who completed the transaction) for a transaction,\n    /// and update the accumulated rewards for the executor.\n    /// @dev Could only be called by the Recorder.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to record the executor for.\n    /// @param executor             The address of the executor who completed the transaction.\n    function recordExecutor(uint256 dstChainId, bytes32 transactionId, address executor) external;\n\n    /// @notice Allows the executor to claim their unclaimed rewards.\n    /// @dev Will revert if the executor has no unclaimed rewards.\n    function claimExecutionFees() external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the accumulated rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function getAccumulatedRewards(address executor) external view returns (uint256 accumulated);\n\n    /// @notice Get the unclaimed rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function getUnclaimedRewards(address executor) external view returns (uint256 unclaimed);\n}\n\n// contracts/interfaces/IExecutionService.sol\n\ninterface IExecutionService {\n    /// @notice Request the execution of an Interchain Transaction on a remote chain.\n    /// Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient\n    /// event with the same transactionId, then execute the transaction on the remote chain:\n    /// `dstInterchainClient.executeTransaction(transactionPayload)`\n    /// Once the execution is confirmed on the source chain, the off-chain actor will be able\n    /// to claim `executionFee` in the ExecutionFees contract.\n    /// @dev Could only be called by `InterchainClient` contracts.\n    /// Will revert if the execution fee is not big enough.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param transactionId        The id of the transaction to execute.\n    /// @param executionFee         The fee paid for the execution.\n    /// @param options              The options to use for the execution.\n    function requestExecution(\n        uint256 dstChainId,\n        uint256 txPayloadSize,\n        bytes32 transactionId,\n        uint256 executionFee,\n        bytes memory options\n    )\n        external;\n\n    /// @notice Get the execution fee for executing an Interchain Transaction on a remote chain.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param options              The options to use for the execution.\n    function getExecutionFee(\n        uint256 dstChainId,\n        uint256 txPayloadSize,\n        bytes memory options\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\ninterface IInterchainApp {\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory sendingModules,\n        address[] memory receivingModules,\n        uint256 requiredResponses,\n        uint64 optimisticTimePeriod\n    )\n        external;\n\n    function getLinkedIApp(uint64 chainID) external view returns (address);\n\n    function getSendingModules() external view returns (address[] memory);\n\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable;\n\n    function appReceive(uint256 srcChainId, bytes32 sender, uint64 nonce, bytes calldata message) external payable;\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 expected);\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sets the address of the InterchainDB contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param _interchainDB The address of the InterchainDB contract.\n     */\n    function setInterchainDB(address _interchainDB) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently primarily gas limit + native gas drop.\n     * @param message The message being sent.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     */\n    function interchainExecute(uint256 gasLimit, bytes calldata transaction) external payable;\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction The InterchainTransaction struct to be checked.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction) external view returns (bool);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    uint8 constant OPTIONS_V1 = 1;\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the entry on the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint64 nonce;\n    uint256 dbNonce;\n    bytes options;\n    bytes message;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint64 nonce,\n        uint256 dbNonce,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            nonce: nonce,\n            dbNonce: dbNonce,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the local Interchain DataBase.\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    struct LocalEntry {\n        address writer;\n        bytes32 dataHash;\n    }\n\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param entryValue   The value of the entry: writer + dataHash hashed together\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 entryValue;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingEntryValue, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(uint256 dbNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the written entry on this chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(uint256 destChainId, uint256 dbNonce, address[] memory srcModules) external payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`\n    /// by providing the returned `dbNonce`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param dbNonce      The database nonce of the written entry on this chain\n    function getEntry(uint256 dbNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the database.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, InterchainClientV1Events, IInterchainClientV1 {\n    using AppConfigLib for bytes;\n    using OptionsLib for bytes;\n\n    uint64 public clientNonce;\n    address public interchainDB;\n    address public executionFees;\n    mapping(bytes32 =\u003e bool) public executedTransactions;\n\n    // Chain ID =\u003e Bytes32 Address of src clients\n    mapping(uint256 =\u003e bytes32) public linkedClients;\n\n    constructor() Ownable(msg.sender) {}\n\n    // @inheritdoc IInterchainClientV1\n    function setExecutionFees(address executionFees_) public onlyOwner {\n        executionFees = executionFees_;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setInterchainDB(address _interchainDB) public onlyOwner {\n        interchainDB = _interchainDB;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint256 chainId, bytes32 client) public onlyOwner {\n        linkedClients[chainId] = client;\n    }\n\n    // TODO: Calculate Gas Pricing per module and charge fees\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        public\n        payable\n    {\n        // TODO: should check options for being correctly formatted\n        uint256 verificationFee = IInterchainDB(interchainDB).getInterchainFee(dstChainId, srcModules);\n        // TODO: should check msg.value \u003e= verificationFee\n        uint256 executionFee = msg.value - verificationFee;\n\n        InterchainTransaction memory icTx = InterchainTransactionLib.constructLocalTransaction({\n            srcSender: msg.sender,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            nonce: clientNonce,\n            dbNonce: IInterchainDB(interchainDB).getDBNonce(),\n            options: options,\n            message: message\n        });\n\n        bytes32 transactionId = icTx.transactionId();\n        // Sanity check: nonce returned from DB should match the nonce used to construct the transaction\n        assert(\n            icTx.dbNonce\n                == IInterchainDB(interchainDB).writeEntryWithVerification{value: verificationFee}(\n                    icTx.dstChainId, transactionId, srcModules\n                )\n        );\n        if (srcExecutionService != address(0)) {\n            IExecutionService(srcExecutionService).requestExecution({\n                dstChainId: dstChainId,\n                // TODO: there should be a way to calculate the payload size without encoding the transaction\n                txPayloadSize: abi.encode(icTx).length,\n                transactionId: transactionId,\n                executionFee: executionFee,\n                options: options\n            });\n        }\n        IExecutionFees(executionFees).addExecutionFee{value: executionFee}(icTx.dstChainId, transactionId);\n        emit InterchainTransactionSent(\n            transactionId,\n            icTx.dbNonce,\n            icTx.dstChainId,\n            icTx.srcSender,\n            icTx.dstReceiver,\n            verificationFee,\n            executionFee,\n            options,\n            message\n        );\n        // Increment nonce for next message\n        clientNonce++;\n    }\n\n    // TODO: App Config Versioning\n    // TODO: What if receiver is not a contract / doesn't conform to interface?\n    /**\n     * @dev Retrieves the application configuration for a given receiver application.\n     * @param receiverApp The address of the receiver application.\n     * @return requiredResponses The number of required responses from the receiving modules.\n     * @return optimisticTimePeriod The time period within which responses are considered valid.\n     * @return approvedDstModules An array of addresses of the approved destination modules.\n     */\n    function _getAppConfig(address receiverApp)\n        internal\n        view\n        returns (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules)\n    {\n        bytes memory appConfig;\n        (appConfig, approvedDstModules) = IInterchainApp(receiverApp).getReceivingConfig();\n        AppConfigV1 memory decodedAppConfig = appConfig.decodeAppConfigV1();\n        requiredResponses = decodedAppConfig.requiredResponses;\n        optimisticTimePeriod = decodedAppConfig.optimisticPeriod;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata encodedTx) public view returns (bool) {\n        InterchainTransaction memory icTx = InterchainTransactionLib.decodeTransaction(encodedTx);\n        bytes32 transactionId = icTx.transactionId();\n        return _isExecutable(transactionId, icTx);\n    }\n\n    function _isExecutable(bytes32 transactionId, InterchainTransaction memory icTx) internal view returns (bool) {\n        require(executedTransactions[transactionId] == false, \"Transaction already executed\");\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            dbNonce: icTx.dbNonce,\n            srcWriter: linkedClients[icTx.srcChainId],\n            dataHash: transactionId\n        });\n\n        (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules) =\n            _getAppConfig(TypeCasts.bytes32ToAddress(icTx.dstReceiver));\n\n        uint256[] memory approvedResponses = _getApprovedResponses(approvedDstModules, icEntry);\n\n        uint256 finalizedResponses = _getFinalizedResponsesCount(approvedResponses, optimisticTimePeriod);\n        require(finalizedResponses \u003e= requiredResponses, \"Not enough valid responses to meet the threshold\");\n        return true;\n    }\n\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedResponses An array of timestamps when each approved response was recorded.\n     * @param optimisticTimePeriod The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses The count of responses that are finalized within the optimistic time period.\n     */\n    function _getFinalizedResponsesCount(\n        uint256[] memory approvedResponses,\n        uint256 optimisticTimePeriod\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 finalizedResponses = 0;\n        for (uint256 i = 0; i \u003c approvedResponses.length; i++) {\n            if (approvedResponses[i] + optimisticTimePeriod \u003c= block.timestamp) {\n                finalizedResponses++;\n            }\n        }\n        return finalizedResponses;\n    }\n    /**\n     * @dev Retrieves the responses from approved modules for a given InterchainEntry.\n     * This function iterates over all approved modules, querying the InterchainDB for each module's response\n     * to the provided InterchainEntry. It compiles these responses into an array of uint256, where each\n     * element represents the timestamp of a module's response.\n     *\n     * @param approvedModules An array of addresses representing the approved modules that can write responses.\n     * @param icEntry The InterchainEntry for which responses are being retrieved.\n     * @return approvedResponses An array of uint256 representing the timestamps of responses from approved modules.\n     */\n\n    function _getApprovedResponses(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry\n    )\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory approvedResponses = new uint256[](approvedModules.length);\n        for (uint256 i = 0; i \u003c approvedModules.length; i++) {\n            approvedResponses[i] = IInterchainDB(interchainDB).readEntry(approvedModules[i], icEntry);\n        }\n        return approvedResponses;\n    }\n\n    function encodeTransaction(InterchainTransaction memory icTx) public view returns (bytes memory) {\n        return abi.encode(icTx);\n    }\n\n    function encodeOptionsV1(OptionsV1 memory options) public view returns (bytes memory) {\n        return options.encodeOptionsV1();\n    }\n\n    // TODO: Gas Fee Consideration that is paid to executor\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(uint256 gasLimit, bytes calldata transaction) external payable {\n        InterchainTransaction memory icTx = InterchainTransactionLib.decodeTransaction(transaction);\n        bytes32 transactionId = icTx.transactionId();\n        require(_isExecutable(transactionId, icTx), \"Transaction is not executable\");\n        executedTransactions[transactionId] = true;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n        if (msg.value != decodedOptions.gasAirdrop) {\n            revert InterchainClientV1__IncorrectMsgValue(msg.value, decodedOptions.gasAirdrop);\n        }\n        // We should always use at least as much as the requested gas limit.\n        // The executor can specify a higher gas limit if they wanted.\n        if (decodedOptions.gasLimit \u003e gasLimit) gasLimit = decodedOptions.gasLimit;\n        // Pass the full msg.value to the app: we have already checked that it matches the requested gas airdrop.\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: gasLimit, value: msg.value}({\n            srcChainId: icTx.srcChainId,\n            sender: icTx.srcSender,\n            nonce: icTx.nonce,\n            message: icTx.message\n        });\n        emit InterchainTransactionReceived(\n            transactionId, icTx.dbNonce, icTx.srcChainId, icTx.srcSender, icTx.dstReceiver\n        );\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"12261:1958:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;12261:1958:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"12261:1958:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[{"internalType":"uint8","name":"version","type":"uint8"}],"name":"OptionsLib__IncorrectVersion","type":"error"}],"userDoc":{"kind":"user","methods":{},"notice":"A library for encoding and decoding Interchain options related to interchain messages.","version":1},"developerDoc":{"kind":"dev","methods":{},"title":"OptionsLib","version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"OptionsLib__IncorrectVersion\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"title\":\"OptionsLib\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"A library for encoding and decoding Interchain options related to interchain messages.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"OptionsLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0xb1820886ef923c4c065c5baff37b5df87b8df1e6d6b4c15efa8656e6bf9bab55\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://d5135fd5a15dd9be50d78f48a77d63d2477f99180a88a45d658259fa89e992a9\",\"dweb:/ipfs/QmeHcqSVFPtKYu1XVd751xBixEPBV2b3rN2jMUYAMKTKqN\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainClientV1.sol:Ownable":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainClientV1Events.sol\n\nabstract contract InterchainClientV1Events {\n    // TODO: figure out indexing\n\n    event InterchainTransactionSent(\n        bytes32 indexed transactionId,\n        uint256 indexed dbNonce,\n        uint256 dstChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver,\n        uint256 verificationFee,\n        uint256 executionFee,\n        bytes options,\n        bytes message\n    );\n\n    event InterchainTransactionReceived(\n        bytes32 indexed transactionId,\n        uint256 indexed dbNonce,\n        uint256 srcChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver\n    );\n}\n\n// contracts/interfaces/IExecutionFees.sol\n\ninterface IExecutionFees {\n    /// @notice Add the execution fee for a transaction. The attached value will be added to the\n    /// rewards for the executor completing the transaction.\n    /// Note: this could be used to store the execution fee for a new transaction, or to add more\n    /// funds to the execution fee of an existing transaction. Therefore this function is payable,\n    /// and does not implement any caller restrictions.\n    /// @dev Will revert if the executor is already recorded for the transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to add the execution fee to.\n    function addExecutionFee(uint256 dstChainId, bytes32 transactionId) external payable;\n\n    /// @notice Record the executor (who completed the transaction) for a transaction,\n    /// and update the accumulated rewards for the executor.\n    /// @dev Could only be called by the Recorder.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to record the executor for.\n    /// @param executor             The address of the executor who completed the transaction.\n    function recordExecutor(uint256 dstChainId, bytes32 transactionId, address executor) external;\n\n    /// @notice Allows the executor to claim their unclaimed rewards.\n    /// @dev Will revert if the executor has no unclaimed rewards.\n    function claimExecutionFees() external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the accumulated rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function getAccumulatedRewards(address executor) external view returns (uint256 accumulated);\n\n    /// @notice Get the unclaimed rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function getUnclaimedRewards(address executor) external view returns (uint256 unclaimed);\n}\n\n// contracts/interfaces/IExecutionService.sol\n\ninterface IExecutionService {\n    /// @notice Request the execution of an Interchain Transaction on a remote chain.\n    /// Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient\n    /// event with the same transactionId, then execute the transaction on the remote chain:\n    /// `dstInterchainClient.executeTransaction(transactionPayload)`\n    /// Once the execution is confirmed on the source chain, the off-chain actor will be able\n    /// to claim `executionFee` in the ExecutionFees contract.\n    /// @dev Could only be called by `InterchainClient` contracts.\n    /// Will revert if the execution fee is not big enough.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param transactionId        The id of the transaction to execute.\n    /// @param executionFee         The fee paid for the execution.\n    /// @param options              The options to use for the execution.\n    function requestExecution(\n        uint256 dstChainId,\n        uint256 txPayloadSize,\n        bytes32 transactionId,\n        uint256 executionFee,\n        bytes memory options\n    )\n        external;\n\n    /// @notice Get the execution fee for executing an Interchain Transaction on a remote chain.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param options              The options to use for the execution.\n    function getExecutionFee(\n        uint256 dstChainId,\n        uint256 txPayloadSize,\n        bytes memory options\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\ninterface IInterchainApp {\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory sendingModules,\n        address[] memory receivingModules,\n        uint256 requiredResponses,\n        uint64 optimisticTimePeriod\n    )\n        external;\n\n    function getLinkedIApp(uint64 chainID) external view returns (address);\n\n    function getSendingModules() external view returns (address[] memory);\n\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable;\n\n    function appReceive(uint256 srcChainId, bytes32 sender, uint64 nonce, bytes calldata message) external payable;\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 expected);\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sets the address of the InterchainDB contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param _interchainDB The address of the InterchainDB contract.\n     */\n    function setInterchainDB(address _interchainDB) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently primarily gas limit + native gas drop.\n     * @param message The message being sent.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     */\n    function interchainExecute(uint256 gasLimit, bytes calldata transaction) external payable;\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction The InterchainTransaction struct to be checked.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction) external view returns (bool);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    uint8 constant OPTIONS_V1 = 1;\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the entry on the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint64 nonce;\n    uint256 dbNonce;\n    bytes options;\n    bytes message;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint64 nonce,\n        uint256 dbNonce,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            nonce: nonce,\n            dbNonce: dbNonce,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the local Interchain DataBase.\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    struct LocalEntry {\n        address writer;\n        bytes32 dataHash;\n    }\n\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param entryValue   The value of the entry: writer + dataHash hashed together\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 entryValue;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingEntryValue, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(uint256 dbNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the written entry on this chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(uint256 destChainId, uint256 dbNonce, address[] memory srcModules) external payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`\n    /// by providing the returned `dbNonce`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param dbNonce      The database nonce of the written entry on this chain\n    function getEntry(uint256 dbNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the database.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, InterchainClientV1Events, IInterchainClientV1 {\n    using AppConfigLib for bytes;\n    using OptionsLib for bytes;\n\n    uint64 public clientNonce;\n    address public interchainDB;\n    address public executionFees;\n    mapping(bytes32 =\u003e bool) public executedTransactions;\n\n    // Chain ID =\u003e Bytes32 Address of src clients\n    mapping(uint256 =\u003e bytes32) public linkedClients;\n\n    constructor() Ownable(msg.sender) {}\n\n    // @inheritdoc IInterchainClientV1\n    function setExecutionFees(address executionFees_) public onlyOwner {\n        executionFees = executionFees_;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setInterchainDB(address _interchainDB) public onlyOwner {\n        interchainDB = _interchainDB;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint256 chainId, bytes32 client) public onlyOwner {\n        linkedClients[chainId] = client;\n    }\n\n    // TODO: Calculate Gas Pricing per module and charge fees\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        public\n        payable\n    {\n        // TODO: should check options for being correctly formatted\n        uint256 verificationFee = IInterchainDB(interchainDB).getInterchainFee(dstChainId, srcModules);\n        // TODO: should check msg.value \u003e= verificationFee\n        uint256 executionFee = msg.value - verificationFee;\n\n        InterchainTransaction memory icTx = InterchainTransactionLib.constructLocalTransaction({\n            srcSender: msg.sender,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            nonce: clientNonce,\n            dbNonce: IInterchainDB(interchainDB).getDBNonce(),\n            options: options,\n            message: message\n        });\n\n        bytes32 transactionId = icTx.transactionId();\n        // Sanity check: nonce returned from DB should match the nonce used to construct the transaction\n        assert(\n            icTx.dbNonce\n                == IInterchainDB(interchainDB).writeEntryWithVerification{value: verificationFee}(\n                    icTx.dstChainId, transactionId, srcModules\n                )\n        );\n        if (srcExecutionService != address(0)) {\n            IExecutionService(srcExecutionService).requestExecution({\n                dstChainId: dstChainId,\n                // TODO: there should be a way to calculate the payload size without encoding the transaction\n                txPayloadSize: abi.encode(icTx).length,\n                transactionId: transactionId,\n                executionFee: executionFee,\n                options: options\n            });\n        }\n        IExecutionFees(executionFees).addExecutionFee{value: executionFee}(icTx.dstChainId, transactionId);\n        emit InterchainTransactionSent(\n            transactionId,\n            icTx.dbNonce,\n            icTx.dstChainId,\n            icTx.srcSender,\n            icTx.dstReceiver,\n            verificationFee,\n            executionFee,\n            options,\n            message\n        );\n        // Increment nonce for next message\n        clientNonce++;\n    }\n\n    // TODO: App Config Versioning\n    // TODO: What if receiver is not a contract / doesn't conform to interface?\n    /**\n     * @dev Retrieves the application configuration for a given receiver application.\n     * @param receiverApp The address of the receiver application.\n     * @return requiredResponses The number of required responses from the receiving modules.\n     * @return optimisticTimePeriod The time period within which responses are considered valid.\n     * @return approvedDstModules An array of addresses of the approved destination modules.\n     */\n    function _getAppConfig(address receiverApp)\n        internal\n        view\n        returns (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules)\n    {\n        bytes memory appConfig;\n        (appConfig, approvedDstModules) = IInterchainApp(receiverApp).getReceivingConfig();\n        AppConfigV1 memory decodedAppConfig = appConfig.decodeAppConfigV1();\n        requiredResponses = decodedAppConfig.requiredResponses;\n        optimisticTimePeriod = decodedAppConfig.optimisticPeriod;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata encodedTx) public view returns (bool) {\n        InterchainTransaction memory icTx = InterchainTransactionLib.decodeTransaction(encodedTx);\n        bytes32 transactionId = icTx.transactionId();\n        return _isExecutable(transactionId, icTx);\n    }\n\n    function _isExecutable(bytes32 transactionId, InterchainTransaction memory icTx) internal view returns (bool) {\n        require(executedTransactions[transactionId] == false, \"Transaction already executed\");\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            dbNonce: icTx.dbNonce,\n            srcWriter: linkedClients[icTx.srcChainId],\n            dataHash: transactionId\n        });\n\n        (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules) =\n            _getAppConfig(TypeCasts.bytes32ToAddress(icTx.dstReceiver));\n\n        uint256[] memory approvedResponses = _getApprovedResponses(approvedDstModules, icEntry);\n\n        uint256 finalizedResponses = _getFinalizedResponsesCount(approvedResponses, optimisticTimePeriod);\n        require(finalizedResponses \u003e= requiredResponses, \"Not enough valid responses to meet the threshold\");\n        return true;\n    }\n\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedResponses An array of timestamps when each approved response was recorded.\n     * @param optimisticTimePeriod The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses The count of responses that are finalized within the optimistic time period.\n     */\n    function _getFinalizedResponsesCount(\n        uint256[] memory approvedResponses,\n        uint256 optimisticTimePeriod\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 finalizedResponses = 0;\n        for (uint256 i = 0; i \u003c approvedResponses.length; i++) {\n            if (approvedResponses[i] + optimisticTimePeriod \u003c= block.timestamp) {\n                finalizedResponses++;\n            }\n        }\n        return finalizedResponses;\n    }\n    /**\n     * @dev Retrieves the responses from approved modules for a given InterchainEntry.\n     * This function iterates over all approved modules, querying the InterchainDB for each module's response\n     * to the provided InterchainEntry. It compiles these responses into an array of uint256, where each\n     * element represents the timestamp of a module's response.\n     *\n     * @param approvedModules An array of addresses representing the approved modules that can write responses.\n     * @param icEntry The InterchainEntry for which responses are being retrieved.\n     * @return approvedResponses An array of uint256 representing the timestamps of responses from approved modules.\n     */\n\n    function _getApprovedResponses(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry\n    )\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory approvedResponses = new uint256[](approvedModules.length);\n        for (uint256 i = 0; i \u003c approvedModules.length; i++) {\n            approvedResponses[i] = IInterchainDB(interchainDB).readEntry(approvedModules[i], icEntry);\n        }\n        return approvedResponses;\n    }\n\n    function encodeTransaction(InterchainTransaction memory icTx) public view returns (bytes memory) {\n        return abi.encode(icTx);\n    }\n\n    function encodeOptionsV1(OptionsV1 memory options) public view returns (bytes memory) {\n        return options.encodeOptionsV1();\n    }\n\n    // TODO: Gas Fee Consideration that is paid to executor\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(uint256 gasLimit, bytes calldata transaction) external payable {\n        InterchainTransaction memory icTx = InterchainTransactionLib.decodeTransaction(transaction);\n        bytes32 transactionId = icTx.transactionId();\n        require(_isExecutable(transactionId, icTx), \"Transaction is not executable\");\n        executedTransactions[transactionId] = true;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n        if (msg.value != decodedOptions.gasAirdrop) {\n            revert InterchainClientV1__IncorrectMsgValue(msg.value, decodedOptions.gasAirdrop);\n        }\n        // We should always use at least as much as the requested gas limit.\n        // The executor can specify a higher gas limit if they wanted.\n        if (decodedOptions.gasLimit \u003e gasLimit) gasLimit = decodedOptions.gasLimit;\n        // Pass the full msg.value to the app: we have already checked that it matches the requested gas airdrop.\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: gasLimit, value: msg.value}({\n            srcChainId: icTx.srcChainId,\n            sender: icTx.srcSender,\n            nonce: icTx.nonce,\n            message: icTx.message\n        });\n        emit InterchainTransactionReceived(\n            transactionId, icTx.dbNonce, icTx.srcChainId, icTx.srcSender, icTx.dstReceiver\n        );\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Contract module which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. The initial owner is set to the address provided by the deployer. This can later be changed with {transferOwnership}. This module is used through inheritance. It will make available the modifier `onlyOwner`, which can be applied to your functions to restrict their use to the owner.","errors":{"OwnableInvalidOwner(address)":[{"details":"The owner is not a valid owner account. (eg. `address(0)`)"}],"OwnableUnauthorizedAccount(address)":[{"details":"The caller account is not authorized to perform an operation."}]},"kind":"dev","methods":{"constructor":{"details":"Initializes the contract setting the address provided by the deployer as the initial owner."},"owner()":{"details":"Returns the address of the current owner."},"renounceOwnership()":{"details":"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."},"transferOwnership(address)":{"details":"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Contract module which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. The initial owner is set to the address provided by the deployer. This can later be changed with {transferOwnership}. This module is used through inheritance. It will make available the modifier `onlyOwner`, which can be applied to your functions to restrict their use to the owner.\",\"errors\":{\"OwnableInvalidOwner(address)\":[{\"details\":\"The owner is not a valid owner account. (eg. `address(0)`)\"}],\"OwnableUnauthorizedAccount(address)\":[{\"details\":\"The caller account is not authorized to perform an operation.\"}]},\"kind\":\"dev\",\"methods\":{\"constructor\":{\"details\":\"Initializes the contract setting the address provided by the deployer as the initial owner.\"},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"Ownable\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0xb1820886ef923c4c065c5baff37b5df87b8df1e6d6b4c15efa8656e6bf9bab55\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://d5135fd5a15dd9be50d78f48a77d63d2477f99180a88a45d658259fa89e992a9\",\"dweb:/ipfs/QmeHcqSVFPtKYu1XVd751xBixEPBV2b3rN2jMUYAMKTKqN\"]}},\"version\":1}"},"hashes":{"owner()":"8da5cb5b","renounceOwnership()":"715018a6","transferOwnership(address)":"f2fde38b"}},"solidity/InterchainClientV1.sol:TypeCasts":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122065c11ea73e90933f93a3e5ae28973ae201972bb1484865620374e4f96fe0e62164736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122065c11ea73e90933f93a3e5ae28973ae201972bb1484865620374e4f96fe0e62164736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainClientV1Events.sol\n\nabstract contract InterchainClientV1Events {\n    // TODO: figure out indexing\n\n    event InterchainTransactionSent(\n        bytes32 indexed transactionId,\n        uint256 indexed dbNonce,\n        uint256 dstChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver,\n        uint256 verificationFee,\n        uint256 executionFee,\n        bytes options,\n        bytes message\n    );\n\n    event InterchainTransactionReceived(\n        bytes32 indexed transactionId,\n        uint256 indexed dbNonce,\n        uint256 srcChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver\n    );\n}\n\n// contracts/interfaces/IExecutionFees.sol\n\ninterface IExecutionFees {\n    /// @notice Add the execution fee for a transaction. The attached value will be added to the\n    /// rewards for the executor completing the transaction.\n    /// Note: this could be used to store the execution fee for a new transaction, or to add more\n    /// funds to the execution fee of an existing transaction. Therefore this function is payable,\n    /// and does not implement any caller restrictions.\n    /// @dev Will revert if the executor is already recorded for the transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to add the execution fee to.\n    function addExecutionFee(uint256 dstChainId, bytes32 transactionId) external payable;\n\n    /// @notice Record the executor (who completed the transaction) for a transaction,\n    /// and update the accumulated rewards for the executor.\n    /// @dev Could only be called by the Recorder.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to record the executor for.\n    /// @param executor             The address of the executor who completed the transaction.\n    function recordExecutor(uint256 dstChainId, bytes32 transactionId, address executor) external;\n\n    /// @notice Allows the executor to claim their unclaimed rewards.\n    /// @dev Will revert if the executor has no unclaimed rewards.\n    function claimExecutionFees() external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the accumulated rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function getAccumulatedRewards(address executor) external view returns (uint256 accumulated);\n\n    /// @notice Get the unclaimed rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function getUnclaimedRewards(address executor) external view returns (uint256 unclaimed);\n}\n\n// contracts/interfaces/IExecutionService.sol\n\ninterface IExecutionService {\n    /// @notice Request the execution of an Interchain Transaction on a remote chain.\n    /// Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient\n    /// event with the same transactionId, then execute the transaction on the remote chain:\n    /// `dstInterchainClient.executeTransaction(transactionPayload)`\n    /// Once the execution is confirmed on the source chain, the off-chain actor will be able\n    /// to claim `executionFee` in the ExecutionFees contract.\n    /// @dev Could only be called by `InterchainClient` contracts.\n    /// Will revert if the execution fee is not big enough.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param transactionId        The id of the transaction to execute.\n    /// @param executionFee         The fee paid for the execution.\n    /// @param options              The options to use for the execution.\n    function requestExecution(\n        uint256 dstChainId,\n        uint256 txPayloadSize,\n        bytes32 transactionId,\n        uint256 executionFee,\n        bytes memory options\n    )\n        external;\n\n    /// @notice Get the execution fee for executing an Interchain Transaction on a remote chain.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param options              The options to use for the execution.\n    function getExecutionFee(\n        uint256 dstChainId,\n        uint256 txPayloadSize,\n        bytes memory options\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\ninterface IInterchainApp {\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory sendingModules,\n        address[] memory receivingModules,\n        uint256 requiredResponses,\n        uint64 optimisticTimePeriod\n    )\n        external;\n\n    function getLinkedIApp(uint64 chainID) external view returns (address);\n\n    function getSendingModules() external view returns (address[] memory);\n\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable;\n\n    function appReceive(uint256 srcChainId, bytes32 sender, uint64 nonce, bytes calldata message) external payable;\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 expected);\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sets the address of the InterchainDB contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param _interchainDB The address of the InterchainDB contract.\n     */\n    function setInterchainDB(address _interchainDB) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently primarily gas limit + native gas drop.\n     * @param message The message being sent.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     */\n    function interchainExecute(uint256 gasLimit, bytes calldata transaction) external payable;\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction The InterchainTransaction struct to be checked.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction) external view returns (bool);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    uint8 constant OPTIONS_V1 = 1;\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the entry on the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint64 nonce;\n    uint256 dbNonce;\n    bytes options;\n    bytes message;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint64 nonce,\n        uint256 dbNonce,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            nonce: nonce,\n            dbNonce: dbNonce,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the local Interchain DataBase.\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    struct LocalEntry {\n        address writer;\n        bytes32 dataHash;\n    }\n\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param entryValue   The value of the entry: writer + dataHash hashed together\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 entryValue;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingEntryValue, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(uint256 dbNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the written entry on this chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(uint256 destChainId, uint256 dbNonce, address[] memory srcModules) external payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`\n    /// by providing the returned `dbNonce`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param dbNonce      The database nonce of the written entry on this chain\n    function getEntry(uint256 dbNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the database.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, InterchainClientV1Events, IInterchainClientV1 {\n    using AppConfigLib for bytes;\n    using OptionsLib for bytes;\n\n    uint64 public clientNonce;\n    address public interchainDB;\n    address public executionFees;\n    mapping(bytes32 =\u003e bool) public executedTransactions;\n\n    // Chain ID =\u003e Bytes32 Address of src clients\n    mapping(uint256 =\u003e bytes32) public linkedClients;\n\n    constructor() Ownable(msg.sender) {}\n\n    // @inheritdoc IInterchainClientV1\n    function setExecutionFees(address executionFees_) public onlyOwner {\n        executionFees = executionFees_;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setInterchainDB(address _interchainDB) public onlyOwner {\n        interchainDB = _interchainDB;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint256 chainId, bytes32 client) public onlyOwner {\n        linkedClients[chainId] = client;\n    }\n\n    // TODO: Calculate Gas Pricing per module and charge fees\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        public\n        payable\n    {\n        // TODO: should check options for being correctly formatted\n        uint256 verificationFee = IInterchainDB(interchainDB).getInterchainFee(dstChainId, srcModules);\n        // TODO: should check msg.value \u003e= verificationFee\n        uint256 executionFee = msg.value - verificationFee;\n\n        InterchainTransaction memory icTx = InterchainTransactionLib.constructLocalTransaction({\n            srcSender: msg.sender,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            nonce: clientNonce,\n            dbNonce: IInterchainDB(interchainDB).getDBNonce(),\n            options: options,\n            message: message\n        });\n\n        bytes32 transactionId = icTx.transactionId();\n        // Sanity check: nonce returned from DB should match the nonce used to construct the transaction\n        assert(\n            icTx.dbNonce\n                == IInterchainDB(interchainDB).writeEntryWithVerification{value: verificationFee}(\n                    icTx.dstChainId, transactionId, srcModules\n                )\n        );\n        if (srcExecutionService != address(0)) {\n            IExecutionService(srcExecutionService).requestExecution({\n                dstChainId: dstChainId,\n                // TODO: there should be a way to calculate the payload size without encoding the transaction\n                txPayloadSize: abi.encode(icTx).length,\n                transactionId: transactionId,\n                executionFee: executionFee,\n                options: options\n            });\n        }\n        IExecutionFees(executionFees).addExecutionFee{value: executionFee}(icTx.dstChainId, transactionId);\n        emit InterchainTransactionSent(\n            transactionId,\n            icTx.dbNonce,\n            icTx.dstChainId,\n            icTx.srcSender,\n            icTx.dstReceiver,\n            verificationFee,\n            executionFee,\n            options,\n            message\n        );\n        // Increment nonce for next message\n        clientNonce++;\n    }\n\n    // TODO: App Config Versioning\n    // TODO: What if receiver is not a contract / doesn't conform to interface?\n    /**\n     * @dev Retrieves the application configuration for a given receiver application.\n     * @param receiverApp The address of the receiver application.\n     * @return requiredResponses The number of required responses from the receiving modules.\n     * @return optimisticTimePeriod The time period within which responses are considered valid.\n     * @return approvedDstModules An array of addresses of the approved destination modules.\n     */\n    function _getAppConfig(address receiverApp)\n        internal\n        view\n        returns (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules)\n    {\n        bytes memory appConfig;\n        (appConfig, approvedDstModules) = IInterchainApp(receiverApp).getReceivingConfig();\n        AppConfigV1 memory decodedAppConfig = appConfig.decodeAppConfigV1();\n        requiredResponses = decodedAppConfig.requiredResponses;\n        optimisticTimePeriod = decodedAppConfig.optimisticPeriod;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata encodedTx) public view returns (bool) {\n        InterchainTransaction memory icTx = InterchainTransactionLib.decodeTransaction(encodedTx);\n        bytes32 transactionId = icTx.transactionId();\n        return _isExecutable(transactionId, icTx);\n    }\n\n    function _isExecutable(bytes32 transactionId, InterchainTransaction memory icTx) internal view returns (bool) {\n        require(executedTransactions[transactionId] == false, \"Transaction already executed\");\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            dbNonce: icTx.dbNonce,\n            srcWriter: linkedClients[icTx.srcChainId],\n            dataHash: transactionId\n        });\n\n        (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules) =\n            _getAppConfig(TypeCasts.bytes32ToAddress(icTx.dstReceiver));\n\n        uint256[] memory approvedResponses = _getApprovedResponses(approvedDstModules, icEntry);\n\n        uint256 finalizedResponses = _getFinalizedResponsesCount(approvedResponses, optimisticTimePeriod);\n        require(finalizedResponses \u003e= requiredResponses, \"Not enough valid responses to meet the threshold\");\n        return true;\n    }\n\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedResponses An array of timestamps when each approved response was recorded.\n     * @param optimisticTimePeriod The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses The count of responses that are finalized within the optimistic time period.\n     */\n    function _getFinalizedResponsesCount(\n        uint256[] memory approvedResponses,\n        uint256 optimisticTimePeriod\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 finalizedResponses = 0;\n        for (uint256 i = 0; i \u003c approvedResponses.length; i++) {\n            if (approvedResponses[i] + optimisticTimePeriod \u003c= block.timestamp) {\n                finalizedResponses++;\n            }\n        }\n        return finalizedResponses;\n    }\n    /**\n     * @dev Retrieves the responses from approved modules for a given InterchainEntry.\n     * This function iterates over all approved modules, querying the InterchainDB for each module's response\n     * to the provided InterchainEntry. It compiles these responses into an array of uint256, where each\n     * element represents the timestamp of a module's response.\n     *\n     * @param approvedModules An array of addresses representing the approved modules that can write responses.\n     * @param icEntry The InterchainEntry for which responses are being retrieved.\n     * @return approvedResponses An array of uint256 representing the timestamps of responses from approved modules.\n     */\n\n    function _getApprovedResponses(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry\n    )\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory approvedResponses = new uint256[](approvedModules.length);\n        for (uint256 i = 0; i \u003c approvedModules.length; i++) {\n            approvedResponses[i] = IInterchainDB(interchainDB).readEntry(approvedModules[i], icEntry);\n        }\n        return approvedResponses;\n    }\n\n    function encodeTransaction(InterchainTransaction memory icTx) public view returns (bytes memory) {\n        return abi.encode(icTx);\n    }\n\n    function encodeOptionsV1(OptionsV1 memory options) public view returns (bytes memory) {\n        return options.encodeOptionsV1();\n    }\n\n    // TODO: Gas Fee Consideration that is paid to executor\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(uint256 gasLimit, bytes calldata transaction) external payable {\n        InterchainTransaction memory icTx = InterchainTransactionLib.decodeTransaction(transaction);\n        bytes32 transactionId = icTx.transactionId();\n        require(_isExecutable(transactionId, icTx), \"Transaction is not executable\");\n        executedTransactions[transactionId] = true;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n        if (msg.value != decodedOptions.gasAirdrop) {\n            revert InterchainClientV1__IncorrectMsgValue(msg.value, decodedOptions.gasAirdrop);\n        }\n        // We should always use at least as much as the requested gas limit.\n        // The executor can specify a higher gas limit if they wanted.\n        if (decodedOptions.gasLimit \u003e gasLimit) gasLimit = decodedOptions.gasLimit;\n        // Pass the full msg.value to the app: we have already checked that it matches the requested gas airdrop.\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: gasLimit, value: msg.value}({\n            srcChainId: icTx.srcChainId,\n            sender: icTx.srcSender,\n            nonce: icTx.nonce,\n            message: icTx.message\n        });\n        emit InterchainTransactionReceived(\n            transactionId, icTx.dbNonce, icTx.srcChainId, icTx.srcSender, icTx.dstReceiver\n        );\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"14254:280:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;14254:280:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"14254:280:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"TypeCasts\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0xb1820886ef923c4c065c5baff37b5df87b8df1e6d6b4c15efa8656e6bf9bab55\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://d5135fd5a15dd9be50d78f48a77d63d2477f99180a88a45d658259fa89e992a9\",\"dweb:/ipfs/QmeHcqSVFPtKYu1XVd751xBixEPBV2b3rN2jMUYAMKTKqN\"]}},\"version\":1}"},"hashes":{}}}