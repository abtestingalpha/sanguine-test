{"solidity/InterchainClientV1.sol:Context":{"code":"0x","runtime-code":"0x","info":{"source":"pragma solidity 0.8.20;\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n/// @notice Struct representing an entry in the Interchain DataBase\n/// @param srcChainId   The chain id of the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param writerNonce  The nonce of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    bytes32 srcWriter;\n    uint256 writerNonce;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param srcWriter    The address of the writer on the local chain\n    /// @param writerNonce  The nonce of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        address srcWriter,\n        uint256 writerNonce,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            srcWriter: TypeCasts.addressToBytes32(srcWriter),\n            writerNonce: writerNonce,\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryId(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.srcWriter, entry.writerNonce));\n    }\n}\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param dataHash     The hash of the data written on the source chain\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 dataHash;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingDataHash, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(address writer, uint256 writerNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntry(bytes32 dataHash) external returns (uint256 writerNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param writer        The address of the writer on the source chain\n    /// @param writerNonce   The nonce of the writer on the source chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(\n        uint256 destChainId,\n        address writer,\n        uint256 writerNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 writerNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param writer       The address of the writer on this chain\n    /// @param writerNonce  The nonce of the writer's entry on this chain\n    function getEntry(address writer, uint256 writerNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the writer on this chain.\n    /// @param writer       The address of the writer on this chain\n    function getWriterNonce(address writer) external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\ninterface IInterchainApp {\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory sendingModules,\n        address[] memory receivingModules,\n        uint256 requiredResponses,\n        uint64 optimisticTimePeriod\n    )\n        external;\n\n    function getLinkedIApp(uint64 chainID) external view returns (address);\n\n    function getSendingModules() external view returns (address[] memory);\n\n    function getReceivingModules() external view returns (address[] memory);\n\n    function getRequiredResponses() external view returns (uint256);\n\n    function getOptimisticTimePeriod() external view returns (uint64);\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable;\n\n    function appReceive() external;\n}\n\ninterface IInterchainClientV1 {\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sets the address of the InterchainDB contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param _interchainDB The address of the InterchainDB contract.\n     */\n    function setInterchainDB(address _interchainDB) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param message The message being sent.\n     * @param options Execution options for the message sent, encoded as bytes, currently primarily gas limit + native gas drop.\n     * @param srcModules The source modules involved in the message sending.\n     */\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        bytes calldata options,\n        address[] calldata srcModules\n    )\n        external\n        payable;\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * @param transaction The transaction data.\n     */\n    function interchainExecute(bytes calldata transaction) external;\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction The InterchainTransaction struct to be checked.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction) external view returns (bool);\n}\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    uint8 constant OPTIONS_V1 = 1;\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, IInterchainClientV1 {\n    using OptionsLib for bytes;\n\n    uint64 public clientNonce;\n    address public interchainDB;\n    mapping(bytes32 =\u003e bool) public executedTransactions;\n\n    // Chain ID =\u003e Bytes32 Address of src clients\n    mapping(uint256 =\u003e bytes32) public linkedClients;\n\n    // TODO: Add permissioning\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint256 chainId, bytes32 client) public onlyOwner {\n        linkedClients[chainId] = client;\n    }\n\n    constructor() Ownable(msg.sender) {}\n\n    // @inheritdoc IInterchainClientV1\n    function setInterchainDB(address _interchainDB) public onlyOwner {\n        interchainDB = _interchainDB;\n    }\n\n    /**\n     * @notice Emitted when an interchain transaction is sent.\n     */\n    event InterchainTransactionSent(\n        bytes32 srcSender,\n        uint256 srcChainId,\n        bytes32 indexed dstReceiver,\n        uint256 indexed dstChainId,\n        bytes message,\n        uint64 nonce,\n        bytes options,\n        bytes32 indexed transactionId,\n        uint256 dbWriterNonce\n    );\n\n    // @notice Emitted when an interchain transaction is executed.\n    // TODO: Indexing\n    event InterchainTransactionExecuted(\n        bytes32 indexed srcSender,\n        uint256 indexed srcChainId,\n        bytes32 dstReceiver,\n        uint256 dstChainId,\n        bytes message,\n        uint64 nonce,\n        bytes options,\n        bytes32 indexed transactionId,\n        uint256 dbWriterNonce\n    );\n\n    /**\n     * @dev Represents an interchain transaction.\n     */\n    struct InterchainTransaction {\n        bytes32 srcSender;\n        uint256 srcChainId;\n        bytes32 dstReceiver;\n        uint256 dstChainId;\n        bytes message;\n        uint64 nonce;\n        bytes options;\n        bytes32 transactionId;\n        uint256 dbWriterNonce;\n    }\n\n    function _generateTransactionId(\n        bytes32 srcSender,\n        uint256 srcChainId,\n        bytes32 dstReceiver,\n        uint256 dstChainId,\n        bytes memory message,\n        uint64 nonce,\n        bytes memory options\n    )\n    internal\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encode(srcSender, srcChainId, dstReceiver, dstChainId, message, nonce, options));\n    }\n\n    // TODO: Calculate Gas Pricing per module and charge fees\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        bytes calldata options,\n        address[] calldata srcModules\n    )\n    public\n    payable\n    {\n        uint256 totalModuleFees = msg.value;\n\n        InterchainTransaction memory icTx = InterchainTransaction({\n            srcSender: TypeCasts.addressToBytes32(msg.sender),\n            srcChainId: block.chainid,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            message: message,\n            nonce: clientNonce,\n            options: options,\n            transactionId: 0,\n            dbWriterNonce: 0\n        });\n\n        bytes32 transactionId = _generateTransactionId(\n            icTx.srcSender, icTx.srcChainId, icTx.dstReceiver, icTx.dstChainId, icTx.message, icTx.nonce, icTx.options\n        );\n        icTx.transactionId = transactionId;\n\n        uint256 dbWriterNonce = IInterchainDB(interchainDB).writeEntryWithVerification{value: totalModuleFees}(\n            icTx.dstChainId, icTx.transactionId, srcModules\n        );\n        icTx.dbWriterNonce = dbWriterNonce;\n\n        emit InterchainTransactionSent(\n            icTx.srcSender,\n            icTx.srcChainId,\n            icTx.dstReceiver,\n            icTx.dstChainId,\n            icTx.message,\n            icTx.nonce,\n            icTx.options,\n            icTx.transactionId,\n            icTx.dbWriterNonce\n        );\n        // Increment nonce for next message\n        clientNonce++;\n    }\n\n    // TODO: App Config Versioning\n    // TODO: What if receiver is not a contract / doesn't conform to interface?\n    /**\n     * @dev Retrieves the application configuration for a given receiver application.\n     * @param receiverApp The address of the receiver application.\n     * @return requiredResponses The number of required responses from the receiving modules.\n     * @return optimisticTimePeriod The time period within which responses are considered valid.\n     * @return approvedDstModules An array of addresses of the approved destination modules.\n     */\n    function _getAppConfig(address receiverApp)\n    internal\n    view\n    returns (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules)\n    {\n        requiredResponses = IInterchainApp(receiverApp).getRequiredResponses();\n        optimisticTimePeriod = IInterchainApp(receiverApp).getOptimisticTimePeriod();\n        approvedDstModules = IInterchainApp(receiverApp).getReceivingModules();\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata transaction) public view returns (bool) {\n        InterchainTransaction memory icTx = abi.decode(transaction, (InterchainTransaction));\n        require(executedTransactions[icTx.transactionId] == false, \"Transaction already executed\");\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            srcWriter: linkedClients[icTx.srcChainId],\n            writerNonce: icTx.dbWriterNonce,\n            dataHash: icTx.transactionId\n        });\n\n        bytes32 reconstructedID = _generateTransactionId(\n            icTx.srcSender, icTx.srcChainId, icTx.dstReceiver, icTx.dstChainId, icTx.message, icTx.nonce, icTx.options\n        );\n\n        require(icTx.transactionId == reconstructedID, \"Invalid transaction ID\");\n\n        (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules) =\n                        _getAppConfig(TypeCasts.bytes32ToAddress(icTx.dstReceiver));\n\n        uint256[] memory approvedResponses = _getApprovedResponses(approvedDstModules, icEntry);\n\n        uint256 finalizedResponses = _getFinalizedResponsesCount(approvedResponses, optimisticTimePeriod);\n        require(finalizedResponses \u003e= requiredResponses, \"Not enough valid responses to meet the threshold\");\n        return true;\n    }\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedResponses An array of timestamps when each approved response was recorded.\n     * @param optimisticTimePeriod The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses The count of responses that are finalized within the optimistic time period.\n     */\n\n    function _getFinalizedResponsesCount(\n        uint256[] memory approvedResponses,\n        uint256 optimisticTimePeriod\n    )\n    internal\n    view\n    returns (uint256)\n    {\n        uint256 finalizedResponses = 0;\n        for (uint256 i = 0; i \u003c approvedResponses.length; i++) {\n            if (approvedResponses[i] + optimisticTimePeriod \u003c= block.timestamp) {\n                finalizedResponses++;\n            }\n        }\n        return finalizedResponses;\n    }\n    /**\n     * @dev Retrieves the responses from approved modules for a given InterchainEntry.\n     * This function iterates over all approved modules, querying the InterchainDB for each module's response\n     * to the provided InterchainEntry. It compiles these responses into an array of uint256, where each\n     * element represents the timestamp of a module's response.\n     *\n     * @param approvedModules An array of addresses representing the approved modules that can write responses.\n     * @param icEntry The InterchainEntry for which responses are being retrieved.\n     * @return approvedResponses An array of uint256 representing the timestamps of responses from approved modules.\n     */\n\n    function _getApprovedResponses(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry\n    )\n    internal\n    view\n    returns (uint256[] memory)\n    {\n        uint256[] memory approvedResponses = new uint256[](approvedModules.length);\n        for (uint256 i = 0; i \u003c approvedModules.length; i++) {\n            approvedResponses[i] = IInterchainDB(interchainDB).readEntry(approvedModules[i], icEntry);\n        }\n        return approvedResponses;\n    }\n\n    function encodeTransaction(InterchainTransaction memory icTx) public view returns (bytes memory) {\n        return abi.encode(icTx);\n    }\n\n    // TODO: Gas Fee Consideration that is paid to executor\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(bytes calldata transaction) public {\n        require(isExecutable(transaction), \"Transaction is not executable\");\n        InterchainTransaction memory icTx = abi.decode(transaction, (InterchainTransaction));\n        executedTransactions[icTx.transactionId] = true;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: decodedOptions.gasLimit}();\n        emit InterchainTransactionExecuted(\n            icTx.srcSender,\n            icTx.srcChainId,\n            icTx.dstReceiver,\n            icTx.dstChainId,\n            icTx.message,\n            icTx.nonce,\n            icTx.options,\n            icTx.transactionId,\n            icTx.dbWriterNonce\n        );\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Provides information about the current execution context, including the sender of the transaction and its data. While these are generally available via msg.sender and msg.data, they should not be accessed in such a direct manner, since when dealing with meta-transactions the account sending and paying for execution may not be the actual sender (as far as an application is concerned). This contract is only required for intermediate, library-like contracts.","kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Provides information about the current execution context, including the sender of the transaction and its data. While these are generally available via msg.sender and msg.data, they should not be accessed in such a direct manner, since when dealing with meta-transactions the account sending and paying for execution may not be the actual sender (as far as an application is concerned). This contract is only required for intermediate, library-like contracts.\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"Context\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0x44c9e0bf0e33c29df6b63f8909747984d3ad8c376a763f57eaa613086c22bb2c\",\"urls\":[\"bzz-raw://f5ad81ebeb36f44c014dbf8fe28dc9747b29eea33cc2d37a5d245fdbb1ef06f8\",\"dweb:/ipfs/QmW4JUaEBdaochJpLMphHqqu1WUrYxjESNET4HciC2jXtX\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainClientV1.sol:IInterchainApp":{"code":"0x","runtime-code":"0x","info":{"source":"pragma solidity 0.8.20;\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n/// @notice Struct representing an entry in the Interchain DataBase\n/// @param srcChainId   The chain id of the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param writerNonce  The nonce of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    bytes32 srcWriter;\n    uint256 writerNonce;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param srcWriter    The address of the writer on the local chain\n    /// @param writerNonce  The nonce of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        address srcWriter,\n        uint256 writerNonce,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            srcWriter: TypeCasts.addressToBytes32(srcWriter),\n            writerNonce: writerNonce,\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryId(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.srcWriter, entry.writerNonce));\n    }\n}\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param dataHash     The hash of the data written on the source chain\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 dataHash;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingDataHash, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(address writer, uint256 writerNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntry(bytes32 dataHash) external returns (uint256 writerNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param writer        The address of the writer on the source chain\n    /// @param writerNonce   The nonce of the writer on the source chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(\n        uint256 destChainId,\n        address writer,\n        uint256 writerNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 writerNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param writer       The address of the writer on this chain\n    /// @param writerNonce  The nonce of the writer's entry on this chain\n    function getEntry(address writer, uint256 writerNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the writer on this chain.\n    /// @param writer       The address of the writer on this chain\n    function getWriterNonce(address writer) external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\ninterface IInterchainApp {\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory sendingModules,\n        address[] memory receivingModules,\n        uint256 requiredResponses,\n        uint64 optimisticTimePeriod\n    )\n        external;\n\n    function getLinkedIApp(uint64 chainID) external view returns (address);\n\n    function getSendingModules() external view returns (address[] memory);\n\n    function getReceivingModules() external view returns (address[] memory);\n\n    function getRequiredResponses() external view returns (uint256);\n\n    function getOptimisticTimePeriod() external view returns (uint64);\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable;\n\n    function appReceive() external;\n}\n\ninterface IInterchainClientV1 {\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sets the address of the InterchainDB contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param _interchainDB The address of the InterchainDB contract.\n     */\n    function setInterchainDB(address _interchainDB) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param message The message being sent.\n     * @param options Execution options for the message sent, encoded as bytes, currently primarily gas limit + native gas drop.\n     * @param srcModules The source modules involved in the message sending.\n     */\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        bytes calldata options,\n        address[] calldata srcModules\n    )\n        external\n        payable;\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * @param transaction The transaction data.\n     */\n    function interchainExecute(bytes calldata transaction) external;\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction The InterchainTransaction struct to be checked.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction) external view returns (bool);\n}\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    uint8 constant OPTIONS_V1 = 1;\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, IInterchainClientV1 {\n    using OptionsLib for bytes;\n\n    uint64 public clientNonce;\n    address public interchainDB;\n    mapping(bytes32 =\u003e bool) public executedTransactions;\n\n    // Chain ID =\u003e Bytes32 Address of src clients\n    mapping(uint256 =\u003e bytes32) public linkedClients;\n\n    // TODO: Add permissioning\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint256 chainId, bytes32 client) public onlyOwner {\n        linkedClients[chainId] = client;\n    }\n\n    constructor() Ownable(msg.sender) {}\n\n    // @inheritdoc IInterchainClientV1\n    function setInterchainDB(address _interchainDB) public onlyOwner {\n        interchainDB = _interchainDB;\n    }\n\n    /**\n     * @notice Emitted when an interchain transaction is sent.\n     */\n    event InterchainTransactionSent(\n        bytes32 srcSender,\n        uint256 srcChainId,\n        bytes32 indexed dstReceiver,\n        uint256 indexed dstChainId,\n        bytes message,\n        uint64 nonce,\n        bytes options,\n        bytes32 indexed transactionId,\n        uint256 dbWriterNonce\n    );\n\n    // @notice Emitted when an interchain transaction is executed.\n    // TODO: Indexing\n    event InterchainTransactionExecuted(\n        bytes32 indexed srcSender,\n        uint256 indexed srcChainId,\n        bytes32 dstReceiver,\n        uint256 dstChainId,\n        bytes message,\n        uint64 nonce,\n        bytes options,\n        bytes32 indexed transactionId,\n        uint256 dbWriterNonce\n    );\n\n    /**\n     * @dev Represents an interchain transaction.\n     */\n    struct InterchainTransaction {\n        bytes32 srcSender;\n        uint256 srcChainId;\n        bytes32 dstReceiver;\n        uint256 dstChainId;\n        bytes message;\n        uint64 nonce;\n        bytes options;\n        bytes32 transactionId;\n        uint256 dbWriterNonce;\n    }\n\n    function _generateTransactionId(\n        bytes32 srcSender,\n        uint256 srcChainId,\n        bytes32 dstReceiver,\n        uint256 dstChainId,\n        bytes memory message,\n        uint64 nonce,\n        bytes memory options\n    )\n    internal\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encode(srcSender, srcChainId, dstReceiver, dstChainId, message, nonce, options));\n    }\n\n    // TODO: Calculate Gas Pricing per module and charge fees\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        bytes calldata options,\n        address[] calldata srcModules\n    )\n    public\n    payable\n    {\n        uint256 totalModuleFees = msg.value;\n\n        InterchainTransaction memory icTx = InterchainTransaction({\n            srcSender: TypeCasts.addressToBytes32(msg.sender),\n            srcChainId: block.chainid,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            message: message,\n            nonce: clientNonce,\n            options: options,\n            transactionId: 0,\n            dbWriterNonce: 0\n        });\n\n        bytes32 transactionId = _generateTransactionId(\n            icTx.srcSender, icTx.srcChainId, icTx.dstReceiver, icTx.dstChainId, icTx.message, icTx.nonce, icTx.options\n        );\n        icTx.transactionId = transactionId;\n\n        uint256 dbWriterNonce = IInterchainDB(interchainDB).writeEntryWithVerification{value: totalModuleFees}(\n            icTx.dstChainId, icTx.transactionId, srcModules\n        );\n        icTx.dbWriterNonce = dbWriterNonce;\n\n        emit InterchainTransactionSent(\n            icTx.srcSender,\n            icTx.srcChainId,\n            icTx.dstReceiver,\n            icTx.dstChainId,\n            icTx.message,\n            icTx.nonce,\n            icTx.options,\n            icTx.transactionId,\n            icTx.dbWriterNonce\n        );\n        // Increment nonce for next message\n        clientNonce++;\n    }\n\n    // TODO: App Config Versioning\n    // TODO: What if receiver is not a contract / doesn't conform to interface?\n    /**\n     * @dev Retrieves the application configuration for a given receiver application.\n     * @param receiverApp The address of the receiver application.\n     * @return requiredResponses The number of required responses from the receiving modules.\n     * @return optimisticTimePeriod The time period within which responses are considered valid.\n     * @return approvedDstModules An array of addresses of the approved destination modules.\n     */\n    function _getAppConfig(address receiverApp)\n    internal\n    view\n    returns (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules)\n    {\n        requiredResponses = IInterchainApp(receiverApp).getRequiredResponses();\n        optimisticTimePeriod = IInterchainApp(receiverApp).getOptimisticTimePeriod();\n        approvedDstModules = IInterchainApp(receiverApp).getReceivingModules();\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata transaction) public view returns (bool) {\n        InterchainTransaction memory icTx = abi.decode(transaction, (InterchainTransaction));\n        require(executedTransactions[icTx.transactionId] == false, \"Transaction already executed\");\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            srcWriter: linkedClients[icTx.srcChainId],\n            writerNonce: icTx.dbWriterNonce,\n            dataHash: icTx.transactionId\n        });\n\n        bytes32 reconstructedID = _generateTransactionId(\n            icTx.srcSender, icTx.srcChainId, icTx.dstReceiver, icTx.dstChainId, icTx.message, icTx.nonce, icTx.options\n        );\n\n        require(icTx.transactionId == reconstructedID, \"Invalid transaction ID\");\n\n        (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules) =\n                        _getAppConfig(TypeCasts.bytes32ToAddress(icTx.dstReceiver));\n\n        uint256[] memory approvedResponses = _getApprovedResponses(approvedDstModules, icEntry);\n\n        uint256 finalizedResponses = _getFinalizedResponsesCount(approvedResponses, optimisticTimePeriod);\n        require(finalizedResponses \u003e= requiredResponses, \"Not enough valid responses to meet the threshold\");\n        return true;\n    }\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedResponses An array of timestamps when each approved response was recorded.\n     * @param optimisticTimePeriod The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses The count of responses that are finalized within the optimistic time period.\n     */\n\n    function _getFinalizedResponsesCount(\n        uint256[] memory approvedResponses,\n        uint256 optimisticTimePeriod\n    )\n    internal\n    view\n    returns (uint256)\n    {\n        uint256 finalizedResponses = 0;\n        for (uint256 i = 0; i \u003c approvedResponses.length; i++) {\n            if (approvedResponses[i] + optimisticTimePeriod \u003c= block.timestamp) {\n                finalizedResponses++;\n            }\n        }\n        return finalizedResponses;\n    }\n    /**\n     * @dev Retrieves the responses from approved modules for a given InterchainEntry.\n     * This function iterates over all approved modules, querying the InterchainDB for each module's response\n     * to the provided InterchainEntry. It compiles these responses into an array of uint256, where each\n     * element represents the timestamp of a module's response.\n     *\n     * @param approvedModules An array of addresses representing the approved modules that can write responses.\n     * @param icEntry The InterchainEntry for which responses are being retrieved.\n     * @return approvedResponses An array of uint256 representing the timestamps of responses from approved modules.\n     */\n\n    function _getApprovedResponses(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry\n    )\n    internal\n    view\n    returns (uint256[] memory)\n    {\n        uint256[] memory approvedResponses = new uint256[](approvedModules.length);\n        for (uint256 i = 0; i \u003c approvedModules.length; i++) {\n            approvedResponses[i] = IInterchainDB(interchainDB).readEntry(approvedModules[i], icEntry);\n        }\n        return approvedResponses;\n    }\n\n    function encodeTransaction(InterchainTransaction memory icTx) public view returns (bytes memory) {\n        return abi.encode(icTx);\n    }\n\n    // TODO: Gas Fee Consideration that is paid to executor\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(bytes calldata transaction) public {\n        require(isExecutable(transaction), \"Transaction is not executable\");\n        InterchainTransaction memory icTx = abi.decode(transaction, (InterchainTransaction));\n        executedTransactions[icTx.transactionId] = true;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: decodedOptions.gasLimit}();\n        emit InterchainTransactionExecuted(\n            icTx.srcSender,\n            icTx.srcChainId,\n            icTx.dstReceiver,\n            icTx.dstChainId,\n            icTx.message,\n            icTx.nonce,\n            icTx.options,\n            icTx.transactionId,\n            icTx.dbWriterNonce\n        );\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[],"name":"appReceive","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint64","name":"chainID","type":"uint64"}],"name":"getLinkedIApp","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getOptimisticTimePeriod","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getReceivingModules","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getRequiredResponses","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getSendingModules","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"receiver","type":"bytes32"},{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"send","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint64[]","name":"chainIDs","type":"uint64[]"},{"internalType":"address[]","name":"linkedIApps","type":"address[]"},{"internalType":"address[]","name":"sendingModules","type":"address[]"},{"internalType":"address[]","name":"receivingModules","type":"address[]"},{"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"internalType":"uint64","name":"optimisticTimePeriod","type":"uint64"}],"name":"setAppConfig","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"appReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainID\",\"type\":\"uint64\"}],\"name\":\"getLinkedIApp\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOptimisticTimePeriod\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReceivingModules\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRequiredResponses\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSendingModules\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"receiver\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"send\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64[]\",\"name\":\"chainIDs\",\"type\":\"uint64[]\"},{\"internalType\":\"address[]\",\"name\":\"linkedIApps\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"sendingModules\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"receivingModules\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"optimisticTimePeriod\",\"type\":\"uint64\"}],\"name\":\"setAppConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"IInterchainApp\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0x44c9e0bf0e33c29df6b63f8909747984d3ad8c376a763f57eaa613086c22bb2c\",\"urls\":[\"bzz-raw://f5ad81ebeb36f44c014dbf8fe28dc9747b29eea33cc2d37a5d245fdbb1ef06f8\",\"dweb:/ipfs/QmW4JUaEBdaochJpLMphHqqu1WUrYxjESNET4HciC2jXtX\"]}},\"version\":1}"},"hashes":{"appReceive()":"7bcad630","getLinkedIApp(uint64)":"bfc849ee","getOptimisticTimePeriod()":"7c9abd3e","getReceivingModules()":"a45e107a","getRequiredResponses()":"f31b19a9","getSendingModules()":"ea13398f","send(bytes32,uint256,bytes)":"e1ef3b3f","setAppConfig(uint64[],address[],address[],address[],uint256,uint64)":"dd34f56a"}},"solidity/InterchainClientV1.sol:IInterchainClientV1":{"code":"0x","runtime-code":"0x","info":{"source":"pragma solidity 0.8.20;\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n/// @notice Struct representing an entry in the Interchain DataBase\n/// @param srcChainId   The chain id of the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param writerNonce  The nonce of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    bytes32 srcWriter;\n    uint256 writerNonce;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param srcWriter    The address of the writer on the local chain\n    /// @param writerNonce  The nonce of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        address srcWriter,\n        uint256 writerNonce,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            srcWriter: TypeCasts.addressToBytes32(srcWriter),\n            writerNonce: writerNonce,\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryId(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.srcWriter, entry.writerNonce));\n    }\n}\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param dataHash     The hash of the data written on the source chain\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 dataHash;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingDataHash, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(address writer, uint256 writerNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntry(bytes32 dataHash) external returns (uint256 writerNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param writer        The address of the writer on the source chain\n    /// @param writerNonce   The nonce of the writer on the source chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(\n        uint256 destChainId,\n        address writer,\n        uint256 writerNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 writerNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param writer       The address of the writer on this chain\n    /// @param writerNonce  The nonce of the writer's entry on this chain\n    function getEntry(address writer, uint256 writerNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the writer on this chain.\n    /// @param writer       The address of the writer on this chain\n    function getWriterNonce(address writer) external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\ninterface IInterchainApp {\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory sendingModules,\n        address[] memory receivingModules,\n        uint256 requiredResponses,\n        uint64 optimisticTimePeriod\n    )\n        external;\n\n    function getLinkedIApp(uint64 chainID) external view returns (address);\n\n    function getSendingModules() external view returns (address[] memory);\n\n    function getReceivingModules() external view returns (address[] memory);\n\n    function getRequiredResponses() external view returns (uint256);\n\n    function getOptimisticTimePeriod() external view returns (uint64);\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable;\n\n    function appReceive() external;\n}\n\ninterface IInterchainClientV1 {\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sets the address of the InterchainDB contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param _interchainDB The address of the InterchainDB contract.\n     */\n    function setInterchainDB(address _interchainDB) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param message The message being sent.\n     * @param options Execution options for the message sent, encoded as bytes, currently primarily gas limit + native gas drop.\n     * @param srcModules The source modules involved in the message sending.\n     */\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        bytes calldata options,\n        address[] calldata srcModules\n    )\n        external\n        payable;\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * @param transaction The transaction data.\n     */\n    function interchainExecute(bytes calldata transaction) external;\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction The InterchainTransaction struct to be checked.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction) external view returns (bool);\n}\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    uint8 constant OPTIONS_V1 = 1;\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, IInterchainClientV1 {\n    using OptionsLib for bytes;\n\n    uint64 public clientNonce;\n    address public interchainDB;\n    mapping(bytes32 =\u003e bool) public executedTransactions;\n\n    // Chain ID =\u003e Bytes32 Address of src clients\n    mapping(uint256 =\u003e bytes32) public linkedClients;\n\n    // TODO: Add permissioning\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint256 chainId, bytes32 client) public onlyOwner {\n        linkedClients[chainId] = client;\n    }\n\n    constructor() Ownable(msg.sender) {}\n\n    // @inheritdoc IInterchainClientV1\n    function setInterchainDB(address _interchainDB) public onlyOwner {\n        interchainDB = _interchainDB;\n    }\n\n    /**\n     * @notice Emitted when an interchain transaction is sent.\n     */\n    event InterchainTransactionSent(\n        bytes32 srcSender,\n        uint256 srcChainId,\n        bytes32 indexed dstReceiver,\n        uint256 indexed dstChainId,\n        bytes message,\n        uint64 nonce,\n        bytes options,\n        bytes32 indexed transactionId,\n        uint256 dbWriterNonce\n    );\n\n    // @notice Emitted when an interchain transaction is executed.\n    // TODO: Indexing\n    event InterchainTransactionExecuted(\n        bytes32 indexed srcSender,\n        uint256 indexed srcChainId,\n        bytes32 dstReceiver,\n        uint256 dstChainId,\n        bytes message,\n        uint64 nonce,\n        bytes options,\n        bytes32 indexed transactionId,\n        uint256 dbWriterNonce\n    );\n\n    /**\n     * @dev Represents an interchain transaction.\n     */\n    struct InterchainTransaction {\n        bytes32 srcSender;\n        uint256 srcChainId;\n        bytes32 dstReceiver;\n        uint256 dstChainId;\n        bytes message;\n        uint64 nonce;\n        bytes options;\n        bytes32 transactionId;\n        uint256 dbWriterNonce;\n    }\n\n    function _generateTransactionId(\n        bytes32 srcSender,\n        uint256 srcChainId,\n        bytes32 dstReceiver,\n        uint256 dstChainId,\n        bytes memory message,\n        uint64 nonce,\n        bytes memory options\n    )\n    internal\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encode(srcSender, srcChainId, dstReceiver, dstChainId, message, nonce, options));\n    }\n\n    // TODO: Calculate Gas Pricing per module and charge fees\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        bytes calldata options,\n        address[] calldata srcModules\n    )\n    public\n    payable\n    {\n        uint256 totalModuleFees = msg.value;\n\n        InterchainTransaction memory icTx = InterchainTransaction({\n            srcSender: TypeCasts.addressToBytes32(msg.sender),\n            srcChainId: block.chainid,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            message: message,\n            nonce: clientNonce,\n            options: options,\n            transactionId: 0,\n            dbWriterNonce: 0\n        });\n\n        bytes32 transactionId = _generateTransactionId(\n            icTx.srcSender, icTx.srcChainId, icTx.dstReceiver, icTx.dstChainId, icTx.message, icTx.nonce, icTx.options\n        );\n        icTx.transactionId = transactionId;\n\n        uint256 dbWriterNonce = IInterchainDB(interchainDB).writeEntryWithVerification{value: totalModuleFees}(\n            icTx.dstChainId, icTx.transactionId, srcModules\n        );\n        icTx.dbWriterNonce = dbWriterNonce;\n\n        emit InterchainTransactionSent(\n            icTx.srcSender,\n            icTx.srcChainId,\n            icTx.dstReceiver,\n            icTx.dstChainId,\n            icTx.message,\n            icTx.nonce,\n            icTx.options,\n            icTx.transactionId,\n            icTx.dbWriterNonce\n        );\n        // Increment nonce for next message\n        clientNonce++;\n    }\n\n    // TODO: App Config Versioning\n    // TODO: What if receiver is not a contract / doesn't conform to interface?\n    /**\n     * @dev Retrieves the application configuration for a given receiver application.\n     * @param receiverApp The address of the receiver application.\n     * @return requiredResponses The number of required responses from the receiving modules.\n     * @return optimisticTimePeriod The time period within which responses are considered valid.\n     * @return approvedDstModules An array of addresses of the approved destination modules.\n     */\n    function _getAppConfig(address receiverApp)\n    internal\n    view\n    returns (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules)\n    {\n        requiredResponses = IInterchainApp(receiverApp).getRequiredResponses();\n        optimisticTimePeriod = IInterchainApp(receiverApp).getOptimisticTimePeriod();\n        approvedDstModules = IInterchainApp(receiverApp).getReceivingModules();\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata transaction) public view returns (bool) {\n        InterchainTransaction memory icTx = abi.decode(transaction, (InterchainTransaction));\n        require(executedTransactions[icTx.transactionId] == false, \"Transaction already executed\");\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            srcWriter: linkedClients[icTx.srcChainId],\n            writerNonce: icTx.dbWriterNonce,\n            dataHash: icTx.transactionId\n        });\n\n        bytes32 reconstructedID = _generateTransactionId(\n            icTx.srcSender, icTx.srcChainId, icTx.dstReceiver, icTx.dstChainId, icTx.message, icTx.nonce, icTx.options\n        );\n\n        require(icTx.transactionId == reconstructedID, \"Invalid transaction ID\");\n\n        (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules) =\n                        _getAppConfig(TypeCasts.bytes32ToAddress(icTx.dstReceiver));\n\n        uint256[] memory approvedResponses = _getApprovedResponses(approvedDstModules, icEntry);\n\n        uint256 finalizedResponses = _getFinalizedResponsesCount(approvedResponses, optimisticTimePeriod);\n        require(finalizedResponses \u003e= requiredResponses, \"Not enough valid responses to meet the threshold\");\n        return true;\n    }\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedResponses An array of timestamps when each approved response was recorded.\n     * @param optimisticTimePeriod The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses The count of responses that are finalized within the optimistic time period.\n     */\n\n    function _getFinalizedResponsesCount(\n        uint256[] memory approvedResponses,\n        uint256 optimisticTimePeriod\n    )\n    internal\n    view\n    returns (uint256)\n    {\n        uint256 finalizedResponses = 0;\n        for (uint256 i = 0; i \u003c approvedResponses.length; i++) {\n            if (approvedResponses[i] + optimisticTimePeriod \u003c= block.timestamp) {\n                finalizedResponses++;\n            }\n        }\n        return finalizedResponses;\n    }\n    /**\n     * @dev Retrieves the responses from approved modules for a given InterchainEntry.\n     * This function iterates over all approved modules, querying the InterchainDB for each module's response\n     * to the provided InterchainEntry. It compiles these responses into an array of uint256, where each\n     * element represents the timestamp of a module's response.\n     *\n     * @param approvedModules An array of addresses representing the approved modules that can write responses.\n     * @param icEntry The InterchainEntry for which responses are being retrieved.\n     * @return approvedResponses An array of uint256 representing the timestamps of responses from approved modules.\n     */\n\n    function _getApprovedResponses(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry\n    )\n    internal\n    view\n    returns (uint256[] memory)\n    {\n        uint256[] memory approvedResponses = new uint256[](approvedModules.length);\n        for (uint256 i = 0; i \u003c approvedModules.length; i++) {\n            approvedResponses[i] = IInterchainDB(interchainDB).readEntry(approvedModules[i], icEntry);\n        }\n        return approvedResponses;\n    }\n\n    function encodeTransaction(InterchainTransaction memory icTx) public view returns (bytes memory) {\n        return abi.encode(icTx);\n    }\n\n    // TODO: Gas Fee Consideration that is paid to executor\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(bytes calldata transaction) public {\n        require(isExecutable(transaction), \"Transaction is not executable\");\n        InterchainTransaction memory icTx = abi.decode(transaction, (InterchainTransaction));\n        executedTransactions[icTx.transactionId] = true;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: decodedOptions.gasLimit}();\n        emit InterchainTransactionExecuted(\n            icTx.srcSender,\n            icTx.srcChainId,\n            icTx.dstReceiver,\n            icTx.dstChainId,\n            icTx.message,\n            icTx.nonce,\n            icTx.options,\n            icTx.transactionId,\n            icTx.dbWriterNonce\n        );\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"bytes","name":"transaction","type":"bytes"}],"name":"interchainExecute","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"receiver","type":"bytes32"},{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"bytes","name":"message","type":"bytes"},{"internalType":"bytes","name":"options","type":"bytes"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"interchainSend","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes","name":"transaction","type":"bytes"}],"name":"isExecutable","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_interchainDB","type":"address"}],"name":"setInterchainDB","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"bytes32","name":"client","type":"bytes32"}],"name":"setLinkedClient","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"interchainExecute(bytes)":{"notice":"Executes a transaction that has been sent via the Interchain."},"interchainSend(bytes32,uint256,bytes,bytes,address[])":{"notice":"Sends a message to another chain via the Interchain Communication Protocol."},"isExecutable(bytes)":{"notice":"Checks if a transaction is executable."},"setInterchainDB(address)":{"notice":"Sets the address of the InterchainDB contract."},"setLinkedClient(uint256,bytes32)":{"notice":"Sets the linked client for a specific chain ID."}},"version":1},"developerDoc":{"kind":"dev","methods":{"interchainExecute(bytes)":{"details":"The transaction must have been previously sent and recorded.","params":{"transaction":"The transaction data."}},"interchainSend(bytes32,uint256,bytes,bytes,address[])":{"details":"Charges a fee for the message, which is payable upon calling this function.","params":{"dstChainId":"The chain ID of the destination chain.","message":"The message being sent.","options":"Execution options for the message sent, encoded as bytes, currently primarily gas limit + native gas drop.","receiver":"The address of the receiver on the destination chain.","srcModules":"The source modules involved in the message sending."}},"isExecutable(bytes)":{"details":"Determines if a transaction meets the criteria to be executed based on: - If approved modules have written to the InterchainDB - If the threshold of approved modules have been met - If the optimistic window has passed for all modules","params":{"transaction":"The InterchainTransaction struct to be checked."},"returns":{"_0":"bool Returns true if the transaction is executable, false otherwise."}},"setInterchainDB(address)":{"details":"Only callable by the contract owner or an authorized account.","params":{"_interchainDB":"The address of the InterchainDB contract."}},"setLinkedClient(uint256,bytes32)":{"details":"Stores the address of the linked client in a mapping with the chain ID as the key.","params":{"chainId":"The chain ID for which the client is being set.","client":"The address of the client being linked."}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"transaction\",\"type\":\"bytes\"}],\"name\":\"interchainExecute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"receiver\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"interchainSend\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"transaction\",\"type\":\"bytes\"}],\"name\":\"isExecutable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_interchainDB\",\"type\":\"address\"}],\"name\":\"setInterchainDB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"client\",\"type\":\"bytes32\"}],\"name\":\"setLinkedClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"interchainExecute(bytes)\":{\"details\":\"The transaction must have been previously sent and recorded.\",\"params\":{\"transaction\":\"The transaction data.\"}},\"interchainSend(bytes32,uint256,bytes,bytes,address[])\":{\"details\":\"Charges a fee for the message, which is payable upon calling this function.\",\"params\":{\"dstChainId\":\"The chain ID of the destination chain.\",\"message\":\"The message being sent.\",\"options\":\"Execution options for the message sent, encoded as bytes, currently primarily gas limit + native gas drop.\",\"receiver\":\"The address of the receiver on the destination chain.\",\"srcModules\":\"The source modules involved in the message sending.\"}},\"isExecutable(bytes)\":{\"details\":\"Determines if a transaction meets the criteria to be executed based on: - If approved modules have written to the InterchainDB - If the threshold of approved modules have been met - If the optimistic window has passed for all modules\",\"params\":{\"transaction\":\"The InterchainTransaction struct to be checked.\"},\"returns\":{\"_0\":\"bool Returns true if the transaction is executable, false otherwise.\"}},\"setInterchainDB(address)\":{\"details\":\"Only callable by the contract owner or an authorized account.\",\"params\":{\"_interchainDB\":\"The address of the InterchainDB contract.\"}},\"setLinkedClient(uint256,bytes32)\":{\"details\":\"Stores the address of the linked client in a mapping with the chain ID as the key.\",\"params\":{\"chainId\":\"The chain ID for which the client is being set.\",\"client\":\"The address of the client being linked.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"interchainExecute(bytes)\":{\"notice\":\"Executes a transaction that has been sent via the Interchain.\"},\"interchainSend(bytes32,uint256,bytes,bytes,address[])\":{\"notice\":\"Sends a message to another chain via the Interchain Communication Protocol.\"},\"isExecutable(bytes)\":{\"notice\":\"Checks if a transaction is executable.\"},\"setInterchainDB(address)\":{\"notice\":\"Sets the address of the InterchainDB contract.\"},\"setLinkedClient(uint256,bytes32)\":{\"notice\":\"Sets the linked client for a specific chain ID.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"IInterchainClientV1\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0x44c9e0bf0e33c29df6b63f8909747984d3ad8c376a763f57eaa613086c22bb2c\",\"urls\":[\"bzz-raw://f5ad81ebeb36f44c014dbf8fe28dc9747b29eea33cc2d37a5d245fdbb1ef06f8\",\"dweb:/ipfs/QmW4JUaEBdaochJpLMphHqqu1WUrYxjESNET4HciC2jXtX\"]}},\"version\":1}"},"hashes":{"interchainExecute(bytes)":"074c17b4","interchainSend(bytes32,uint256,bytes,bytes,address[])":"521011a9","isExecutable(bytes)":"31afa7de","setInterchainDB(address)":"b7ce2078","setLinkedClient(uint256,bytes32)":"f34234c8"}},"solidity/InterchainClientV1.sol:IInterchainDB":{"code":"0x","runtime-code":"0x","info":{"source":"pragma solidity 0.8.20;\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n/// @notice Struct representing an entry in the Interchain DataBase\n/// @param srcChainId   The chain id of the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param writerNonce  The nonce of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    bytes32 srcWriter;\n    uint256 writerNonce;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param srcWriter    The address of the writer on the local chain\n    /// @param writerNonce  The nonce of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        address srcWriter,\n        uint256 writerNonce,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            srcWriter: TypeCasts.addressToBytes32(srcWriter),\n            writerNonce: writerNonce,\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryId(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.srcWriter, entry.writerNonce));\n    }\n}\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param dataHash     The hash of the data written on the source chain\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 dataHash;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingDataHash, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(address writer, uint256 writerNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntry(bytes32 dataHash) external returns (uint256 writerNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param writer        The address of the writer on the source chain\n    /// @param writerNonce   The nonce of the writer on the source chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(\n        uint256 destChainId,\n        address writer,\n        uint256 writerNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 writerNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param writer       The address of the writer on this chain\n    /// @param writerNonce  The nonce of the writer's entry on this chain\n    function getEntry(address writer, uint256 writerNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the writer on this chain.\n    /// @param writer       The address of the writer on this chain\n    function getWriterNonce(address writer) external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\ninterface IInterchainApp {\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory sendingModules,\n        address[] memory receivingModules,\n        uint256 requiredResponses,\n        uint64 optimisticTimePeriod\n    )\n        external;\n\n    function getLinkedIApp(uint64 chainID) external view returns (address);\n\n    function getSendingModules() external view returns (address[] memory);\n\n    function getReceivingModules() external view returns (address[] memory);\n\n    function getRequiredResponses() external view returns (uint256);\n\n    function getOptimisticTimePeriod() external view returns (uint64);\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable;\n\n    function appReceive() external;\n}\n\ninterface IInterchainClientV1 {\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sets the address of the InterchainDB contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param _interchainDB The address of the InterchainDB contract.\n     */\n    function setInterchainDB(address _interchainDB) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param message The message being sent.\n     * @param options Execution options for the message sent, encoded as bytes, currently primarily gas limit + native gas drop.\n     * @param srcModules The source modules involved in the message sending.\n     */\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        bytes calldata options,\n        address[] calldata srcModules\n    )\n        external\n        payable;\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * @param transaction The transaction data.\n     */\n    function interchainExecute(bytes calldata transaction) external;\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction The InterchainTransaction struct to be checked.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction) external view returns (bool);\n}\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    uint8 constant OPTIONS_V1 = 1;\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, IInterchainClientV1 {\n    using OptionsLib for bytes;\n\n    uint64 public clientNonce;\n    address public interchainDB;\n    mapping(bytes32 =\u003e bool) public executedTransactions;\n\n    // Chain ID =\u003e Bytes32 Address of src clients\n    mapping(uint256 =\u003e bytes32) public linkedClients;\n\n    // TODO: Add permissioning\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint256 chainId, bytes32 client) public onlyOwner {\n        linkedClients[chainId] = client;\n    }\n\n    constructor() Ownable(msg.sender) {}\n\n    // @inheritdoc IInterchainClientV1\n    function setInterchainDB(address _interchainDB) public onlyOwner {\n        interchainDB = _interchainDB;\n    }\n\n    /**\n     * @notice Emitted when an interchain transaction is sent.\n     */\n    event InterchainTransactionSent(\n        bytes32 srcSender,\n        uint256 srcChainId,\n        bytes32 indexed dstReceiver,\n        uint256 indexed dstChainId,\n        bytes message,\n        uint64 nonce,\n        bytes options,\n        bytes32 indexed transactionId,\n        uint256 dbWriterNonce\n    );\n\n    // @notice Emitted when an interchain transaction is executed.\n    // TODO: Indexing\n    event InterchainTransactionExecuted(\n        bytes32 indexed srcSender,\n        uint256 indexed srcChainId,\n        bytes32 dstReceiver,\n        uint256 dstChainId,\n        bytes message,\n        uint64 nonce,\n        bytes options,\n        bytes32 indexed transactionId,\n        uint256 dbWriterNonce\n    );\n\n    /**\n     * @dev Represents an interchain transaction.\n     */\n    struct InterchainTransaction {\n        bytes32 srcSender;\n        uint256 srcChainId;\n        bytes32 dstReceiver;\n        uint256 dstChainId;\n        bytes message;\n        uint64 nonce;\n        bytes options;\n        bytes32 transactionId;\n        uint256 dbWriterNonce;\n    }\n\n    function _generateTransactionId(\n        bytes32 srcSender,\n        uint256 srcChainId,\n        bytes32 dstReceiver,\n        uint256 dstChainId,\n        bytes memory message,\n        uint64 nonce,\n        bytes memory options\n    )\n    internal\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encode(srcSender, srcChainId, dstReceiver, dstChainId, message, nonce, options));\n    }\n\n    // TODO: Calculate Gas Pricing per module and charge fees\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        bytes calldata options,\n        address[] calldata srcModules\n    )\n    public\n    payable\n    {\n        uint256 totalModuleFees = msg.value;\n\n        InterchainTransaction memory icTx = InterchainTransaction({\n            srcSender: TypeCasts.addressToBytes32(msg.sender),\n            srcChainId: block.chainid,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            message: message,\n            nonce: clientNonce,\n            options: options,\n            transactionId: 0,\n            dbWriterNonce: 0\n        });\n\n        bytes32 transactionId = _generateTransactionId(\n            icTx.srcSender, icTx.srcChainId, icTx.dstReceiver, icTx.dstChainId, icTx.message, icTx.nonce, icTx.options\n        );\n        icTx.transactionId = transactionId;\n\n        uint256 dbWriterNonce = IInterchainDB(interchainDB).writeEntryWithVerification{value: totalModuleFees}(\n            icTx.dstChainId, icTx.transactionId, srcModules\n        );\n        icTx.dbWriterNonce = dbWriterNonce;\n\n        emit InterchainTransactionSent(\n            icTx.srcSender,\n            icTx.srcChainId,\n            icTx.dstReceiver,\n            icTx.dstChainId,\n            icTx.message,\n            icTx.nonce,\n            icTx.options,\n            icTx.transactionId,\n            icTx.dbWriterNonce\n        );\n        // Increment nonce for next message\n        clientNonce++;\n    }\n\n    // TODO: App Config Versioning\n    // TODO: What if receiver is not a contract / doesn't conform to interface?\n    /**\n     * @dev Retrieves the application configuration for a given receiver application.\n     * @param receiverApp The address of the receiver application.\n     * @return requiredResponses The number of required responses from the receiving modules.\n     * @return optimisticTimePeriod The time period within which responses are considered valid.\n     * @return approvedDstModules An array of addresses of the approved destination modules.\n     */\n    function _getAppConfig(address receiverApp)\n    internal\n    view\n    returns (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules)\n    {\n        requiredResponses = IInterchainApp(receiverApp).getRequiredResponses();\n        optimisticTimePeriod = IInterchainApp(receiverApp).getOptimisticTimePeriod();\n        approvedDstModules = IInterchainApp(receiverApp).getReceivingModules();\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata transaction) public view returns (bool) {\n        InterchainTransaction memory icTx = abi.decode(transaction, (InterchainTransaction));\n        require(executedTransactions[icTx.transactionId] == false, \"Transaction already executed\");\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            srcWriter: linkedClients[icTx.srcChainId],\n            writerNonce: icTx.dbWriterNonce,\n            dataHash: icTx.transactionId\n        });\n\n        bytes32 reconstructedID = _generateTransactionId(\n            icTx.srcSender, icTx.srcChainId, icTx.dstReceiver, icTx.dstChainId, icTx.message, icTx.nonce, icTx.options\n        );\n\n        require(icTx.transactionId == reconstructedID, \"Invalid transaction ID\");\n\n        (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules) =\n                        _getAppConfig(TypeCasts.bytes32ToAddress(icTx.dstReceiver));\n\n        uint256[] memory approvedResponses = _getApprovedResponses(approvedDstModules, icEntry);\n\n        uint256 finalizedResponses = _getFinalizedResponsesCount(approvedResponses, optimisticTimePeriod);\n        require(finalizedResponses \u003e= requiredResponses, \"Not enough valid responses to meet the threshold\");\n        return true;\n    }\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedResponses An array of timestamps when each approved response was recorded.\n     * @param optimisticTimePeriod The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses The count of responses that are finalized within the optimistic time period.\n     */\n\n    function _getFinalizedResponsesCount(\n        uint256[] memory approvedResponses,\n        uint256 optimisticTimePeriod\n    )\n    internal\n    view\n    returns (uint256)\n    {\n        uint256 finalizedResponses = 0;\n        for (uint256 i = 0; i \u003c approvedResponses.length; i++) {\n            if (approvedResponses[i] + optimisticTimePeriod \u003c= block.timestamp) {\n                finalizedResponses++;\n            }\n        }\n        return finalizedResponses;\n    }\n    /**\n     * @dev Retrieves the responses from approved modules for a given InterchainEntry.\n     * This function iterates over all approved modules, querying the InterchainDB for each module's response\n     * to the provided InterchainEntry. It compiles these responses into an array of uint256, where each\n     * element represents the timestamp of a module's response.\n     *\n     * @param approvedModules An array of addresses representing the approved modules that can write responses.\n     * @param icEntry The InterchainEntry for which responses are being retrieved.\n     * @return approvedResponses An array of uint256 representing the timestamps of responses from approved modules.\n     */\n\n    function _getApprovedResponses(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry\n    )\n    internal\n    view\n    returns (uint256[] memory)\n    {\n        uint256[] memory approvedResponses = new uint256[](approvedModules.length);\n        for (uint256 i = 0; i \u003c approvedModules.length; i++) {\n            approvedResponses[i] = IInterchainDB(interchainDB).readEntry(approvedModules[i], icEntry);\n        }\n        return approvedResponses;\n    }\n\n    function encodeTransaction(InterchainTransaction memory icTx) public view returns (bytes memory) {\n        return abi.encode(icTx);\n    }\n\n    // TODO: Gas Fee Consideration that is paid to executor\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(bytes calldata transaction) public {\n        require(isExecutable(transaction), \"Transaction is not executable\");\n        InterchainTransaction memory icTx = abi.decode(transaction, (InterchainTransaction));\n        executedTransactions[icTx.transactionId] = true;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: decodedOptions.gasLimit}();\n        emit InterchainTransactionExecuted(\n            icTx.srcSender,\n            icTx.srcChainId,\n            icTx.dstReceiver,\n            icTx.dstChainId,\n            icTx.message,\n            icTx.nonce,\n            icTx.options,\n            icTx.transactionId,\n            icTx.dbWriterNonce\n        );\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"bytes32","name":"existingDataHash","type":"bytes32"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"uint256","name":"writerNonce","type":"uint256"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"newEntry","type":"tuple"}],"name":"InterchainDB__ConflictingEntries","type":"error"},{"inputs":[{"internalType":"address","name":"writer","type":"address"},{"internalType":"uint256","name":"writerNonce","type":"uint256"}],"name":"InterchainDB__EntryDoesNotExist","type":"error"},{"inputs":[{"internalType":"uint256","name":"actualFee","type":"uint256"},{"internalType":"uint256","name":"expectedFee","type":"uint256"}],"name":"InterchainDB__IncorrectFeeAmount","type":"error"},{"inputs":[],"name":"InterchainDB__NoModulesSpecified","type":"error"},{"inputs":[],"name":"InterchainDB__SameChainId","type":"error"},{"inputs":[{"internalType":"address","name":"writer","type":"address"},{"internalType":"uint256","name":"writerNonce","type":"uint256"}],"name":"getEntry","outputs":[{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"uint256","name":"writerNonce","type":"uint256"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"getInterchainFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"writer","type":"address"}],"name":"getWriterNonce","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"dstModule","type":"address"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"uint256","name":"writerNonce","type":"uint256"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"entry","type":"tuple"}],"name":"readEntry","outputs":[{"internalType":"uint256","name":"moduleVerifiedAt","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"internalType":"address","name":"writer","type":"address"},{"internalType":"uint256","name":"writerNonce","type":"uint256"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"requestVerification","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"uint256","name":"writerNonce","type":"uint256"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"entry","type":"tuple"}],"name":"verifyEntry","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"name":"writeEntry","outputs":[{"internalType":"uint256","name":"writerNonce","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"writeEntryWithVerification","outputs":[{"internalType":"uint256","name":"writerNonce","type":"uint256"}],"stateMutability":"payable","type":"function"}],"userDoc":{"kind":"user","methods":{"getEntry(address,uint256)":{"notice":"Get the Interchain Entry by the writer and the writer nonce."},"getInterchainFee(uint256,address[])":{"notice":"Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain using the provided Interchain Modules."},"getWriterNonce(address)":{"notice":"Get the nonce of the writer on this chain."},"readEntry(address,(uint256,bytes32,uint256,bytes32))":{"notice":"Read the data written on specific source chain by a specific writer, and verify it on the destination chain using the provided Interchain Module. Note: returned zero value indicates that the module has not verified the entry."},"requestVerification(uint256,address,uint256,address[])":{"notice":"Request the given Interchain Modules to verify the already written entry on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: this method is permissionless, and anyone can request verification for any entry."},"verifyEntry((uint256,bytes32,uint256,bytes32))":{"notice":"Allows the Interchain Module to verify the entry coming from a remote source chain."},"writeEntry(bytes32)":{"notice":"Write data to the Interchain DataBase as a new entry. Note: there are no guarantees that this entry will be available for reading on any of the remote chains. Use `verifyEntry` to ensure that the entry is available for reading on the destination chain."},"writeEntryWithVerification(uint256,bytes32,address[])":{"notice":"Write data to the Interchain DataBase, and request the given Interchain Modules to verify it on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: additional verification for the same entry could be later done using `requestVerification`."}},"version":1},"developerDoc":{"kind":"dev","methods":{"getEntry(address,uint256)":{"details":"Will revert if the entry with the given nonce does not exist.","params":{"writer":"The address of the writer on this chain","writerNonce":"The nonce of the writer's entry on this chain"}},"getInterchainFee(uint256,address[])":{"details":"Will revert if the empty array of modules is provided.","params":{"destChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"}},"getWriterNonce(address)":{"params":{"writer":"The address of the writer on this chain"}},"readEntry(address,(uint256,bytes32,uint256,bytes32))":{"params":{"dstModule":"The destination chain addresses of the Interchain Modules to use for verification","entry":"The Interchain Entry to read"},"returns":{"moduleVerifiedAt":"  The block timestamp at which the entry was verified by the module,                             or zero if the module has not verified the entry."}},"requestVerification(uint256,address,uint256,address[])":{"details":"Will revert if the entry with the given nonce does not exist.","params":{"destChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification","writer":"The address of the writer on the source chain","writerNonce":"The nonce of the writer on the source chain"}},"verifyEntry((uint256,bytes32,uint256,bytes32))":{"params":{"entry":"The Interchain Entry to confirm"}},"writeEntry(bytes32)":{"params":{"dataHash":"The hash of the data to be written to the Interchain DataBase as a new entry"},"returns":{"writerNonce":"The writer-specific nonce of the written entry"}},"writeEntryWithVerification(uint256,bytes32,address[])":{"details":"Will revert if the empty array of modules is provided.","params":{"dataHash":"The hash of the data to be written to the Interchain DataBase as a new entry","destChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"},"returns":{"writerNonce":"The writer-specific nonce of the written entry"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"existingDataHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"newEntry\",\"type\":\"tuple\"}],\"name\":\"InterchainDB__ConflictingEntries\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"writer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__EntryDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actualFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedFee\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__IncorrectFeeAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainDB__NoModulesSpecified\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainDB__SameChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"writer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"}],\"name\":\"getEntry\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"getInterchainFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"writer\",\"type\":\"address\"}],\"name\":\"getWriterNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dstModule\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"entry\",\"type\":\"tuple\"}],\"name\":\"readEntry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"moduleVerifiedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"writer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"requestVerification\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"entry\",\"type\":\"tuple\"}],\"name\":\"verifyEntry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"writeEntry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"writeEntryWithVerification\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getEntry(address,uint256)\":{\"details\":\"Will revert if the entry with the given nonce does not exist.\",\"params\":{\"writer\":\"The address of the writer on this chain\",\"writerNonce\":\"The nonce of the writer's entry on this chain\"}},\"getInterchainFee(uint256,address[])\":{\"details\":\"Will revert if the empty array of modules is provided.\",\"params\":{\"destChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"}},\"getWriterNonce(address)\":{\"params\":{\"writer\":\"The address of the writer on this chain\"}},\"readEntry(address,(uint256,bytes32,uint256,bytes32))\":{\"params\":{\"dstModule\":\"The destination chain addresses of the Interchain Modules to use for verification\",\"entry\":\"The Interchain Entry to read\"},\"returns\":{\"moduleVerifiedAt\":\"  The block timestamp at which the entry was verified by the module,                             or zero if the module has not verified the entry.\"}},\"requestVerification(uint256,address,uint256,address[])\":{\"details\":\"Will revert if the entry with the given nonce does not exist.\",\"params\":{\"destChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\",\"writer\":\"The address of the writer on the source chain\",\"writerNonce\":\"The nonce of the writer on the source chain\"}},\"verifyEntry((uint256,bytes32,uint256,bytes32))\":{\"params\":{\"entry\":\"The Interchain Entry to confirm\"}},\"writeEntry(bytes32)\":{\"params\":{\"dataHash\":\"The hash of the data to be written to the Interchain DataBase as a new entry\"},\"returns\":{\"writerNonce\":\"The writer-specific nonce of the written entry\"}},\"writeEntryWithVerification(uint256,bytes32,address[])\":{\"details\":\"Will revert if the empty array of modules is provided.\",\"params\":{\"dataHash\":\"The hash of the data to be written to the Interchain DataBase as a new entry\",\"destChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"},\"returns\":{\"writerNonce\":\"The writer-specific nonce of the written entry\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getEntry(address,uint256)\":{\"notice\":\"Get the Interchain Entry by the writer and the writer nonce.\"},\"getInterchainFee(uint256,address[])\":{\"notice\":\"Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain using the provided Interchain Modules.\"},\"getWriterNonce(address)\":{\"notice\":\"Get the nonce of the writer on this chain.\"},\"readEntry(address,(uint256,bytes32,uint256,bytes32))\":{\"notice\":\"Read the data written on specific source chain by a specific writer, and verify it on the destination chain using the provided Interchain Module. Note: returned zero value indicates that the module has not verified the entry.\"},\"requestVerification(uint256,address,uint256,address[])\":{\"notice\":\"Request the given Interchain Modules to verify the already written entry on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: this method is permissionless, and anyone can request verification for any entry.\"},\"verifyEntry((uint256,bytes32,uint256,bytes32))\":{\"notice\":\"Allows the Interchain Module to verify the entry coming from a remote source chain.\"},\"writeEntry(bytes32)\":{\"notice\":\"Write data to the Interchain DataBase as a new entry. Note: there are no guarantees that this entry will be available for reading on any of the remote chains. Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\"},\"writeEntryWithVerification(uint256,bytes32,address[])\":{\"notice\":\"Write data to the Interchain DataBase, and request the given Interchain Modules to verify it on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: additional verification for the same entry could be later done using `requestVerification`.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"IInterchainDB\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0x44c9e0bf0e33c29df6b63f8909747984d3ad8c376a763f57eaa613086c22bb2c\",\"urls\":[\"bzz-raw://f5ad81ebeb36f44c014dbf8fe28dc9747b29eea33cc2d37a5d245fdbb1ef06f8\",\"dweb:/ipfs/QmW4JUaEBdaochJpLMphHqqu1WUrYxjESNET4HciC2jXtX\"]}},\"version\":1}"},"hashes":{"getEntry(address,uint256)":"b8a740e0","getInterchainFee(uint256,address[])":"fc7686ec","getWriterNonce(address)":"4a30a686","readEntry(address,(uint256,bytes32,uint256,bytes32))":"d48588e0","requestVerification(uint256,address,uint256,address[])":"b4f16bae","verifyEntry((uint256,bytes32,uint256,bytes32))":"9cbc6dd5","writeEntry(bytes32)":"2ad8c706","writeEntryWithVerification(uint256,bytes32,address[])":"67c769af"}},"solidity/InterchainClientV1.sol:InterchainClientV1":{"code":"0x608060405234801561001057600080fd5b50338061003757604051631e4fbdf760e01b81526000600482015260240160405180910390fd5b61004081610046565b50610096565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b61192a806100a56000396000f3fe6080604052600436106100d25760003560e01c8063715018a61161007f5780638da5cb5b116100595780638da5cb5b14610292578063b7ce2078146102bd578063f2fde38b146102dd578063f34234c8146102fd57600080fd5b8063715018a6146102125780637268b08f146102275780638691d34c1461026257600080fd5b806331afa7de116100b057806331afa7de146101a2578063521011a9146101d257806358865d18146101e557600080fd5b8063074c17b4146100d75780630d898416146100f95780630e785ce014610150575b600080fd5b3480156100e357600080fd5b506100f76100f2366004611013565b61031d565b005b34801561010557600080fd5b506000546101329074010000000000000000000000000000000000000000900467ffffffffffffffff1681565b60405167ffffffffffffffff90911681526020015b60405180910390f35b34801561015c57600080fd5b5060015461017d9073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610147565b3480156101ae57600080fd5b506101c26101bd366004611013565b6104cf565b6040519015158152602001610147565b6100f76101e0366004611055565b610721565b3480156101f157600080fd5b5061020561020036600461129c565b6109ad565b60405161014791906113ec565b34801561021e57600080fd5b506100f76109d6565b34801561023357600080fd5b50610254610242366004611406565b60036020526000908152604090205481565b604051908152602001610147565b34801561026e57600080fd5b506101c261027d366004611406565b60026020526000908152604090205460ff1681565b34801561029e57600080fd5b5060005473ffffffffffffffffffffffffffffffffffffffff1661017d565b3480156102c957600080fd5b506100f76102d8366004611441565b6109ea565b3480156102e957600080fd5b506100f76102f8366004611441565b610a39565b34801561030957600080fd5b506100f761031836600461145e565b610a9d565b61032782826104cf565b610392576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f5472616e73616374696f6e206973206e6f742065786563757461626c6500000060448201526064015b60405180910390fd5b60006103a08284018461129c565b60e0810151600090815260026020526040812080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016600117905560c0820151919250906103ee90610ab7565b90506103fb826040015190565b73ffffffffffffffffffffffffffffffffffffffff16637bcad63082600001516040518263ffffffff1660e01b8152600401600060405180830381600088803b15801561044757600080fd5b5087f115801561045b573d6000803e3d6000fd5b50505050508160e00151826020015183600001517f8f5bf42a756e7d14bf3253830829fc4add2b2563a8b76396ee807515d1f1f5418560400151866060015187608001518860a001518960c001518a61010001516040516104c196959493929190611480565b60405180910390a450505050565b6000806104de8385018561129c565b60e081015160009081526002602052604090205490915060ff161561055f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f5472616e73616374696f6e20616c7265616479206578656375746564000000006044820152606401610389565b6000604051806080016040528083602001518152602001600360008560200151815260200190815260200160002054815260200183610100015181526020018360e00151815250905060006105d5836000015184602001518560400151866060015187608001518860a001518960c00151610b3b565b9050808360e0015114610644576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f496e76616c6964207472616e73616374696f6e204944000000000000000000006044820152606401610389565b600080600061065c610657876040015190565b610b7d565b925092509250600061066e8287610d07565b9050600061067c8285610e87565b90508481101561070e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603060248201527f4e6f7420656e6f7567682076616c696420726573706f6e73657320746f206d6560448201527f657420746865207468726573686f6c64000000000000000000000000000000006064820152608401610389565b6001985050505050505050505b92915050565b6040805161012081019091523490600090803381526020014681526020018b81526020018a815260200189898080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201829052509385525050905474010000000000000000000000000000000000000000900467ffffffffffffffff1660208084019190915260408051601f8b0183900483028101830182528a815293019291508990899081908401838280828437600092018290525093855250505060208083018290526040928301829052835190840151928401516060850151608086015160a087015160c0880151979850949661082596949590610b3b565b60e0830181905260015460608401516040517f67c769af00000000000000000000000000000000000000000000000000000000815292935060009273ffffffffffffffffffffffffffffffffffffffff909216916367c769af918791610894919087908c908c906004016114d5565b60206040518083038185885af11580156108b2573d6000803e3d6000fd5b50505050506040513d601f19601f820116820180604052508101906108d79190611541565b610100840181905260e084015160608501516040808701518751602089015160808a015160a08b015160c08c015195519899509697959693957f42174f9fd1c22d8fb303dabbccbb7a9bf53aaa47463d904e6172b5d14c1b45239561093e95918b90611480565b60405180910390a46000805474010000000000000000000000000000000000000000900467ffffffffffffffff1690601461097883611589565b91906101000a81548167ffffffffffffffff021916908367ffffffffffffffff16021790555050505050505050505050505050565b6060816040516020016109c091906115b0565b6040516020818303038152906040529050919050565b6109de610ee0565b6109e86000610f33565b565b6109f2610ee0565b600180547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b610a41610ee0565b73ffffffffffffffffffffffffffffffffffffffff8116610a91576040517f1e4fbdf700000000000000000000000000000000000000000000000000000000815260006004820152602401610389565b610a9a81610f33565b50565b610aa5610ee0565b60009182526003602052604090912055565b6040805180820190915260008082526020820152600080610ad784610fa8565b9092509050600160ff83161015610b1f576040517fbd91a21500000000000000000000000000000000000000000000000000000000815260ff83166004820152602401610389565b80806020019051810190610b33919061166e565b949350505050565b600087878787878787604051602001610b5a97969594939291906116bd565b604051602081830303815290604052805190602001209050979650505050505050565b60008060608373ffffffffffffffffffffffffffffffffffffffff1663f31b19a96040518163ffffffff1660e01b8152600401602060405180830381865afa158015610bcd573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bf19190611541565b92508373ffffffffffffffffffffffffffffffffffffffff16637c9abd3e6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610c3e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c629190611718565b67ffffffffffffffff1691508373ffffffffffffffffffffffffffffffffffffffff1663a45e107a6040518163ffffffff1660e01b8152600401600060405180830381865afa158015610cb9573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201604052610cff9190810190611735565b929491935050565b60606000835167ffffffffffffffff811115610d2557610d25611132565b604051908082528060200260200182016040528015610d4e578160200160208202803683370190505b50905060005b8451811015610e7f57600154855173ffffffffffffffffffffffffffffffffffffffff9091169063d48588e090879084908110610d9357610d936117e7565b602090810291909101810151604080517fffffffff0000000000000000000000000000000000000000000000000000000060e086901b16815273ffffffffffffffffffffffffffffffffffffffff9092166004830152885160248301529188015160448201529087015160648201526060870151608482015260a401602060405180830381865afa158015610e2c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e509190611541565b828281518110610e6257610e626117e7565b602090810291909101015280610e7781611816565b915050610d54565b509392505050565b600080805b8451811015610e7f574284868381518110610ea957610ea96117e7565b6020026020010151610ebb919061184e565b11610ece5781610eca81611816565b9250505b80610ed881611816565b915050610e8c565b60005473ffffffffffffffffffffffffffffffffffffffff1633146109e8576040517f118cdaa7000000000000000000000000000000000000000000000000000000008152336004820152602401610389565b6000805473ffffffffffffffffffffffffffffffffffffffff8381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6000606082806020019051810190610fc09190611861565b9094909350915050565b60008083601f840112610fdc57600080fd5b50813567ffffffffffffffff811115610ff457600080fd5b60208301915083602082850101111561100c57600080fd5b9250929050565b6000806020838503121561102657600080fd5b823567ffffffffffffffff81111561103d57600080fd5b61104985828601610fca565b90969095509350505050565b60008060008060008060008060a0898b03121561107157600080fd5b8835975060208901359650604089013567ffffffffffffffff8082111561109757600080fd5b6110a38c838d01610fca565b909850965060608b01359150808211156110bc57600080fd5b6110c88c838d01610fca565b909650945060808b01359150808211156110e157600080fd5b818b0191508b601f8301126110f557600080fd5b81358181111561110457600080fd5b8c60208260051b850101111561111957600080fd5b6020830194508093505050509295985092959890939650565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051610120810167ffffffffffffffff8111828210171561118557611185611132565b60405290565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff811182821017156111d2576111d2611132565b604052919050565b600067ffffffffffffffff8211156111f4576111f4611132565b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b600082601f83011261123157600080fd5b813561124461123f826111da565b61118b565b81815284602083860101111561125957600080fd5b816020850160208301376000918101602001919091529392505050565b67ffffffffffffffff81168114610a9a57600080fd5b803561129781611276565b919050565b6000602082840312156112ae57600080fd5b813567ffffffffffffffff808211156112c657600080fd5b9083019061012082860312156112db57600080fd5b6112e3611161565b8235815260208301356020820152604083013560408201526060830135606082015260808301358281111561131757600080fd5b61132387828601611220565b60808301525061133560a0840161128c565b60a082015260c08301358281111561134c57600080fd5b61135887828601611220565b60c08301525060e083810135908201526101009283013592810192909252509392505050565b60005b83811015611399578181015183820152602001611381565b50506000910152565b600081518084526113ba81602086016020860161137e565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6020815260006113ff60208301846113a2565b9392505050565b60006020828403121561141857600080fd5b5035919050565b73ffffffffffffffffffffffffffffffffffffffff81168114610a9a57600080fd5b60006020828403121561145357600080fd5b81356113ff8161141f565b6000806040838503121561147157600080fd5b50508035926020909101359150565b86815285602082015260c06040820152600061149f60c08301876113a2565b67ffffffffffffffff8616606084015282810360808401526114c181866113a2565b9150508260a0830152979650505050505050565b84815260208082018590526060604083018190528201839052600090849060808401835b8681101561153457833561150c8161141f565b73ffffffffffffffffffffffffffffffffffffffff16825292820192908201906001016114f9565b5098975050505050505050565b60006020828403121561155357600080fd5b5051919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600067ffffffffffffffff8083168181036115a6576115a661155a565b6001019392505050565b6020815281516020820152602082015160408201526040820151606082015260608201516080820152600060808301516101208060a08501526115f76101408501836113a2565b915060a085015161161460c086018267ffffffffffffffff169052565b5060c08501517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08584030160e086015261164e83826113a2565b60e087015161010087810191909152909601519190940152509192915050565b60006040828403121561168057600080fd5b6040516040810181811067ffffffffffffffff821117156116a3576116a3611132565b604052825181526020928301519281019290925250919050565b87815286602082015285604082015284606082015260e0608082015260006116e860e08301866113a2565b67ffffffffffffffff851660a084015282810360c084015261170a81856113a2565b9a9950505050505050505050565b60006020828403121561172a57600080fd5b81516113ff81611276565b6000602080838503121561174857600080fd5b825167ffffffffffffffff8082111561176057600080fd5b818501915085601f83011261177457600080fd5b81518181111561178657611786611132565b8060051b915061179784830161118b565b81815291830184019184810190888411156117b157600080fd5b938501935b838510156117db57845192506117cb8361141f565b82825293850193908501906117b6565b98975050505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036118475761184761155a565b5060010190565b8082018082111561071b5761071b61155a565b6000806040838503121561187457600080fd5b825160ff8116811461188557600080fd5b602084015190925067ffffffffffffffff8111156118a257600080fd5b8301601f810185136118b357600080fd5b80516118c161123f826111da565b8181528660208385010111156118d657600080fd5b6118e782602083016020860161137e565b809350505050925092905056fea2646970667358221220974efed71277f00142414b84a59c1cc5fd10133ea6e134b2c4ccdbadd8bd2cb964736f6c63430008140033","runtime-code":"0x6080604052600436106100d25760003560e01c8063715018a61161007f5780638da5cb5b116100595780638da5cb5b14610292578063b7ce2078146102bd578063f2fde38b146102dd578063f34234c8146102fd57600080fd5b8063715018a6146102125780637268b08f146102275780638691d34c1461026257600080fd5b806331afa7de116100b057806331afa7de146101a2578063521011a9146101d257806358865d18146101e557600080fd5b8063074c17b4146100d75780630d898416146100f95780630e785ce014610150575b600080fd5b3480156100e357600080fd5b506100f76100f2366004611013565b61031d565b005b34801561010557600080fd5b506000546101329074010000000000000000000000000000000000000000900467ffffffffffffffff1681565b60405167ffffffffffffffff90911681526020015b60405180910390f35b34801561015c57600080fd5b5060015461017d9073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610147565b3480156101ae57600080fd5b506101c26101bd366004611013565b6104cf565b6040519015158152602001610147565b6100f76101e0366004611055565b610721565b3480156101f157600080fd5b5061020561020036600461129c565b6109ad565b60405161014791906113ec565b34801561021e57600080fd5b506100f76109d6565b34801561023357600080fd5b50610254610242366004611406565b60036020526000908152604090205481565b604051908152602001610147565b34801561026e57600080fd5b506101c261027d366004611406565b60026020526000908152604090205460ff1681565b34801561029e57600080fd5b5060005473ffffffffffffffffffffffffffffffffffffffff1661017d565b3480156102c957600080fd5b506100f76102d8366004611441565b6109ea565b3480156102e957600080fd5b506100f76102f8366004611441565b610a39565b34801561030957600080fd5b506100f761031836600461145e565b610a9d565b61032782826104cf565b610392576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f5472616e73616374696f6e206973206e6f742065786563757461626c6500000060448201526064015b60405180910390fd5b60006103a08284018461129c565b60e0810151600090815260026020526040812080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016600117905560c0820151919250906103ee90610ab7565b90506103fb826040015190565b73ffffffffffffffffffffffffffffffffffffffff16637bcad63082600001516040518263ffffffff1660e01b8152600401600060405180830381600088803b15801561044757600080fd5b5087f115801561045b573d6000803e3d6000fd5b50505050508160e00151826020015183600001517f8f5bf42a756e7d14bf3253830829fc4add2b2563a8b76396ee807515d1f1f5418560400151866060015187608001518860a001518960c001518a61010001516040516104c196959493929190611480565b60405180910390a450505050565b6000806104de8385018561129c565b60e081015160009081526002602052604090205490915060ff161561055f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f5472616e73616374696f6e20616c7265616479206578656375746564000000006044820152606401610389565b6000604051806080016040528083602001518152602001600360008560200151815260200190815260200160002054815260200183610100015181526020018360e00151815250905060006105d5836000015184602001518560400151866060015187608001518860a001518960c00151610b3b565b9050808360e0015114610644576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f496e76616c6964207472616e73616374696f6e204944000000000000000000006044820152606401610389565b600080600061065c610657876040015190565b610b7d565b925092509250600061066e8287610d07565b9050600061067c8285610e87565b90508481101561070e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603060248201527f4e6f7420656e6f7567682076616c696420726573706f6e73657320746f206d6560448201527f657420746865207468726573686f6c64000000000000000000000000000000006064820152608401610389565b6001985050505050505050505b92915050565b6040805161012081019091523490600090803381526020014681526020018b81526020018a815260200189898080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201829052509385525050905474010000000000000000000000000000000000000000900467ffffffffffffffff1660208084019190915260408051601f8b0183900483028101830182528a815293019291508990899081908401838280828437600092018290525093855250505060208083018290526040928301829052835190840151928401516060850151608086015160a087015160c0880151979850949661082596949590610b3b565b60e0830181905260015460608401516040517f67c769af00000000000000000000000000000000000000000000000000000000815292935060009273ffffffffffffffffffffffffffffffffffffffff909216916367c769af918791610894919087908c908c906004016114d5565b60206040518083038185885af11580156108b2573d6000803e3d6000fd5b50505050506040513d601f19601f820116820180604052508101906108d79190611541565b610100840181905260e084015160608501516040808701518751602089015160808a015160a08b015160c08c015195519899509697959693957f42174f9fd1c22d8fb303dabbccbb7a9bf53aaa47463d904e6172b5d14c1b45239561093e95918b90611480565b60405180910390a46000805474010000000000000000000000000000000000000000900467ffffffffffffffff1690601461097883611589565b91906101000a81548167ffffffffffffffff021916908367ffffffffffffffff16021790555050505050505050505050505050565b6060816040516020016109c091906115b0565b6040516020818303038152906040529050919050565b6109de610ee0565b6109e86000610f33565b565b6109f2610ee0565b600180547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b610a41610ee0565b73ffffffffffffffffffffffffffffffffffffffff8116610a91576040517f1e4fbdf700000000000000000000000000000000000000000000000000000000815260006004820152602401610389565b610a9a81610f33565b50565b610aa5610ee0565b60009182526003602052604090912055565b6040805180820190915260008082526020820152600080610ad784610fa8565b9092509050600160ff83161015610b1f576040517fbd91a21500000000000000000000000000000000000000000000000000000000815260ff83166004820152602401610389565b80806020019051810190610b33919061166e565b949350505050565b600087878787878787604051602001610b5a97969594939291906116bd565b604051602081830303815290604052805190602001209050979650505050505050565b60008060608373ffffffffffffffffffffffffffffffffffffffff1663f31b19a96040518163ffffffff1660e01b8152600401602060405180830381865afa158015610bcd573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bf19190611541565b92508373ffffffffffffffffffffffffffffffffffffffff16637c9abd3e6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610c3e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c629190611718565b67ffffffffffffffff1691508373ffffffffffffffffffffffffffffffffffffffff1663a45e107a6040518163ffffffff1660e01b8152600401600060405180830381865afa158015610cb9573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201604052610cff9190810190611735565b929491935050565b60606000835167ffffffffffffffff811115610d2557610d25611132565b604051908082528060200260200182016040528015610d4e578160200160208202803683370190505b50905060005b8451811015610e7f57600154855173ffffffffffffffffffffffffffffffffffffffff9091169063d48588e090879084908110610d9357610d936117e7565b602090810291909101810151604080517fffffffff0000000000000000000000000000000000000000000000000000000060e086901b16815273ffffffffffffffffffffffffffffffffffffffff9092166004830152885160248301529188015160448201529087015160648201526060870151608482015260a401602060405180830381865afa158015610e2c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e509190611541565b828281518110610e6257610e626117e7565b602090810291909101015280610e7781611816565b915050610d54565b509392505050565b600080805b8451811015610e7f574284868381518110610ea957610ea96117e7565b6020026020010151610ebb919061184e565b11610ece5781610eca81611816565b9250505b80610ed881611816565b915050610e8c565b60005473ffffffffffffffffffffffffffffffffffffffff1633146109e8576040517f118cdaa7000000000000000000000000000000000000000000000000000000008152336004820152602401610389565b6000805473ffffffffffffffffffffffffffffffffffffffff8381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6000606082806020019051810190610fc09190611861565b9094909350915050565b60008083601f840112610fdc57600080fd5b50813567ffffffffffffffff811115610ff457600080fd5b60208301915083602082850101111561100c57600080fd5b9250929050565b6000806020838503121561102657600080fd5b823567ffffffffffffffff81111561103d57600080fd5b61104985828601610fca565b90969095509350505050565b60008060008060008060008060a0898b03121561107157600080fd5b8835975060208901359650604089013567ffffffffffffffff8082111561109757600080fd5b6110a38c838d01610fca565b909850965060608b01359150808211156110bc57600080fd5b6110c88c838d01610fca565b909650945060808b01359150808211156110e157600080fd5b818b0191508b601f8301126110f557600080fd5b81358181111561110457600080fd5b8c60208260051b850101111561111957600080fd5b6020830194508093505050509295985092959890939650565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051610120810167ffffffffffffffff8111828210171561118557611185611132565b60405290565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff811182821017156111d2576111d2611132565b604052919050565b600067ffffffffffffffff8211156111f4576111f4611132565b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b600082601f83011261123157600080fd5b813561124461123f826111da565b61118b565b81815284602083860101111561125957600080fd5b816020850160208301376000918101602001919091529392505050565b67ffffffffffffffff81168114610a9a57600080fd5b803561129781611276565b919050565b6000602082840312156112ae57600080fd5b813567ffffffffffffffff808211156112c657600080fd5b9083019061012082860312156112db57600080fd5b6112e3611161565b8235815260208301356020820152604083013560408201526060830135606082015260808301358281111561131757600080fd5b61132387828601611220565b60808301525061133560a0840161128c565b60a082015260c08301358281111561134c57600080fd5b61135887828601611220565b60c08301525060e083810135908201526101009283013592810192909252509392505050565b60005b83811015611399578181015183820152602001611381565b50506000910152565b600081518084526113ba81602086016020860161137e565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6020815260006113ff60208301846113a2565b9392505050565b60006020828403121561141857600080fd5b5035919050565b73ffffffffffffffffffffffffffffffffffffffff81168114610a9a57600080fd5b60006020828403121561145357600080fd5b81356113ff8161141f565b6000806040838503121561147157600080fd5b50508035926020909101359150565b86815285602082015260c06040820152600061149f60c08301876113a2565b67ffffffffffffffff8616606084015282810360808401526114c181866113a2565b9150508260a0830152979650505050505050565b84815260208082018590526060604083018190528201839052600090849060808401835b8681101561153457833561150c8161141f565b73ffffffffffffffffffffffffffffffffffffffff16825292820192908201906001016114f9565b5098975050505050505050565b60006020828403121561155357600080fd5b5051919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600067ffffffffffffffff8083168181036115a6576115a661155a565b6001019392505050565b6020815281516020820152602082015160408201526040820151606082015260608201516080820152600060808301516101208060a08501526115f76101408501836113a2565b915060a085015161161460c086018267ffffffffffffffff169052565b5060c08501517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08584030160e086015261164e83826113a2565b60e087015161010087810191909152909601519190940152509192915050565b60006040828403121561168057600080fd5b6040516040810181811067ffffffffffffffff821117156116a3576116a3611132565b604052825181526020928301519281019290925250919050565b87815286602082015285604082015284606082015260e0608082015260006116e860e08301866113a2565b67ffffffffffffffff851660a084015282810360c084015261170a81856113a2565b9a9950505050505050505050565b60006020828403121561172a57600080fd5b81516113ff81611276565b6000602080838503121561174857600080fd5b825167ffffffffffffffff8082111561176057600080fd5b818501915085601f83011261177457600080fd5b81518181111561178657611786611132565b8060051b915061179784830161118b565b81815291830184019184810190888411156117b157600080fd5b938501935b838510156117db57845192506117cb8361141f565b82825293850193908501906117b6565b98975050505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036118475761184761155a565b5060010190565b8082018082111561071b5761071b61155a565b6000806040838503121561187457600080fd5b825160ff8116811461188557600080fd5b602084015190925067ffffffffffffffff8111156118a257600080fd5b8301601f810185136118b357600080fd5b80516118c161123f826111da565b8181528660208385010111156118d657600080fd5b6118e782602083016020860161137e565b809350505050925092905056fea2646970667358221220974efed71277f00142414b84a59c1cc5fd10133ea6e134b2c4ccdbadd8bd2cb964736f6c63430008140033","info":{"source":"pragma solidity 0.8.20;\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n/// @notice Struct representing an entry in the Interchain DataBase\n/// @param srcChainId   The chain id of the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param writerNonce  The nonce of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    bytes32 srcWriter;\n    uint256 writerNonce;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param srcWriter    The address of the writer on the local chain\n    /// @param writerNonce  The nonce of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        address srcWriter,\n        uint256 writerNonce,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            srcWriter: TypeCasts.addressToBytes32(srcWriter),\n            writerNonce: writerNonce,\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryId(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.srcWriter, entry.writerNonce));\n    }\n}\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param dataHash     The hash of the data written on the source chain\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 dataHash;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingDataHash, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(address writer, uint256 writerNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntry(bytes32 dataHash) external returns (uint256 writerNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param writer        The address of the writer on the source chain\n    /// @param writerNonce   The nonce of the writer on the source chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(\n        uint256 destChainId,\n        address writer,\n        uint256 writerNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 writerNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param writer       The address of the writer on this chain\n    /// @param writerNonce  The nonce of the writer's entry on this chain\n    function getEntry(address writer, uint256 writerNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the writer on this chain.\n    /// @param writer       The address of the writer on this chain\n    function getWriterNonce(address writer) external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\ninterface IInterchainApp {\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory sendingModules,\n        address[] memory receivingModules,\n        uint256 requiredResponses,\n        uint64 optimisticTimePeriod\n    )\n        external;\n\n    function getLinkedIApp(uint64 chainID) external view returns (address);\n\n    function getSendingModules() external view returns (address[] memory);\n\n    function getReceivingModules() external view returns (address[] memory);\n\n    function getRequiredResponses() external view returns (uint256);\n\n    function getOptimisticTimePeriod() external view returns (uint64);\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable;\n\n    function appReceive() external;\n}\n\ninterface IInterchainClientV1 {\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sets the address of the InterchainDB contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param _interchainDB The address of the InterchainDB contract.\n     */\n    function setInterchainDB(address _interchainDB) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param message The message being sent.\n     * @param options Execution options for the message sent, encoded as bytes, currently primarily gas limit + native gas drop.\n     * @param srcModules The source modules involved in the message sending.\n     */\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        bytes calldata options,\n        address[] calldata srcModules\n    )\n        external\n        payable;\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * @param transaction The transaction data.\n     */\n    function interchainExecute(bytes calldata transaction) external;\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction The InterchainTransaction struct to be checked.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction) external view returns (bool);\n}\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    uint8 constant OPTIONS_V1 = 1;\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, IInterchainClientV1 {\n    using OptionsLib for bytes;\n\n    uint64 public clientNonce;\n    address public interchainDB;\n    mapping(bytes32 =\u003e bool) public executedTransactions;\n\n    // Chain ID =\u003e Bytes32 Address of src clients\n    mapping(uint256 =\u003e bytes32) public linkedClients;\n\n    // TODO: Add permissioning\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint256 chainId, bytes32 client) public onlyOwner {\n        linkedClients[chainId] = client;\n    }\n\n    constructor() Ownable(msg.sender) {}\n\n    // @inheritdoc IInterchainClientV1\n    function setInterchainDB(address _interchainDB) public onlyOwner {\n        interchainDB = _interchainDB;\n    }\n\n    /**\n     * @notice Emitted when an interchain transaction is sent.\n     */\n    event InterchainTransactionSent(\n        bytes32 srcSender,\n        uint256 srcChainId,\n        bytes32 indexed dstReceiver,\n        uint256 indexed dstChainId,\n        bytes message,\n        uint64 nonce,\n        bytes options,\n        bytes32 indexed transactionId,\n        uint256 dbWriterNonce\n    );\n\n    // @notice Emitted when an interchain transaction is executed.\n    // TODO: Indexing\n    event InterchainTransactionExecuted(\n        bytes32 indexed srcSender,\n        uint256 indexed srcChainId,\n        bytes32 dstReceiver,\n        uint256 dstChainId,\n        bytes message,\n        uint64 nonce,\n        bytes options,\n        bytes32 indexed transactionId,\n        uint256 dbWriterNonce\n    );\n\n    /**\n     * @dev Represents an interchain transaction.\n     */\n    struct InterchainTransaction {\n        bytes32 srcSender;\n        uint256 srcChainId;\n        bytes32 dstReceiver;\n        uint256 dstChainId;\n        bytes message;\n        uint64 nonce;\n        bytes options;\n        bytes32 transactionId;\n        uint256 dbWriterNonce;\n    }\n\n    function _generateTransactionId(\n        bytes32 srcSender,\n        uint256 srcChainId,\n        bytes32 dstReceiver,\n        uint256 dstChainId,\n        bytes memory message,\n        uint64 nonce,\n        bytes memory options\n    )\n    internal\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encode(srcSender, srcChainId, dstReceiver, dstChainId, message, nonce, options));\n    }\n\n    // TODO: Calculate Gas Pricing per module and charge fees\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        bytes calldata options,\n        address[] calldata srcModules\n    )\n    public\n    payable\n    {\n        uint256 totalModuleFees = msg.value;\n\n        InterchainTransaction memory icTx = InterchainTransaction({\n            srcSender: TypeCasts.addressToBytes32(msg.sender),\n            srcChainId: block.chainid,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            message: message,\n            nonce: clientNonce,\n            options: options,\n            transactionId: 0,\n            dbWriterNonce: 0\n        });\n\n        bytes32 transactionId = _generateTransactionId(\n            icTx.srcSender, icTx.srcChainId, icTx.dstReceiver, icTx.dstChainId, icTx.message, icTx.nonce, icTx.options\n        );\n        icTx.transactionId = transactionId;\n\n        uint256 dbWriterNonce = IInterchainDB(interchainDB).writeEntryWithVerification{value: totalModuleFees}(\n            icTx.dstChainId, icTx.transactionId, srcModules\n        );\n        icTx.dbWriterNonce = dbWriterNonce;\n\n        emit InterchainTransactionSent(\n            icTx.srcSender,\n            icTx.srcChainId,\n            icTx.dstReceiver,\n            icTx.dstChainId,\n            icTx.message,\n            icTx.nonce,\n            icTx.options,\n            icTx.transactionId,\n            icTx.dbWriterNonce\n        );\n        // Increment nonce for next message\n        clientNonce++;\n    }\n\n    // TODO: App Config Versioning\n    // TODO: What if receiver is not a contract / doesn't conform to interface?\n    /**\n     * @dev Retrieves the application configuration for a given receiver application.\n     * @param receiverApp The address of the receiver application.\n     * @return requiredResponses The number of required responses from the receiving modules.\n     * @return optimisticTimePeriod The time period within which responses are considered valid.\n     * @return approvedDstModules An array of addresses of the approved destination modules.\n     */\n    function _getAppConfig(address receiverApp)\n    internal\n    view\n    returns (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules)\n    {\n        requiredResponses = IInterchainApp(receiverApp).getRequiredResponses();\n        optimisticTimePeriod = IInterchainApp(receiverApp).getOptimisticTimePeriod();\n        approvedDstModules = IInterchainApp(receiverApp).getReceivingModules();\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata transaction) public view returns (bool) {\n        InterchainTransaction memory icTx = abi.decode(transaction, (InterchainTransaction));\n        require(executedTransactions[icTx.transactionId] == false, \"Transaction already executed\");\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            srcWriter: linkedClients[icTx.srcChainId],\n            writerNonce: icTx.dbWriterNonce,\n            dataHash: icTx.transactionId\n        });\n\n        bytes32 reconstructedID = _generateTransactionId(\n            icTx.srcSender, icTx.srcChainId, icTx.dstReceiver, icTx.dstChainId, icTx.message, icTx.nonce, icTx.options\n        );\n\n        require(icTx.transactionId == reconstructedID, \"Invalid transaction ID\");\n\n        (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules) =\n                        _getAppConfig(TypeCasts.bytes32ToAddress(icTx.dstReceiver));\n\n        uint256[] memory approvedResponses = _getApprovedResponses(approvedDstModules, icEntry);\n\n        uint256 finalizedResponses = _getFinalizedResponsesCount(approvedResponses, optimisticTimePeriod);\n        require(finalizedResponses \u003e= requiredResponses, \"Not enough valid responses to meet the threshold\");\n        return true;\n    }\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedResponses An array of timestamps when each approved response was recorded.\n     * @param optimisticTimePeriod The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses The count of responses that are finalized within the optimistic time period.\n     */\n\n    function _getFinalizedResponsesCount(\n        uint256[] memory approvedResponses,\n        uint256 optimisticTimePeriod\n    )\n    internal\n    view\n    returns (uint256)\n    {\n        uint256 finalizedResponses = 0;\n        for (uint256 i = 0; i \u003c approvedResponses.length; i++) {\n            if (approvedResponses[i] + optimisticTimePeriod \u003c= block.timestamp) {\n                finalizedResponses++;\n            }\n        }\n        return finalizedResponses;\n    }\n    /**\n     * @dev Retrieves the responses from approved modules for a given InterchainEntry.\n     * This function iterates over all approved modules, querying the InterchainDB for each module's response\n     * to the provided InterchainEntry. It compiles these responses into an array of uint256, where each\n     * element represents the timestamp of a module's response.\n     *\n     * @param approvedModules An array of addresses representing the approved modules that can write responses.\n     * @param icEntry The InterchainEntry for which responses are being retrieved.\n     * @return approvedResponses An array of uint256 representing the timestamps of responses from approved modules.\n     */\n\n    function _getApprovedResponses(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry\n    )\n    internal\n    view\n    returns (uint256[] memory)\n    {\n        uint256[] memory approvedResponses = new uint256[](approvedModules.length);\n        for (uint256 i = 0; i \u003c approvedModules.length; i++) {\n            approvedResponses[i] = IInterchainDB(interchainDB).readEntry(approvedModules[i], icEntry);\n        }\n        return approvedResponses;\n    }\n\n    function encodeTransaction(InterchainTransaction memory icTx) public view returns (bytes memory) {\n        return abi.encode(icTx);\n    }\n\n    // TODO: Gas Fee Consideration that is paid to executor\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(bytes calldata transaction) public {\n        require(isExecutable(transaction), \"Transaction is not executable\");\n        InterchainTransaction memory icTx = abi.decode(transaction, (InterchainTransaction));\n        executedTransactions[icTx.transactionId] = true;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: decodedOptions.gasLimit}();\n        emit InterchainTransactionExecuted(\n            icTx.srcSender,\n            icTx.srcChainId,\n            icTx.dstReceiver,\n            icTx.dstChainId,\n            icTx.message,\n            icTx.nonce,\n            icTx.options,\n            icTx.transactionId,\n            icTx.dbWriterNonce\n        );\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"16914:9461:0:-:0;;;17440:36;;;;;;;;;-1:-1:-1;17462:10:0;;2095:95;;2148:31;;-1:-1:-1;;;2148:31:0;;2176:1;2148:31;;;160:51:1;133:18;;2148:31:0;;;;;;;2095:95;2199:32;2218:12;2199:18;:32::i;:::-;2051:187;16914:9461;;3738:187;3811:16;3830:6;;-1:-1:-1;;;;;3846:17:0;;;-1:-1:-1;;;;;;3846:17:0;;;;;;3878:40;;3830:6;;;;;;;3878:40;;3811:16;3878:40;3801:124;3738:187;:::o;14:203:1:-;16914:9461:0;;;;;;","srcMapRuntime":"16914:9461:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;25577:796;;;;;;;;;;-1:-1:-1;25577:796:0;;;;;:::i;:::-;;:::i;:::-;;17013:25;;;;;;;;;;-1:-1:-1;17013:25:0;;;;;;;;;;;;;;1061:18:1;1049:31;;;1031:50;;1019:2;1004:18;17013:25:0;;;;;;;;17044:27;;;;;;;;;;-1:-1:-1;17044:27:0;;;;;;;;;;;1268:42:1;1256:55;;;1238:74;;1226:2;1211:18;17044:27:0;1092:226:1;21837:1395:0;;;;;;;;;;-1:-1:-1;21837:1395:0;;;;;:::i;:::-;;:::i;:::-;;;1488:14:1;;1481:22;1463:41;;1451:2;1436:18;21837:1395:0;1323:187:1;19284:1504:0;;;;;;:::i;:::-;;:::i;25335:137::-;;;;;;;;;;-1:-1:-1;25335:137:0;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;3119:101::-;;;;;;;;;;;;;:::i;17186:48::-;;;;;;;;;;-1:-1:-1;17186:48:0;;;;;:::i;:::-;;;;;;;;;;;;;;;;;7006:25:1;;;6994:2;6979:18;17186:48:0;6860:177:1;17077:52:0;;;;;;;;;;-1:-1:-1;17077:52:0;;;;;:::i;:::-;;;;;;;;;;;;;;;;2464:85;;;;;;;;;;-1:-1:-1;2510:7:0;2536:6;;;2464:85;;17521:110;;;;;;;;;;-1:-1:-1;17521:110:0;;;;;:::i;:::-;;:::i;3369:215::-;;;;;;;;;;-1:-1:-1;3369:215:0;;;;;:::i;:::-;;:::i;17311:123::-;;;;;;;;;;-1:-1:-1;17311:123:0;;;;;:::i;:::-;;:::i;25577:796::-;25657:25;25670:11;;25657:12;:25::i;:::-;25649:67;;;;;;;8093:2:1;25649:67:0;;;8075:21:1;8132:2;8112:18;;;8105:30;8171:31;8151:18;;;8144:59;8220:18;;25649:67:0;;;;;;;;;25726:33;25762:48;;;;25773:11;25762:48;:::i;:::-;25841:18;;;;25820:40;;;;:20;:40;;;;;:47;;;;25863:4;25820:47;;;25912:12;;;;25726:84;;-1:-1:-1;25820:40:0;25912:30;;:28;:30::i;:::-;25878:64;;25968:44;25995:4;:16;;;4196:1;4086:121;25968:44;25953:71;;;26030:14;:23;;;25953:103;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;26306:4;:18;;;26142:4;:15;;;26114:4;:14;;;26071:295;26171:4;:16;;;26201:4;:15;;;26230:4;:12;;;26256:4;:10;;;26280:4;:12;;;26338:4;:18;;;26071:295;;;;;;;;;;;:::i;:::-;;;;;;;;25639:734;;25577:796;;:::o;21837:1395::-;21908:4;;21960:48;;;;21971:11;21960:48;:::i;:::-;22047:18;;;;22026:40;;;;:20;:40;;;;;;21924:84;;-1:-1:-1;22026:40:0;;:49;22018:90;;;;;;;9144:2:1;22018:90:0;;;9126:21:1;9183:2;9163:18;;;9156:30;9222;9202:18;;;9195:58;9270:18;;22018:90:0;8942:352:1;22018:90:0;22182:30;22215:210;;;;;;;;22257:4;:15;;;22215:210;;;;22297:13;:30;22311:4;:15;;;22297:30;;;;;;;;;;;;22215:210;;;;22354:4;:18;;;22215:210;;;;22396:4;:18;;;22215:210;;;22182:243;;22436:23;22462:152;22498:4;:14;;;22514:4;:15;;;22531:4;:16;;;22549:4;:15;;;22566:4;:12;;;22580:4;:10;;;22592:4;:12;;;22462:22;:152::i;:::-;22436:178;;22655:15;22633:4;:18;;;:37;22625:72;;;;;;;9501:2:1;22625:72:0;;;9483:21:1;9540:2;9520:18;;;9513:30;9579:24;9559:18;;;9552:52;9621:18;;22625:72:0;9299:346:1;22625:72:0;22709:25;22736:28;22766:35;22829:59;22843:44;22870:4;:16;;;4196:1;4086:121;22843:44;22829:13;:59::i;:::-;22708:180;;;;;;22899:34;22936:50;22958:18;22978:7;22936:21;:50::i;:::-;22899:87;;22997:26;23026:68;23054:17;23073:20;23026:27;:68::i;:::-;22997:97;;23134:17;23112:18;:39;;23104:100;;;;;;;9852:2:1;23104:100:0;;;9834:21:1;9891:2;9871:18;;;9864:30;9930:34;9910:18;;;9903:62;10001:18;9981;;;9974:46;10037:19;;23104:100:0;9650:412:1;23104:100:0;23221:4;23214:11;;;;;;;;;;21837:1395;;;;;:::o;19284:1504::-;19590:358;;;;;;;;;19534:9;;19508:23;;19590:358;19664:10;19590:358;;;;19701:13;19590:358;;;;19741:8;19590:358;;;;19775:10;19590:358;;;;19808:7;;19590:358;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;19590:358:0;;;-1:-1:-1;;19836:11:0;;;;;;;19590:358;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;19870:7:0;;19590:358;;;;;;19870:7;19590:358;;19870:7;19590:358;;;;;;;;-1:-1:-1;19590:358:0;;;-1:-1:-1;;;19590:358:0;;;;;;;;;;;;;;20019:14;;20035:15;;;;20052:16;;;;20070:15;;;;20087:12;;;;20101:10;;;;20113:12;;;;19554:394;;-1:-1:-1;19590:358:0;;19983:152;;20019:14;;20101:10;19983:22;:152::i;:::-;20145:18;;;:34;;;20228:12;;20306:15;;;;20214:149;;;;;19959:176;;-1:-1:-1;20190:21:0;;20228:12;;;;;20214:54;;20276:15;;20214:149;;20306:15;19959:176;;20343:10;;;;20214:149;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;20373:18;;;:34;;;20654:18;;;;20549:15;;;;20519:16;;;;;20462:14;;20490:15;;;;20578:12;;;;20604:10;;;;20628:12;;;;20423:291;;20190:173;;-1:-1:-1;20654:18:0;;20549:15;;20519:16;;20423:291;;;;20604:10;20190:173;;20423:291;:::i;:::-;;;;;;;;20768:11;:13;;;;;;;;:11;:13;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;19498:1290;;;;19284:1504;;;;;;;;:::o;25335:137::-;25418:12;25460:4;25449:16;;;;;;;;:::i;:::-;;;;;;;;;;;;;25442:23;;25335:137;;;:::o;3119:101::-;2357:13;:11;:13::i;:::-;3183:30:::1;3210:1;3183:18;:30::i;:::-;3119:101::o:0;17521:110::-;2357:13;:11;:13::i;:::-;17596:12:::1;:28:::0;;;::::1;;::::0;;;::::1;::::0;;;::::1;::::0;;17521:110::o;3369:215::-;2357:13;:11;:13::i;:::-;3453:22:::1;::::0;::::1;3449:91;;3498:31;::::0;::::1;::::0;;3526:1:::1;3498:31;::::0;::::1;1238:74:1::0;1211:18;;3498:31:0::1;1092:226:1::0;3449:91:0::1;3549:28;3568:8;3549:18;:28::i;:::-;3369:215:::0;:::o;17311:123::-;2357:13;:11;:13::i;:::-;17396:22:::1;::::0;;;:13:::1;:22;::::0;;;;;:31;17311:123::o;16201:603::-;-1:-1:-1;;;;;;;;;;;;;;;;;16297:13:0;16312:20;16336:28;16359:4;16336:22;:28::i;:::-;16296:68;;-1:-1:-1;16296:68:0;-1:-1:-1;14957:1:0;16378:20;;;;16374:95;;;16421:37;;;;;12897:4:1;12885:17;;16421:37:0;;;12867:36:1;12840:18;;16421:37:0;12725:184:1;16374:95:0;16776:7;16765:32;;;;;;;;;;;;:::i;:::-;16758:39;16201:603;-1:-1:-1;;;;16201:603:0:o;18779:398::-;19046:7;19097:9;19108:10;19120:11;19133:10;19145:7;19154:5;19161:7;19086:83;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;19076:94;;;;;;19069:101;;18779:398;;;;;;;;;:::o;21362:430::-;21441:25;21468:28;21498:35;21584:11;21569:48;;;:50;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;21549:70;;21667:11;21652:51;;;:53;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;21629:76;;;;21751:11;21736:47;;;:49;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;21362:430;;;;-1:-1:-1;;21362:430:0:o;24852:477::-;25006:16;25038:34;25089:15;:22;25075:37;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;25075:37:0;;25038:74;;25127:9;25122:167;25146:15;:22;25142:1;:26;25122:167;;;25226:12;;25250:18;;25226:12;;;;;25212:37;;25250:15;;25266:1;;25250:18;;;;;;:::i;:::-;;;;;;;;;;;;25212:66;;;;;;;;;;;15914:42:1;15902:55;;;25212:66:0;;;15884:74:1;15994:13;;15974:18;;;15967:41;16050:15;;;16044:22;16024:18;;;16017:50;16109:15;;;16103:22;16083:18;;;16076:50;16098:2;16169:15;;16163:22;16142:19;;;16135:51;15856:19;;25212:66:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;25189:17;25207:1;25189:20;;;;;;;;:::i;:::-;;;;;;;;;;:89;25170:3;;;;:::i;:::-;;;;25122:167;;;-1:-1:-1;25305:17:0;24852:477;-1:-1:-1;;;24852:477:0:o;23681:464::-;23841:7;;;23904:200;23928:17;:24;23924:1;:28;23904:200;;;24024:15;24000:20;23977:17;23995:1;23977:20;;;;;;;;:::i;:::-;;;;;;;:43;;;;:::i;:::-;:62;23973:121;;24059:20;;;;:::i;:::-;;;;23973:121;23954:3;;;;:::i;:::-;;;;23904:200;;2622:162;2510:7;2536:6;2681:23;2536:6;772:10;2681:23;2677:101;;2727:40;;;;;772:10;2727:40;;;1238:74:1;1211:18;;2727:40:0;1092:226:1;3738:187:0;3811:16;3830:6;;;3846:17;;;;;;;;;;3878:40;;3830:6;;;;;;;3878:40;;3811:16;3878:40;3801:124;3738:187;:::o;15572:181::-;15646:13;15661:20;15725:4;15714:32;;;;;;;;;;;;:::i;:::-;15693:53;;;;-1:-1:-1;15572:181:0;-1:-1:-1;;15572:181:0:o;14:347:1:-;65:8;75:6;129:3;122:4;114:6;110:17;106:27;96:55;;147:1;144;137:12;96:55;-1:-1:-1;170:20:1;;213:18;202:30;;199:50;;;245:1;242;235:12;199:50;282:4;274:6;270:17;258:29;;334:3;327:4;318:6;310;306:19;302:30;299:39;296:59;;;351:1;348;341:12;296:59;14:347;;;;;:::o;366:409::-;436:6;444;497:2;485:9;476:7;472:23;468:32;465:52;;;513:1;510;503:12;465:52;553:9;540:23;586:18;578:6;575:30;572:50;;;618:1;615;608:12;572:50;657:58;707:7;698:6;687:9;683:22;657:58;:::i;:::-;734:8;;631:84;;-1:-1:-1;366:409:1;-1:-1:-1;;;;366:409:1:o;1515:1327::-;1659:6;1667;1675;1683;1691;1699;1707;1715;1768:3;1756:9;1747:7;1743:23;1739:33;1736:53;;;1785:1;1782;1775:12;1736:53;1821:9;1808:23;1798:33;;1878:2;1867:9;1863:18;1850:32;1840:42;;1933:2;1922:9;1918:18;1905:32;1956:18;1997:2;1989:6;1986:14;1983:34;;;2013:1;2010;2003:12;1983:34;2052:58;2102:7;2093:6;2082:9;2078:22;2052:58;:::i;:::-;2129:8;;-1:-1:-1;2026:84:1;-1:-1:-1;2217:2:1;2202:18;;2189:32;;-1:-1:-1;2233:16:1;;;2230:36;;;2262:1;2259;2252:12;2230:36;2301:60;2353:7;2342:8;2331:9;2327:24;2301:60;:::i;:::-;2380:8;;-1:-1:-1;2275:86:1;-1:-1:-1;2468:3:1;2453:19;;2440:33;;-1:-1:-1;2485:16:1;;;2482:36;;;2514:1;2511;2504:12;2482:36;2552:8;2541:9;2537:24;2527:34;;2599:7;2592:4;2588:2;2584:13;2580:27;2570:55;;2621:1;2618;2611:12;2570:55;2661:2;2648:16;2687:2;2679:6;2676:14;2673:34;;;2703:1;2700;2693:12;2673:34;2756:7;2751:2;2741:6;2738:1;2734:14;2730:2;2726:23;2722:32;2719:45;2716:65;;;2777:1;2774;2767:12;2716:65;2808:2;2804;2800:11;2790:21;;2830:6;2820:16;;;;;1515:1327;;;;;;;;;;;:::o;2847:184::-;2899:77;2896:1;2889:88;2996:4;2993:1;2986:15;3020:4;3017:1;3010:15;3036:255;3108:2;3102:9;3150:6;3138:19;;3187:18;3172:34;;3208:22;;;3169:62;3166:88;;;3234:18;;:::i;:::-;3270:2;3263:22;3036:255;:::o;3296:334::-;3367:2;3361:9;3423:2;3413:13;;3428:66;3409:86;3397:99;;3526:18;3511:34;;3547:22;;;3508:62;3505:88;;;3573:18;;:::i;:::-;3609:2;3602:22;3296:334;;-1:-1:-1;3296:334:1:o;3635:245::-;3683:4;3716:18;3708:6;3705:30;3702:56;;;3738:18;;:::i;:::-;-1:-1:-1;3795:2:1;3783:15;3800:66;3779:88;3869:4;3775:99;;3635:245::o;3885:462::-;3927:5;3980:3;3973:4;3965:6;3961:17;3957:27;3947:55;;3998:1;3995;3988:12;3947:55;4034:6;4021:20;4065:48;4081:31;4109:2;4081:31;:::i;:::-;4065:48;:::i;:::-;4138:2;4129:7;4122:19;4184:3;4177:4;4172:2;4164:6;4160:15;4156:26;4153:35;4150:55;;;4201:1;4198;4191:12;4150:55;4266:2;4259:4;4251:6;4247:17;4240:4;4231:7;4227:18;4214:55;4314:1;4289:16;;;4307:4;4285:27;4278:38;;;;4293:7;3885:462;-1:-1:-1;;;3885:462:1:o;4352:129::-;4437:18;4430:5;4426:30;4419:5;4416:41;4406:69;;4471:1;4468;4461:12;4486:132;4553:20;;4582:30;4553:20;4582:30;:::i;:::-;4486:132;;;:::o;4623:1236::-;4720:6;4773:2;4761:9;4752:7;4748:23;4744:32;4741:52;;;4789:1;4786;4779:12;4741:52;4829:9;4816:23;4858:18;4899:2;4891:6;4888:14;4885:34;;;4915:1;4912;4905:12;4885:34;4938:22;;;;4994:6;4976:16;;;4972:29;4969:49;;;5014:1;5011;5004:12;4969:49;5040:22;;:::i;:::-;5098:2;5085:16;5078:5;5071:31;5155:2;5151;5147:11;5134:25;5129:2;5122:5;5118:14;5111:49;5213:2;5209;5205:11;5192:25;5187:2;5180:5;5176:14;5169:49;5271:2;5267;5263:11;5250:25;5245:2;5238:5;5234:14;5227:49;5322:3;5318:2;5314:12;5301:26;5352:2;5342:8;5339:16;5336:36;;;5368:1;5365;5358:12;5336:36;5405:44;5441:7;5430:8;5426:2;5422:17;5405:44;:::i;:::-;5399:3;5392:5;5388:15;5381:69;;5483:31;5509:3;5505:2;5501:12;5483:31;:::i;:::-;5477:3;5470:5;5466:15;5459:56;5561:3;5557:2;5553:12;5540:26;5591:2;5581:8;5578:16;5575:36;;;5607:1;5604;5597:12;5575:36;5644:44;5680:7;5669:8;5665:2;5661:17;5644:44;:::i;:::-;5638:3;5627:15;;5620:69;-1:-1:-1;5743:3:1;5735:12;;;5722:26;5705:15;;;5698:51;5768:3;5816:11;;;5803:25;5787:14;;;5780:49;;;;-1:-1:-1;5631:5:1;4623:1236;-1:-1:-1;;;4623:1236:1:o;5864:250::-;5949:1;5959:113;5973:6;5970:1;5967:13;5959:113;;;6049:11;;;6043:18;6030:11;;;6023:39;5995:2;5988:10;5959:113;;;-1:-1:-1;;6106:1:1;6088:16;;6081:27;5864:250::o;6119:329::-;6160:3;6198:5;6192:12;6225:6;6220:3;6213:19;6241:76;6310:6;6303:4;6298:3;6294:14;6287:4;6280:5;6276:16;6241:76;:::i;:::-;6362:2;6350:15;6367:66;6346:88;6337:98;;;;6437:4;6333:109;;6119:329;-1:-1:-1;;6119:329:1:o;6453:217::-;6600:2;6589:9;6582:21;6563:4;6620:44;6660:2;6649:9;6645:18;6637:6;6620:44;:::i;:::-;6612:52;6453:217;-1:-1:-1;;;6453:217:1:o;6675:180::-;6734:6;6787:2;6775:9;6766:7;6762:23;6758:32;6755:52;;;6803:1;6800;6793:12;6755:52;-1:-1:-1;6826:23:1;;6675:180;-1:-1:-1;6675:180:1:o;7227:154::-;7313:42;7306:5;7302:54;7295:5;7292:65;7282:93;;7371:1;7368;7361:12;7386:247;7445:6;7498:2;7486:9;7477:7;7473:23;7469:32;7466:52;;;7514:1;7511;7504:12;7466:52;7553:9;7540:23;7572:31;7597:5;7572:31;:::i;7638:248::-;7706:6;7714;7767:2;7755:9;7746:7;7742:23;7738:32;7735:52;;;7783:1;7780;7773:12;7735:52;-1:-1:-1;;7806:23:1;;;7876:2;7861:18;;;7848:32;;-1:-1:-1;7638:248:1:o;8249:688::-;8552:6;8541:9;8534:25;8595:6;8590:2;8579:9;8575:18;8568:34;8638:3;8633:2;8622:9;8618:18;8611:31;8515:4;8665:45;8705:3;8694:9;8690:19;8682:6;8665:45;:::i;:::-;8758:18;8750:6;8746:31;8741:2;8730:9;8726:18;8719:59;8827:9;8819:6;8815:22;8809:3;8798:9;8794:19;8787:51;8855:32;8880:6;8872;8855:32;:::i;:::-;8847:40;;;8924:6;8918:3;8907:9;8903:19;8896:35;8249:688;;;;;;;;;:::o;10067:871::-;10335:25;;;10379:2;10397:18;;;10390:34;;;10323:2;10455;10440:18;;10433:30;;;10308:18;;10498:22;;;10275:4;;10578:6;;10551:3;10536:19;;10275:4;10612:300;10626:6;10623:1;10620:13;10612:300;;;10701:6;10688:20;10721:31;10746:5;10721:31;:::i;:::-;10788:42;10777:54;10765:67;;10887:15;;;;10852:12;;;;10648:1;10641:9;10612:300;;;-1:-1:-1;10929:3:1;10067:871;-1:-1:-1;;;;;;;;10067:871:1:o;10943:184::-;11013:6;11066:2;11054:9;11045:7;11041:23;11037:32;11034:52;;;11082:1;11079;11072:12;11034:52;-1:-1:-1;11105:16:1;;10943:184;-1:-1:-1;10943:184:1:o;11132:::-;11184:77;11181:1;11174:88;11281:4;11278:1;11271:15;11305:4;11302:1;11295:15;11321:209;11359:3;11387:18;11440:2;11433:5;11429:14;11467:2;11458:7;11455:15;11452:41;;11473:18;;:::i;:::-;11522:1;11509:15;;11321:209;-1:-1:-1;;;11321:209:1:o;11535:1185::-;11740:2;11729:9;11722:21;11785:6;11779:13;11774:2;11763:9;11759:18;11752:41;11847:2;11839:6;11835:15;11829:22;11824:2;11813:9;11809:18;11802:50;11906:2;11898:6;11894:15;11888:22;11883:2;11872:9;11868:18;11861:50;11966:2;11958:6;11954:15;11948:22;11942:3;11931:9;11927:19;11920:51;11703:4;12018:3;12010:6;12006:16;12000:23;12042:6;12085:2;12079:3;12068:9;12064:19;12057:31;12111:51;12157:3;12146:9;12142:19;12128:12;12111:51;:::i;:::-;12097:65;;12211:3;12203:6;12199:16;12193:23;12225:54;12274:3;12263:9;12259:19;12243:14;856:18;845:30;833:43;;780:102;12225:54;;12328:3;12320:6;12316:16;12310:23;12398:66;12386:9;12378:6;12374:22;12370:95;12364:3;12353:9;12349:19;12342:124;12489:40;12522:6;12506:14;12489:40;:::i;:::-;12566:3;12554:16;;12548:23;12590:3;12609:18;;;12602:30;;;;12674:15;;;12668:22;12648:18;;;;12641:50;-1:-1:-1;12475:54:1;;11535:1185;-1:-1:-1;;11535:1185:1:o;12914:502::-;13010:6;13063:2;13051:9;13042:7;13038:23;13034:32;13031:52;;;13079:1;13076;13069:12;13031:52;13112:2;13106:9;13154:2;13146:6;13142:15;13223:6;13211:10;13208:22;13187:18;13175:10;13172:34;13169:62;13166:88;;;13234:18;;:::i;:::-;13270:2;13263:22;13309:16;;13294:32;;13380:2;13365:18;;;13359:25;13342:15;;;13335:50;;;;-1:-1:-1;13301:6:1;12914:502;-1:-1:-1;12914:502:1:o;13421:760::-;13752:6;13741:9;13734:25;13795:6;13790:2;13779:9;13775:18;13768:34;13838:6;13833:2;13822:9;13818:18;13811:34;13881:6;13876:2;13865:9;13861:18;13854:34;13925:3;13919;13908:9;13904:19;13897:32;13715:4;13952:45;13992:3;13981:9;13977:19;13969:6;13952:45;:::i;:::-;14046:18;14038:6;14034:31;14028:3;14017:9;14013:19;14006:60;14115:9;14107:6;14103:22;14097:3;14086:9;14082:19;14075:51;14143:32;14168:6;14160;14143:32;:::i;:::-;14135:40;13421:760;-1:-1:-1;;;;;;;;;;13421:760:1:o;14186:249::-;14255:6;14308:2;14296:9;14287:7;14283:23;14279:32;14276:52;;;14324:1;14321;14314:12;14276:52;14356:9;14350:16;14375:30;14399:5;14375:30;:::i;14440:1011::-;14535:6;14566:2;14609;14597:9;14588:7;14584:23;14580:32;14577:52;;;14625:1;14622;14615:12;14577:52;14658:9;14652:16;14687:18;14728:2;14720:6;14717:14;14714:34;;;14744:1;14741;14734:12;14714:34;14782:6;14771:9;14767:22;14757:32;;14827:7;14820:4;14816:2;14812:13;14808:27;14798:55;;14849:1;14846;14839:12;14798:55;14878:2;14872:9;14900:2;14896;14893:10;14890:36;;;14906:18;;:::i;:::-;14952:2;14949:1;14945:10;14935:20;;14975:28;14999:2;14995;14991:11;14975:28;:::i;:::-;15037:15;;;15107:11;;;15103:20;;;15068:12;;;;15135:19;;;15132:39;;;15167:1;15164;15157:12;15132:39;15191:11;;;;15211:210;15227:6;15222:3;15219:15;15211:210;;;15300:3;15294:10;15281:23;;15317:31;15342:5;15317:31;:::i;:::-;15361:18;;;15244:12;;;;15399;;;;15211:210;;;15440:5;14440:1011;-1:-1:-1;;;;;;;;14440:1011:1:o;15456:184::-;15508:77;15505:1;15498:88;15605:4;15602:1;15595:15;15629:4;15626:1;15619:15;16197:195;16236:3;16267:66;16260:5;16257:77;16254:103;;16337:18;;:::i;:::-;-1:-1:-1;16384:1:1;16373:13;;16197:195::o;16397:125::-;16462:9;;;16483:10;;;16480:36;;;16496:18;;:::i;16527:797::-;16613:6;16621;16674:2;16662:9;16653:7;16649:23;16645:32;16642:52;;;16690:1;16687;16680:12;16642:52;16722:9;16716:16;16772:4;16765:5;16761:16;16754:5;16751:27;16741:55;;16792:1;16789;16782:12;16741:55;16864:2;16849:18;;16843:25;16815:5;;-1:-1:-1;16891:18:1;16880:30;;16877:50;;;16923:1;16920;16913:12;16877:50;16946:22;;16999:4;16991:13;;16987:27;-1:-1:-1;16977:55:1;;17028:1;17025;17018:12;16977:55;17057:2;17051:9;17082:48;17098:31;17126:2;17098:31;:::i;17082:48::-;17153:2;17146:5;17139:17;17193:7;17188:2;17183;17179;17175:11;17171:20;17168:33;17165:53;;;17214:1;17211;17204:12;17165:53;17227:67;17291:2;17286;17279:5;17275:14;17270:2;17266;17262:11;17227:67;:::i;:::-;17313:5;17303:15;;;;;16527:797;;;;;:::o","abiDefinition":[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[{"internalType":"uint8","name":"version","type":"uint8"}],"name":"OptionsLib__IncorrectVersion","type":"error"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"srcSender","type":"bytes32"},{"indexed":true,"internalType":"uint256","name":"srcChainId","type":"uint256"},{"indexed":false,"internalType":"bytes32","name":"dstReceiver","type":"bytes32"},{"indexed":false,"internalType":"uint256","name":"dstChainId","type":"uint256"},{"indexed":false,"internalType":"bytes","name":"message","type":"bytes"},{"indexed":false,"internalType":"uint64","name":"nonce","type":"uint64"},{"indexed":false,"internalType":"bytes","name":"options","type":"bytes"},{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":false,"internalType":"uint256","name":"dbWriterNonce","type":"uint256"}],"name":"InterchainTransactionExecuted","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"bytes32","name":"srcSender","type":"bytes32"},{"indexed":false,"internalType":"uint256","name":"srcChainId","type":"uint256"},{"indexed":true,"internalType":"bytes32","name":"dstReceiver","type":"bytes32"},{"indexed":true,"internalType":"uint256","name":"dstChainId","type":"uint256"},{"indexed":false,"internalType":"bytes","name":"message","type":"bytes"},{"indexed":false,"internalType":"uint64","name":"nonce","type":"uint64"},{"indexed":false,"internalType":"bytes","name":"options","type":"bytes"},{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":false,"internalType":"uint256","name":"dbWriterNonce","type":"uint256"}],"name":"InterchainTransactionSent","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[],"name":"clientNonce","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"bytes32","name":"srcSender","type":"bytes32"},{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"dstReceiver","type":"bytes32"},{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"bytes","name":"message","type":"bytes"},{"internalType":"uint64","name":"nonce","type":"uint64"},{"internalType":"bytes","name":"options","type":"bytes"},{"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"internalType":"uint256","name":"dbWriterNonce","type":"uint256"}],"internalType":"struct InterchainClientV1.InterchainTransaction","name":"icTx","type":"tuple"}],"name":"encodeTransaction","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"name":"executedTransactions","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"interchainDB","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"transaction","type":"bytes"}],"name":"interchainExecute","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"receiver","type":"bytes32"},{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"bytes","name":"message","type":"bytes"},{"internalType":"bytes","name":"options","type":"bytes"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"interchainSend","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes","name":"transaction","type":"bytes"}],"name":"isExecutable","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"linkedClients","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_interchainDB","type":"address"}],"name":"setInterchainDB","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"bytes32","name":"client","type":"bytes32"}],"name":"setLinkedClient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"events":{"InterchainTransactionSent(bytes32,uint256,bytes32,uint256,bytes,uint64,bytes,bytes32,uint256)":{"notice":"Emitted when an interchain transaction is sent."}},"kind":"user","methods":{"interchainExecute(bytes)":{"notice":"Executes a transaction that has been sent via the Interchain."},"interchainSend(bytes32,uint256,bytes,bytes,address[])":{"notice":"Sends a message to another chain via the Interchain Communication Protocol."},"isExecutable(bytes)":{"notice":"Checks if a transaction is executable."},"setInterchainDB(address)":{"notice":"Sets the address of the InterchainDB contract."},"setLinkedClient(uint256,bytes32)":{"notice":"Sets the linked client for a specific chain ID."}},"version":1},"developerDoc":{"details":"Implements the operations of the Interchain Execution Layer.","errors":{"OwnableInvalidOwner(address)":[{"details":"The owner is not a valid owner account. (eg. `address(0)`)"}],"OwnableUnauthorizedAccount(address)":[{"details":"The caller account is not authorized to perform an operation."}]},"kind":"dev","methods":{"interchainExecute(bytes)":{"details":"The transaction must have been previously sent and recorded.","params":{"transaction":"The transaction data."}},"interchainSend(bytes32,uint256,bytes,bytes,address[])":{"details":"Charges a fee for the message, which is payable upon calling this function.","params":{"dstChainId":"The chain ID of the destination chain.","message":"The message being sent.","options":"Execution options for the message sent, encoded as bytes, currently primarily gas limit + native gas drop.","receiver":"The address of the receiver on the destination chain.","srcModules":"The source modules involved in the message sending."}},"isExecutable(bytes)":{"details":"Determines if a transaction meets the criteria to be executed based on: - If approved modules have written to the InterchainDB - If the threshold of approved modules have been met - If the optimistic window has passed for all modules","params":{"transaction":"The InterchainTransaction struct to be checked."},"returns":{"_0":"bool Returns true if the transaction is executable, false otherwise."}},"owner()":{"details":"Returns the address of the current owner."},"renounceOwnership()":{"details":"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."},"setInterchainDB(address)":{"details":"Only callable by the contract owner or an authorized account.","params":{"_interchainDB":"The address of the InterchainDB contract."}},"setLinkedClient(uint256,bytes32)":{"details":"Stores the address of the linked client in a mapping with the chain ID as the key.","params":{"chainId":"The chain ID for which the client is being set.","client":"The address of the client being linked."}},"transferOwnership(address)":{"details":"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}},"title":"InterchainClientV1","version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"OptionsLib__IncorrectVersion\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"srcSender\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dstReceiver\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dbWriterNonce\",\"type\":\"uint256\"}],\"name\":\"InterchainTransactionExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"srcSender\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"dstReceiver\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dbWriterNonce\",\"type\":\"uint256\"}],\"name\":\"InterchainTransactionSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"clientNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"srcSender\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dstReceiver\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"dbWriterNonce\",\"type\":\"uint256\"}],\"internalType\":\"struct InterchainClientV1.InterchainTransaction\",\"name\":\"icTx\",\"type\":\"tuple\"}],\"name\":\"encodeTransaction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"executedTransactions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interchainDB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"transaction\",\"type\":\"bytes\"}],\"name\":\"interchainExecute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"receiver\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"interchainSend\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"transaction\",\"type\":\"bytes\"}],\"name\":\"isExecutable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"linkedClients\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_interchainDB\",\"type\":\"address\"}],\"name\":\"setInterchainDB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"client\",\"type\":\"bytes32\"}],\"name\":\"setLinkedClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Implements the operations of the Interchain Execution Layer.\",\"errors\":{\"OwnableInvalidOwner(address)\":[{\"details\":\"The owner is not a valid owner account. (eg. `address(0)`)\"}],\"OwnableUnauthorizedAccount(address)\":[{\"details\":\"The caller account is not authorized to perform an operation.\"}]},\"kind\":\"dev\",\"methods\":{\"interchainExecute(bytes)\":{\"details\":\"The transaction must have been previously sent and recorded.\",\"params\":{\"transaction\":\"The transaction data.\"}},\"interchainSend(bytes32,uint256,bytes,bytes,address[])\":{\"details\":\"Charges a fee for the message, which is payable upon calling this function.\",\"params\":{\"dstChainId\":\"The chain ID of the destination chain.\",\"message\":\"The message being sent.\",\"options\":\"Execution options for the message sent, encoded as bytes, currently primarily gas limit + native gas drop.\",\"receiver\":\"The address of the receiver on the destination chain.\",\"srcModules\":\"The source modules involved in the message sending.\"}},\"isExecutable(bytes)\":{\"details\":\"Determines if a transaction meets the criteria to be executed based on: - If approved modules have written to the InterchainDB - If the threshold of approved modules have been met - If the optimistic window has passed for all modules\",\"params\":{\"transaction\":\"The InterchainTransaction struct to be checked.\"},\"returns\":{\"_0\":\"bool Returns true if the transaction is executable, false otherwise.\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"setInterchainDB(address)\":{\"details\":\"Only callable by the contract owner or an authorized account.\",\"params\":{\"_interchainDB\":\"The address of the InterchainDB contract.\"}},\"setLinkedClient(uint256,bytes32)\":{\"details\":\"Stores the address of the linked client in a mapping with the chain ID as the key.\",\"params\":{\"chainId\":\"The chain ID for which the client is being set.\",\"client\":\"The address of the client being linked.\"}},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"title\":\"InterchainClientV1\",\"version\":1},\"userdoc\":{\"events\":{\"InterchainTransactionSent(bytes32,uint256,bytes32,uint256,bytes,uint64,bytes,bytes32,uint256)\":{\"notice\":\"Emitted when an interchain transaction is sent.\"}},\"kind\":\"user\",\"methods\":{\"interchainExecute(bytes)\":{\"notice\":\"Executes a transaction that has been sent via the Interchain.\"},\"interchainSend(bytes32,uint256,bytes,bytes,address[])\":{\"notice\":\"Sends a message to another chain via the Interchain Communication Protocol.\"},\"isExecutable(bytes)\":{\"notice\":\"Checks if a transaction is executable.\"},\"setInterchainDB(address)\":{\"notice\":\"Sets the address of the InterchainDB contract.\"},\"setLinkedClient(uint256,bytes32)\":{\"notice\":\"Sets the linked client for a specific chain ID.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"InterchainClientV1\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0x44c9e0bf0e33c29df6b63f8909747984d3ad8c376a763f57eaa613086c22bb2c\",\"urls\":[\"bzz-raw://f5ad81ebeb36f44c014dbf8fe28dc9747b29eea33cc2d37a5d245fdbb1ef06f8\",\"dweb:/ipfs/QmW4JUaEBdaochJpLMphHqqu1WUrYxjESNET4HciC2jXtX\"]}},\"version\":1}"},"hashes":{"clientNonce()":"0d898416","encodeTransaction((bytes32,uint256,bytes32,uint256,bytes,uint64,bytes,bytes32,uint256))":"58865d18","executedTransactions(bytes32)":"8691d34c","interchainDB()":"0e785ce0","interchainExecute(bytes)":"074c17b4","interchainSend(bytes32,uint256,bytes,bytes,address[])":"521011a9","isExecutable(bytes)":"31afa7de","linkedClients(uint256)":"7268b08f","owner()":"8da5cb5b","renounceOwnership()":"715018a6","setInterchainDB(address)":"b7ce2078","setLinkedClient(uint256,bytes32)":"f34234c8","transferOwnership(address)":"f2fde38b"}},"solidity/InterchainClientV1.sol:InterchainEntryLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220fef7fe18d99015067f19d1a2183befdcdb4f9f5ed7101baeb45ebcc41445eea764736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220fef7fe18d99015067f19d1a2183befdcdb4f9f5ed7101baeb45ebcc41445eea764736f6c63430008140033","info":{"source":"pragma solidity 0.8.20;\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n/// @notice Struct representing an entry in the Interchain DataBase\n/// @param srcChainId   The chain id of the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param writerNonce  The nonce of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    bytes32 srcWriter;\n    uint256 writerNonce;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param srcWriter    The address of the writer on the local chain\n    /// @param writerNonce  The nonce of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        address srcWriter,\n        uint256 writerNonce,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            srcWriter: TypeCasts.addressToBytes32(srcWriter),\n            writerNonce: writerNonce,\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryId(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.srcWriter, entry.writerNonce));\n    }\n}\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param dataHash     The hash of the data written on the source chain\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 dataHash;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingDataHash, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(address writer, uint256 writerNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntry(bytes32 dataHash) external returns (uint256 writerNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param writer        The address of the writer on the source chain\n    /// @param writerNonce   The nonce of the writer on the source chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(\n        uint256 destChainId,\n        address writer,\n        uint256 writerNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 writerNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param writer       The address of the writer on this chain\n    /// @param writerNonce  The nonce of the writer's entry on this chain\n    function getEntry(address writer, uint256 writerNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the writer on this chain.\n    /// @param writer       The address of the writer on this chain\n    function getWriterNonce(address writer) external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\ninterface IInterchainApp {\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory sendingModules,\n        address[] memory receivingModules,\n        uint256 requiredResponses,\n        uint64 optimisticTimePeriod\n    )\n        external;\n\n    function getLinkedIApp(uint64 chainID) external view returns (address);\n\n    function getSendingModules() external view returns (address[] memory);\n\n    function getReceivingModules() external view returns (address[] memory);\n\n    function getRequiredResponses() external view returns (uint256);\n\n    function getOptimisticTimePeriod() external view returns (uint64);\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable;\n\n    function appReceive() external;\n}\n\ninterface IInterchainClientV1 {\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sets the address of the InterchainDB contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param _interchainDB The address of the InterchainDB contract.\n     */\n    function setInterchainDB(address _interchainDB) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param message The message being sent.\n     * @param options Execution options for the message sent, encoded as bytes, currently primarily gas limit + native gas drop.\n     * @param srcModules The source modules involved in the message sending.\n     */\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        bytes calldata options,\n        address[] calldata srcModules\n    )\n        external\n        payable;\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * @param transaction The transaction data.\n     */\n    function interchainExecute(bytes calldata transaction) external;\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction The InterchainTransaction struct to be checked.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction) external view returns (bool);\n}\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    uint8 constant OPTIONS_V1 = 1;\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, IInterchainClientV1 {\n    using OptionsLib for bytes;\n\n    uint64 public clientNonce;\n    address public interchainDB;\n    mapping(bytes32 =\u003e bool) public executedTransactions;\n\n    // Chain ID =\u003e Bytes32 Address of src clients\n    mapping(uint256 =\u003e bytes32) public linkedClients;\n\n    // TODO: Add permissioning\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint256 chainId, bytes32 client) public onlyOwner {\n        linkedClients[chainId] = client;\n    }\n\n    constructor() Ownable(msg.sender) {}\n\n    // @inheritdoc IInterchainClientV1\n    function setInterchainDB(address _interchainDB) public onlyOwner {\n        interchainDB = _interchainDB;\n    }\n\n    /**\n     * @notice Emitted when an interchain transaction is sent.\n     */\n    event InterchainTransactionSent(\n        bytes32 srcSender,\n        uint256 srcChainId,\n        bytes32 indexed dstReceiver,\n        uint256 indexed dstChainId,\n        bytes message,\n        uint64 nonce,\n        bytes options,\n        bytes32 indexed transactionId,\n        uint256 dbWriterNonce\n    );\n\n    // @notice Emitted when an interchain transaction is executed.\n    // TODO: Indexing\n    event InterchainTransactionExecuted(\n        bytes32 indexed srcSender,\n        uint256 indexed srcChainId,\n        bytes32 dstReceiver,\n        uint256 dstChainId,\n        bytes message,\n        uint64 nonce,\n        bytes options,\n        bytes32 indexed transactionId,\n        uint256 dbWriterNonce\n    );\n\n    /**\n     * @dev Represents an interchain transaction.\n     */\n    struct InterchainTransaction {\n        bytes32 srcSender;\n        uint256 srcChainId;\n        bytes32 dstReceiver;\n        uint256 dstChainId;\n        bytes message;\n        uint64 nonce;\n        bytes options;\n        bytes32 transactionId;\n        uint256 dbWriterNonce;\n    }\n\n    function _generateTransactionId(\n        bytes32 srcSender,\n        uint256 srcChainId,\n        bytes32 dstReceiver,\n        uint256 dstChainId,\n        bytes memory message,\n        uint64 nonce,\n        bytes memory options\n    )\n    internal\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encode(srcSender, srcChainId, dstReceiver, dstChainId, message, nonce, options));\n    }\n\n    // TODO: Calculate Gas Pricing per module and charge fees\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        bytes calldata options,\n        address[] calldata srcModules\n    )\n    public\n    payable\n    {\n        uint256 totalModuleFees = msg.value;\n\n        InterchainTransaction memory icTx = InterchainTransaction({\n            srcSender: TypeCasts.addressToBytes32(msg.sender),\n            srcChainId: block.chainid,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            message: message,\n            nonce: clientNonce,\n            options: options,\n            transactionId: 0,\n            dbWriterNonce: 0\n        });\n\n        bytes32 transactionId = _generateTransactionId(\n            icTx.srcSender, icTx.srcChainId, icTx.dstReceiver, icTx.dstChainId, icTx.message, icTx.nonce, icTx.options\n        );\n        icTx.transactionId = transactionId;\n\n        uint256 dbWriterNonce = IInterchainDB(interchainDB).writeEntryWithVerification{value: totalModuleFees}(\n            icTx.dstChainId, icTx.transactionId, srcModules\n        );\n        icTx.dbWriterNonce = dbWriterNonce;\n\n        emit InterchainTransactionSent(\n            icTx.srcSender,\n            icTx.srcChainId,\n            icTx.dstReceiver,\n            icTx.dstChainId,\n            icTx.message,\n            icTx.nonce,\n            icTx.options,\n            icTx.transactionId,\n            icTx.dbWriterNonce\n        );\n        // Increment nonce for next message\n        clientNonce++;\n    }\n\n    // TODO: App Config Versioning\n    // TODO: What if receiver is not a contract / doesn't conform to interface?\n    /**\n     * @dev Retrieves the application configuration for a given receiver application.\n     * @param receiverApp The address of the receiver application.\n     * @return requiredResponses The number of required responses from the receiving modules.\n     * @return optimisticTimePeriod The time period within which responses are considered valid.\n     * @return approvedDstModules An array of addresses of the approved destination modules.\n     */\n    function _getAppConfig(address receiverApp)\n    internal\n    view\n    returns (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules)\n    {\n        requiredResponses = IInterchainApp(receiverApp).getRequiredResponses();\n        optimisticTimePeriod = IInterchainApp(receiverApp).getOptimisticTimePeriod();\n        approvedDstModules = IInterchainApp(receiverApp).getReceivingModules();\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata transaction) public view returns (bool) {\n        InterchainTransaction memory icTx = abi.decode(transaction, (InterchainTransaction));\n        require(executedTransactions[icTx.transactionId] == false, \"Transaction already executed\");\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            srcWriter: linkedClients[icTx.srcChainId],\n            writerNonce: icTx.dbWriterNonce,\n            dataHash: icTx.transactionId\n        });\n\n        bytes32 reconstructedID = _generateTransactionId(\n            icTx.srcSender, icTx.srcChainId, icTx.dstReceiver, icTx.dstChainId, icTx.message, icTx.nonce, icTx.options\n        );\n\n        require(icTx.transactionId == reconstructedID, \"Invalid transaction ID\");\n\n        (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules) =\n                        _getAppConfig(TypeCasts.bytes32ToAddress(icTx.dstReceiver));\n\n        uint256[] memory approvedResponses = _getApprovedResponses(approvedDstModules, icEntry);\n\n        uint256 finalizedResponses = _getFinalizedResponsesCount(approvedResponses, optimisticTimePeriod);\n        require(finalizedResponses \u003e= requiredResponses, \"Not enough valid responses to meet the threshold\");\n        return true;\n    }\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedResponses An array of timestamps when each approved response was recorded.\n     * @param optimisticTimePeriod The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses The count of responses that are finalized within the optimistic time period.\n     */\n\n    function _getFinalizedResponsesCount(\n        uint256[] memory approvedResponses,\n        uint256 optimisticTimePeriod\n    )\n    internal\n    view\n    returns (uint256)\n    {\n        uint256 finalizedResponses = 0;\n        for (uint256 i = 0; i \u003c approvedResponses.length; i++) {\n            if (approvedResponses[i] + optimisticTimePeriod \u003c= block.timestamp) {\n                finalizedResponses++;\n            }\n        }\n        return finalizedResponses;\n    }\n    /**\n     * @dev Retrieves the responses from approved modules for a given InterchainEntry.\n     * This function iterates over all approved modules, querying the InterchainDB for each module's response\n     * to the provided InterchainEntry. It compiles these responses into an array of uint256, where each\n     * element represents the timestamp of a module's response.\n     *\n     * @param approvedModules An array of addresses representing the approved modules that can write responses.\n     * @param icEntry The InterchainEntry for which responses are being retrieved.\n     * @return approvedResponses An array of uint256 representing the timestamps of responses from approved modules.\n     */\n\n    function _getApprovedResponses(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry\n    )\n    internal\n    view\n    returns (uint256[] memory)\n    {\n        uint256[] memory approvedResponses = new uint256[](approvedModules.length);\n        for (uint256 i = 0; i \u003c approvedModules.length; i++) {\n            approvedResponses[i] = IInterchainDB(interchainDB).readEntry(approvedModules[i], icEntry);\n        }\n        return approvedResponses;\n    }\n\n    function encodeTransaction(InterchainTransaction memory icTx) public view returns (bytes memory) {\n        return abi.encode(icTx);\n    }\n\n    // TODO: Gas Fee Consideration that is paid to executor\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(bytes calldata transaction) public {\n        require(isExecutable(transaction), \"Transaction is not executable\");\n        InterchainTransaction memory icTx = abi.decode(transaction, (InterchainTransaction));\n        executedTransactions[icTx.transactionId] = true;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: decodedOptions.gasLimit}();\n        emit InterchainTransactionExecuted(\n            icTx.srcSender,\n            icTx.srcChainId,\n            icTx.dstReceiver,\n            icTx.dstChainId,\n            icTx.message,\n            icTx.nonce,\n            icTx.options,\n            icTx.transactionId,\n            icTx.dbWriterNonce\n        );\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"4669:1080:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;4669:1080:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"4669:1080:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"InterchainEntryLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0x44c9e0bf0e33c29df6b63f8909747984d3ad8c376a763f57eaa613086c22bb2c\",\"urls\":[\"bzz-raw://f5ad81ebeb36f44c014dbf8fe28dc9747b29eea33cc2d37a5d245fdbb1ef06f8\",\"dweb:/ipfs/QmW4JUaEBdaochJpLMphHqqu1WUrYxjESNET4HciC2jXtX\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainClientV1.sol:OptionsLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212200022afdbe04f3efff0bf6e269cf58a32f321e09807674bd30ef5c3328b80910f64736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212200022afdbe04f3efff0bf6e269cf58a32f321e09807674bd30ef5c3328b80910f64736f6c63430008140033","info":{"source":"pragma solidity 0.8.20;\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n/// @notice Struct representing an entry in the Interchain DataBase\n/// @param srcChainId   The chain id of the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param writerNonce  The nonce of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    bytes32 srcWriter;\n    uint256 writerNonce;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param srcWriter    The address of the writer on the local chain\n    /// @param writerNonce  The nonce of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        address srcWriter,\n        uint256 writerNonce,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            srcWriter: TypeCasts.addressToBytes32(srcWriter),\n            writerNonce: writerNonce,\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryId(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.srcWriter, entry.writerNonce));\n    }\n}\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param dataHash     The hash of the data written on the source chain\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 dataHash;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingDataHash, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(address writer, uint256 writerNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntry(bytes32 dataHash) external returns (uint256 writerNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param writer        The address of the writer on the source chain\n    /// @param writerNonce   The nonce of the writer on the source chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(\n        uint256 destChainId,\n        address writer,\n        uint256 writerNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 writerNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param writer       The address of the writer on this chain\n    /// @param writerNonce  The nonce of the writer's entry on this chain\n    function getEntry(address writer, uint256 writerNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the writer on this chain.\n    /// @param writer       The address of the writer on this chain\n    function getWriterNonce(address writer) external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\ninterface IInterchainApp {\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory sendingModules,\n        address[] memory receivingModules,\n        uint256 requiredResponses,\n        uint64 optimisticTimePeriod\n    )\n        external;\n\n    function getLinkedIApp(uint64 chainID) external view returns (address);\n\n    function getSendingModules() external view returns (address[] memory);\n\n    function getReceivingModules() external view returns (address[] memory);\n\n    function getRequiredResponses() external view returns (uint256);\n\n    function getOptimisticTimePeriod() external view returns (uint64);\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable;\n\n    function appReceive() external;\n}\n\ninterface IInterchainClientV1 {\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sets the address of the InterchainDB contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param _interchainDB The address of the InterchainDB contract.\n     */\n    function setInterchainDB(address _interchainDB) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param message The message being sent.\n     * @param options Execution options for the message sent, encoded as bytes, currently primarily gas limit + native gas drop.\n     * @param srcModules The source modules involved in the message sending.\n     */\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        bytes calldata options,\n        address[] calldata srcModules\n    )\n        external\n        payable;\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * @param transaction The transaction data.\n     */\n    function interchainExecute(bytes calldata transaction) external;\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction The InterchainTransaction struct to be checked.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction) external view returns (bool);\n}\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    uint8 constant OPTIONS_V1 = 1;\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, IInterchainClientV1 {\n    using OptionsLib for bytes;\n\n    uint64 public clientNonce;\n    address public interchainDB;\n    mapping(bytes32 =\u003e bool) public executedTransactions;\n\n    // Chain ID =\u003e Bytes32 Address of src clients\n    mapping(uint256 =\u003e bytes32) public linkedClients;\n\n    // TODO: Add permissioning\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint256 chainId, bytes32 client) public onlyOwner {\n        linkedClients[chainId] = client;\n    }\n\n    constructor() Ownable(msg.sender) {}\n\n    // @inheritdoc IInterchainClientV1\n    function setInterchainDB(address _interchainDB) public onlyOwner {\n        interchainDB = _interchainDB;\n    }\n\n    /**\n     * @notice Emitted when an interchain transaction is sent.\n     */\n    event InterchainTransactionSent(\n        bytes32 srcSender,\n        uint256 srcChainId,\n        bytes32 indexed dstReceiver,\n        uint256 indexed dstChainId,\n        bytes message,\n        uint64 nonce,\n        bytes options,\n        bytes32 indexed transactionId,\n        uint256 dbWriterNonce\n    );\n\n    // @notice Emitted when an interchain transaction is executed.\n    // TODO: Indexing\n    event InterchainTransactionExecuted(\n        bytes32 indexed srcSender,\n        uint256 indexed srcChainId,\n        bytes32 dstReceiver,\n        uint256 dstChainId,\n        bytes message,\n        uint64 nonce,\n        bytes options,\n        bytes32 indexed transactionId,\n        uint256 dbWriterNonce\n    );\n\n    /**\n     * @dev Represents an interchain transaction.\n     */\n    struct InterchainTransaction {\n        bytes32 srcSender;\n        uint256 srcChainId;\n        bytes32 dstReceiver;\n        uint256 dstChainId;\n        bytes message;\n        uint64 nonce;\n        bytes options;\n        bytes32 transactionId;\n        uint256 dbWriterNonce;\n    }\n\n    function _generateTransactionId(\n        bytes32 srcSender,\n        uint256 srcChainId,\n        bytes32 dstReceiver,\n        uint256 dstChainId,\n        bytes memory message,\n        uint64 nonce,\n        bytes memory options\n    )\n    internal\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encode(srcSender, srcChainId, dstReceiver, dstChainId, message, nonce, options));\n    }\n\n    // TODO: Calculate Gas Pricing per module and charge fees\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        bytes calldata options,\n        address[] calldata srcModules\n    )\n    public\n    payable\n    {\n        uint256 totalModuleFees = msg.value;\n\n        InterchainTransaction memory icTx = InterchainTransaction({\n            srcSender: TypeCasts.addressToBytes32(msg.sender),\n            srcChainId: block.chainid,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            message: message,\n            nonce: clientNonce,\n            options: options,\n            transactionId: 0,\n            dbWriterNonce: 0\n        });\n\n        bytes32 transactionId = _generateTransactionId(\n            icTx.srcSender, icTx.srcChainId, icTx.dstReceiver, icTx.dstChainId, icTx.message, icTx.nonce, icTx.options\n        );\n        icTx.transactionId = transactionId;\n\n        uint256 dbWriterNonce = IInterchainDB(interchainDB).writeEntryWithVerification{value: totalModuleFees}(\n            icTx.dstChainId, icTx.transactionId, srcModules\n        );\n        icTx.dbWriterNonce = dbWriterNonce;\n\n        emit InterchainTransactionSent(\n            icTx.srcSender,\n            icTx.srcChainId,\n            icTx.dstReceiver,\n            icTx.dstChainId,\n            icTx.message,\n            icTx.nonce,\n            icTx.options,\n            icTx.transactionId,\n            icTx.dbWriterNonce\n        );\n        // Increment nonce for next message\n        clientNonce++;\n    }\n\n    // TODO: App Config Versioning\n    // TODO: What if receiver is not a contract / doesn't conform to interface?\n    /**\n     * @dev Retrieves the application configuration for a given receiver application.\n     * @param receiverApp The address of the receiver application.\n     * @return requiredResponses The number of required responses from the receiving modules.\n     * @return optimisticTimePeriod The time period within which responses are considered valid.\n     * @return approvedDstModules An array of addresses of the approved destination modules.\n     */\n    function _getAppConfig(address receiverApp)\n    internal\n    view\n    returns (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules)\n    {\n        requiredResponses = IInterchainApp(receiverApp).getRequiredResponses();\n        optimisticTimePeriod = IInterchainApp(receiverApp).getOptimisticTimePeriod();\n        approvedDstModules = IInterchainApp(receiverApp).getReceivingModules();\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata transaction) public view returns (bool) {\n        InterchainTransaction memory icTx = abi.decode(transaction, (InterchainTransaction));\n        require(executedTransactions[icTx.transactionId] == false, \"Transaction already executed\");\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            srcWriter: linkedClients[icTx.srcChainId],\n            writerNonce: icTx.dbWriterNonce,\n            dataHash: icTx.transactionId\n        });\n\n        bytes32 reconstructedID = _generateTransactionId(\n            icTx.srcSender, icTx.srcChainId, icTx.dstReceiver, icTx.dstChainId, icTx.message, icTx.nonce, icTx.options\n        );\n\n        require(icTx.transactionId == reconstructedID, \"Invalid transaction ID\");\n\n        (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules) =\n                        _getAppConfig(TypeCasts.bytes32ToAddress(icTx.dstReceiver));\n\n        uint256[] memory approvedResponses = _getApprovedResponses(approvedDstModules, icEntry);\n\n        uint256 finalizedResponses = _getFinalizedResponsesCount(approvedResponses, optimisticTimePeriod);\n        require(finalizedResponses \u003e= requiredResponses, \"Not enough valid responses to meet the threshold\");\n        return true;\n    }\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedResponses An array of timestamps when each approved response was recorded.\n     * @param optimisticTimePeriod The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses The count of responses that are finalized within the optimistic time period.\n     */\n\n    function _getFinalizedResponsesCount(\n        uint256[] memory approvedResponses,\n        uint256 optimisticTimePeriod\n    )\n    internal\n    view\n    returns (uint256)\n    {\n        uint256 finalizedResponses = 0;\n        for (uint256 i = 0; i \u003c approvedResponses.length; i++) {\n            if (approvedResponses[i] + optimisticTimePeriod \u003c= block.timestamp) {\n                finalizedResponses++;\n            }\n        }\n        return finalizedResponses;\n    }\n    /**\n     * @dev Retrieves the responses from approved modules for a given InterchainEntry.\n     * This function iterates over all approved modules, querying the InterchainDB for each module's response\n     * to the provided InterchainEntry. It compiles these responses into an array of uint256, where each\n     * element represents the timestamp of a module's response.\n     *\n     * @param approvedModules An array of addresses representing the approved modules that can write responses.\n     * @param icEntry The InterchainEntry for which responses are being retrieved.\n     * @return approvedResponses An array of uint256 representing the timestamps of responses from approved modules.\n     */\n\n    function _getApprovedResponses(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry\n    )\n    internal\n    view\n    returns (uint256[] memory)\n    {\n        uint256[] memory approvedResponses = new uint256[](approvedModules.length);\n        for (uint256 i = 0; i \u003c approvedModules.length; i++) {\n            approvedResponses[i] = IInterchainDB(interchainDB).readEntry(approvedModules[i], icEntry);\n        }\n        return approvedResponses;\n    }\n\n    function encodeTransaction(InterchainTransaction memory icTx) public view returns (bytes memory) {\n        return abi.encode(icTx);\n    }\n\n    // TODO: Gas Fee Consideration that is paid to executor\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(bytes calldata transaction) public {\n        require(isExecutable(transaction), \"Transaction is not executable\");\n        InterchainTransaction memory icTx = abi.decode(transaction, (InterchainTransaction));\n        executedTransactions[icTx.transactionId] = true;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: decodedOptions.gasLimit}();\n        emit InterchainTransactionExecuted(\n            icTx.srcSender,\n            icTx.srcChainId,\n            icTx.dstReceiver,\n            icTx.dstChainId,\n            icTx.message,\n            icTx.nonce,\n            icTx.options,\n            icTx.transactionId,\n            icTx.dbWriterNonce\n        );\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"14848:1958:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;14848:1958:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"14848:1958:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[{"internalType":"uint8","name":"version","type":"uint8"}],"name":"OptionsLib__IncorrectVersion","type":"error"}],"userDoc":{"kind":"user","methods":{},"notice":"A library for encoding and decoding Interchain options related to interchain messages.","version":1},"developerDoc":{"kind":"dev","methods":{},"title":"OptionsLib","version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"OptionsLib__IncorrectVersion\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"title\":\"OptionsLib\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"A library for encoding and decoding Interchain options related to interchain messages.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"OptionsLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0x44c9e0bf0e33c29df6b63f8909747984d3ad8c376a763f57eaa613086c22bb2c\",\"urls\":[\"bzz-raw://f5ad81ebeb36f44c014dbf8fe28dc9747b29eea33cc2d37a5d245fdbb1ef06f8\",\"dweb:/ipfs/QmW4JUaEBdaochJpLMphHqqu1WUrYxjESNET4HciC2jXtX\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainClientV1.sol:Ownable":{"code":"0x","runtime-code":"0x","info":{"source":"pragma solidity 0.8.20;\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n/// @notice Struct representing an entry in the Interchain DataBase\n/// @param srcChainId   The chain id of the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param writerNonce  The nonce of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    bytes32 srcWriter;\n    uint256 writerNonce;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param srcWriter    The address of the writer on the local chain\n    /// @param writerNonce  The nonce of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        address srcWriter,\n        uint256 writerNonce,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            srcWriter: TypeCasts.addressToBytes32(srcWriter),\n            writerNonce: writerNonce,\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryId(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.srcWriter, entry.writerNonce));\n    }\n}\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param dataHash     The hash of the data written on the source chain\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 dataHash;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingDataHash, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(address writer, uint256 writerNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntry(bytes32 dataHash) external returns (uint256 writerNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param writer        The address of the writer on the source chain\n    /// @param writerNonce   The nonce of the writer on the source chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(\n        uint256 destChainId,\n        address writer,\n        uint256 writerNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 writerNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param writer       The address of the writer on this chain\n    /// @param writerNonce  The nonce of the writer's entry on this chain\n    function getEntry(address writer, uint256 writerNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the writer on this chain.\n    /// @param writer       The address of the writer on this chain\n    function getWriterNonce(address writer) external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\ninterface IInterchainApp {\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory sendingModules,\n        address[] memory receivingModules,\n        uint256 requiredResponses,\n        uint64 optimisticTimePeriod\n    )\n        external;\n\n    function getLinkedIApp(uint64 chainID) external view returns (address);\n\n    function getSendingModules() external view returns (address[] memory);\n\n    function getReceivingModules() external view returns (address[] memory);\n\n    function getRequiredResponses() external view returns (uint256);\n\n    function getOptimisticTimePeriod() external view returns (uint64);\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable;\n\n    function appReceive() external;\n}\n\ninterface IInterchainClientV1 {\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sets the address of the InterchainDB contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param _interchainDB The address of the InterchainDB contract.\n     */\n    function setInterchainDB(address _interchainDB) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param message The message being sent.\n     * @param options Execution options for the message sent, encoded as bytes, currently primarily gas limit + native gas drop.\n     * @param srcModules The source modules involved in the message sending.\n     */\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        bytes calldata options,\n        address[] calldata srcModules\n    )\n        external\n        payable;\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * @param transaction The transaction data.\n     */\n    function interchainExecute(bytes calldata transaction) external;\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction The InterchainTransaction struct to be checked.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction) external view returns (bool);\n}\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    uint8 constant OPTIONS_V1 = 1;\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, IInterchainClientV1 {\n    using OptionsLib for bytes;\n\n    uint64 public clientNonce;\n    address public interchainDB;\n    mapping(bytes32 =\u003e bool) public executedTransactions;\n\n    // Chain ID =\u003e Bytes32 Address of src clients\n    mapping(uint256 =\u003e bytes32) public linkedClients;\n\n    // TODO: Add permissioning\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint256 chainId, bytes32 client) public onlyOwner {\n        linkedClients[chainId] = client;\n    }\n\n    constructor() Ownable(msg.sender) {}\n\n    // @inheritdoc IInterchainClientV1\n    function setInterchainDB(address _interchainDB) public onlyOwner {\n        interchainDB = _interchainDB;\n    }\n\n    /**\n     * @notice Emitted when an interchain transaction is sent.\n     */\n    event InterchainTransactionSent(\n        bytes32 srcSender,\n        uint256 srcChainId,\n        bytes32 indexed dstReceiver,\n        uint256 indexed dstChainId,\n        bytes message,\n        uint64 nonce,\n        bytes options,\n        bytes32 indexed transactionId,\n        uint256 dbWriterNonce\n    );\n\n    // @notice Emitted when an interchain transaction is executed.\n    // TODO: Indexing\n    event InterchainTransactionExecuted(\n        bytes32 indexed srcSender,\n        uint256 indexed srcChainId,\n        bytes32 dstReceiver,\n        uint256 dstChainId,\n        bytes message,\n        uint64 nonce,\n        bytes options,\n        bytes32 indexed transactionId,\n        uint256 dbWriterNonce\n    );\n\n    /**\n     * @dev Represents an interchain transaction.\n     */\n    struct InterchainTransaction {\n        bytes32 srcSender;\n        uint256 srcChainId;\n        bytes32 dstReceiver;\n        uint256 dstChainId;\n        bytes message;\n        uint64 nonce;\n        bytes options;\n        bytes32 transactionId;\n        uint256 dbWriterNonce;\n    }\n\n    function _generateTransactionId(\n        bytes32 srcSender,\n        uint256 srcChainId,\n        bytes32 dstReceiver,\n        uint256 dstChainId,\n        bytes memory message,\n        uint64 nonce,\n        bytes memory options\n    )\n    internal\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encode(srcSender, srcChainId, dstReceiver, dstChainId, message, nonce, options));\n    }\n\n    // TODO: Calculate Gas Pricing per module and charge fees\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        bytes calldata options,\n        address[] calldata srcModules\n    )\n    public\n    payable\n    {\n        uint256 totalModuleFees = msg.value;\n\n        InterchainTransaction memory icTx = InterchainTransaction({\n            srcSender: TypeCasts.addressToBytes32(msg.sender),\n            srcChainId: block.chainid,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            message: message,\n            nonce: clientNonce,\n            options: options,\n            transactionId: 0,\n            dbWriterNonce: 0\n        });\n\n        bytes32 transactionId = _generateTransactionId(\n            icTx.srcSender, icTx.srcChainId, icTx.dstReceiver, icTx.dstChainId, icTx.message, icTx.nonce, icTx.options\n        );\n        icTx.transactionId = transactionId;\n\n        uint256 dbWriterNonce = IInterchainDB(interchainDB).writeEntryWithVerification{value: totalModuleFees}(\n            icTx.dstChainId, icTx.transactionId, srcModules\n        );\n        icTx.dbWriterNonce = dbWriterNonce;\n\n        emit InterchainTransactionSent(\n            icTx.srcSender,\n            icTx.srcChainId,\n            icTx.dstReceiver,\n            icTx.dstChainId,\n            icTx.message,\n            icTx.nonce,\n            icTx.options,\n            icTx.transactionId,\n            icTx.dbWriterNonce\n        );\n        // Increment nonce for next message\n        clientNonce++;\n    }\n\n    // TODO: App Config Versioning\n    // TODO: What if receiver is not a contract / doesn't conform to interface?\n    /**\n     * @dev Retrieves the application configuration for a given receiver application.\n     * @param receiverApp The address of the receiver application.\n     * @return requiredResponses The number of required responses from the receiving modules.\n     * @return optimisticTimePeriod The time period within which responses are considered valid.\n     * @return approvedDstModules An array of addresses of the approved destination modules.\n     */\n    function _getAppConfig(address receiverApp)\n    internal\n    view\n    returns (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules)\n    {\n        requiredResponses = IInterchainApp(receiverApp).getRequiredResponses();\n        optimisticTimePeriod = IInterchainApp(receiverApp).getOptimisticTimePeriod();\n        approvedDstModules = IInterchainApp(receiverApp).getReceivingModules();\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata transaction) public view returns (bool) {\n        InterchainTransaction memory icTx = abi.decode(transaction, (InterchainTransaction));\n        require(executedTransactions[icTx.transactionId] == false, \"Transaction already executed\");\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            srcWriter: linkedClients[icTx.srcChainId],\n            writerNonce: icTx.dbWriterNonce,\n            dataHash: icTx.transactionId\n        });\n\n        bytes32 reconstructedID = _generateTransactionId(\n            icTx.srcSender, icTx.srcChainId, icTx.dstReceiver, icTx.dstChainId, icTx.message, icTx.nonce, icTx.options\n        );\n\n        require(icTx.transactionId == reconstructedID, \"Invalid transaction ID\");\n\n        (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules) =\n                        _getAppConfig(TypeCasts.bytes32ToAddress(icTx.dstReceiver));\n\n        uint256[] memory approvedResponses = _getApprovedResponses(approvedDstModules, icEntry);\n\n        uint256 finalizedResponses = _getFinalizedResponsesCount(approvedResponses, optimisticTimePeriod);\n        require(finalizedResponses \u003e= requiredResponses, \"Not enough valid responses to meet the threshold\");\n        return true;\n    }\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedResponses An array of timestamps when each approved response was recorded.\n     * @param optimisticTimePeriod The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses The count of responses that are finalized within the optimistic time period.\n     */\n\n    function _getFinalizedResponsesCount(\n        uint256[] memory approvedResponses,\n        uint256 optimisticTimePeriod\n    )\n    internal\n    view\n    returns (uint256)\n    {\n        uint256 finalizedResponses = 0;\n        for (uint256 i = 0; i \u003c approvedResponses.length; i++) {\n            if (approvedResponses[i] + optimisticTimePeriod \u003c= block.timestamp) {\n                finalizedResponses++;\n            }\n        }\n        return finalizedResponses;\n    }\n    /**\n     * @dev Retrieves the responses from approved modules for a given InterchainEntry.\n     * This function iterates over all approved modules, querying the InterchainDB for each module's response\n     * to the provided InterchainEntry. It compiles these responses into an array of uint256, where each\n     * element represents the timestamp of a module's response.\n     *\n     * @param approvedModules An array of addresses representing the approved modules that can write responses.\n     * @param icEntry The InterchainEntry for which responses are being retrieved.\n     * @return approvedResponses An array of uint256 representing the timestamps of responses from approved modules.\n     */\n\n    function _getApprovedResponses(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry\n    )\n    internal\n    view\n    returns (uint256[] memory)\n    {\n        uint256[] memory approvedResponses = new uint256[](approvedModules.length);\n        for (uint256 i = 0; i \u003c approvedModules.length; i++) {\n            approvedResponses[i] = IInterchainDB(interchainDB).readEntry(approvedModules[i], icEntry);\n        }\n        return approvedResponses;\n    }\n\n    function encodeTransaction(InterchainTransaction memory icTx) public view returns (bytes memory) {\n        return abi.encode(icTx);\n    }\n\n    // TODO: Gas Fee Consideration that is paid to executor\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(bytes calldata transaction) public {\n        require(isExecutable(transaction), \"Transaction is not executable\");\n        InterchainTransaction memory icTx = abi.decode(transaction, (InterchainTransaction));\n        executedTransactions[icTx.transactionId] = true;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: decodedOptions.gasLimit}();\n        emit InterchainTransactionExecuted(\n            icTx.srcSender,\n            icTx.srcChainId,\n            icTx.dstReceiver,\n            icTx.dstChainId,\n            icTx.message,\n            icTx.nonce,\n            icTx.options,\n            icTx.transactionId,\n            icTx.dbWriterNonce\n        );\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Contract module which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. The initial owner is set to the address provided by the deployer. This can later be changed with {transferOwnership}. This module is used through inheritance. It will make available the modifier `onlyOwner`, which can be applied to your functions to restrict their use to the owner.","errors":{"OwnableInvalidOwner(address)":[{"details":"The owner is not a valid owner account. (eg. `address(0)`)"}],"OwnableUnauthorizedAccount(address)":[{"details":"The caller account is not authorized to perform an operation."}]},"kind":"dev","methods":{"constructor":{"details":"Initializes the contract setting the address provided by the deployer as the initial owner."},"owner()":{"details":"Returns the address of the current owner."},"renounceOwnership()":{"details":"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."},"transferOwnership(address)":{"details":"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Contract module which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. The initial owner is set to the address provided by the deployer. This can later be changed with {transferOwnership}. This module is used through inheritance. It will make available the modifier `onlyOwner`, which can be applied to your functions to restrict their use to the owner.\",\"errors\":{\"OwnableInvalidOwner(address)\":[{\"details\":\"The owner is not a valid owner account. (eg. `address(0)`)\"}],\"OwnableUnauthorizedAccount(address)\":[{\"details\":\"The caller account is not authorized to perform an operation.\"}]},\"kind\":\"dev\",\"methods\":{\"constructor\":{\"details\":\"Initializes the contract setting the address provided by the deployer as the initial owner.\"},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"Ownable\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0x44c9e0bf0e33c29df6b63f8909747984d3ad8c376a763f57eaa613086c22bb2c\",\"urls\":[\"bzz-raw://f5ad81ebeb36f44c014dbf8fe28dc9747b29eea33cc2d37a5d245fdbb1ef06f8\",\"dweb:/ipfs/QmW4JUaEBdaochJpLMphHqqu1WUrYxjESNET4HciC2jXtX\"]}},\"version\":1}"},"hashes":{"owner()":"8da5cb5b","renounceOwnership()":"715018a6","transferOwnership(address)":"f2fde38b"}},"solidity/InterchainClientV1.sol:TypeCasts":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220ce5f2bffddbfd513e42bbe475ea3a36c46e78ac7f69d8ebaaf48a99dd98f1e5c64736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220ce5f2bffddbfd513e42bbe475ea3a36c46e78ac7f69d8ebaaf48a99dd98f1e5c64736f6c63430008140033","info":{"source":"pragma solidity 0.8.20;\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n/// @notice Struct representing an entry in the Interchain DataBase\n/// @param srcChainId   The chain id of the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param writerNonce  The nonce of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    bytes32 srcWriter;\n    uint256 writerNonce;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param srcWriter    The address of the writer on the local chain\n    /// @param writerNonce  The nonce of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        address srcWriter,\n        uint256 writerNonce,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            srcWriter: TypeCasts.addressToBytes32(srcWriter),\n            writerNonce: writerNonce,\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryId(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.srcWriter, entry.writerNonce));\n    }\n}\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param dataHash     The hash of the data written on the source chain\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 dataHash;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingDataHash, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(address writer, uint256 writerNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntry(bytes32 dataHash) external returns (uint256 writerNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param writer        The address of the writer on the source chain\n    /// @param writerNonce   The nonce of the writer on the source chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(\n        uint256 destChainId,\n        address writer,\n        uint256 writerNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 writerNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param writer       The address of the writer on this chain\n    /// @param writerNonce  The nonce of the writer's entry on this chain\n    function getEntry(address writer, uint256 writerNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the writer on this chain.\n    /// @param writer       The address of the writer on this chain\n    function getWriterNonce(address writer) external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\ninterface IInterchainApp {\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory sendingModules,\n        address[] memory receivingModules,\n        uint256 requiredResponses,\n        uint64 optimisticTimePeriod\n    )\n        external;\n\n    function getLinkedIApp(uint64 chainID) external view returns (address);\n\n    function getSendingModules() external view returns (address[] memory);\n\n    function getReceivingModules() external view returns (address[] memory);\n\n    function getRequiredResponses() external view returns (uint256);\n\n    function getOptimisticTimePeriod() external view returns (uint64);\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable;\n\n    function appReceive() external;\n}\n\ninterface IInterchainClientV1 {\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sets the address of the InterchainDB contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param _interchainDB The address of the InterchainDB contract.\n     */\n    function setInterchainDB(address _interchainDB) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param message The message being sent.\n     * @param options Execution options for the message sent, encoded as bytes, currently primarily gas limit + native gas drop.\n     * @param srcModules The source modules involved in the message sending.\n     */\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        bytes calldata options,\n        address[] calldata srcModules\n    )\n        external\n        payable;\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * @param transaction The transaction data.\n     */\n    function interchainExecute(bytes calldata transaction) external;\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction The InterchainTransaction struct to be checked.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction) external view returns (bool);\n}\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    uint8 constant OPTIONS_V1 = 1;\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, IInterchainClientV1 {\n    using OptionsLib for bytes;\n\n    uint64 public clientNonce;\n    address public interchainDB;\n    mapping(bytes32 =\u003e bool) public executedTransactions;\n\n    // Chain ID =\u003e Bytes32 Address of src clients\n    mapping(uint256 =\u003e bytes32) public linkedClients;\n\n    // TODO: Add permissioning\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint256 chainId, bytes32 client) public onlyOwner {\n        linkedClients[chainId] = client;\n    }\n\n    constructor() Ownable(msg.sender) {}\n\n    // @inheritdoc IInterchainClientV1\n    function setInterchainDB(address _interchainDB) public onlyOwner {\n        interchainDB = _interchainDB;\n    }\n\n    /**\n     * @notice Emitted when an interchain transaction is sent.\n     */\n    event InterchainTransactionSent(\n        bytes32 srcSender,\n        uint256 srcChainId,\n        bytes32 indexed dstReceiver,\n        uint256 indexed dstChainId,\n        bytes message,\n        uint64 nonce,\n        bytes options,\n        bytes32 indexed transactionId,\n        uint256 dbWriterNonce\n    );\n\n    // @notice Emitted when an interchain transaction is executed.\n    // TODO: Indexing\n    event InterchainTransactionExecuted(\n        bytes32 indexed srcSender,\n        uint256 indexed srcChainId,\n        bytes32 dstReceiver,\n        uint256 dstChainId,\n        bytes message,\n        uint64 nonce,\n        bytes options,\n        bytes32 indexed transactionId,\n        uint256 dbWriterNonce\n    );\n\n    /**\n     * @dev Represents an interchain transaction.\n     */\n    struct InterchainTransaction {\n        bytes32 srcSender;\n        uint256 srcChainId;\n        bytes32 dstReceiver;\n        uint256 dstChainId;\n        bytes message;\n        uint64 nonce;\n        bytes options;\n        bytes32 transactionId;\n        uint256 dbWriterNonce;\n    }\n\n    function _generateTransactionId(\n        bytes32 srcSender,\n        uint256 srcChainId,\n        bytes32 dstReceiver,\n        uint256 dstChainId,\n        bytes memory message,\n        uint64 nonce,\n        bytes memory options\n    )\n    internal\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encode(srcSender, srcChainId, dstReceiver, dstChainId, message, nonce, options));\n    }\n\n    // TODO: Calculate Gas Pricing per module and charge fees\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        bytes32 receiver,\n        uint256 dstChainId,\n        bytes calldata message,\n        bytes calldata options,\n        address[] calldata srcModules\n    )\n    public\n    payable\n    {\n        uint256 totalModuleFees = msg.value;\n\n        InterchainTransaction memory icTx = InterchainTransaction({\n            srcSender: TypeCasts.addressToBytes32(msg.sender),\n            srcChainId: block.chainid,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            message: message,\n            nonce: clientNonce,\n            options: options,\n            transactionId: 0,\n            dbWriterNonce: 0\n        });\n\n        bytes32 transactionId = _generateTransactionId(\n            icTx.srcSender, icTx.srcChainId, icTx.dstReceiver, icTx.dstChainId, icTx.message, icTx.nonce, icTx.options\n        );\n        icTx.transactionId = transactionId;\n\n        uint256 dbWriterNonce = IInterchainDB(interchainDB).writeEntryWithVerification{value: totalModuleFees}(\n            icTx.dstChainId, icTx.transactionId, srcModules\n        );\n        icTx.dbWriterNonce = dbWriterNonce;\n\n        emit InterchainTransactionSent(\n            icTx.srcSender,\n            icTx.srcChainId,\n            icTx.dstReceiver,\n            icTx.dstChainId,\n            icTx.message,\n            icTx.nonce,\n            icTx.options,\n            icTx.transactionId,\n            icTx.dbWriterNonce\n        );\n        // Increment nonce for next message\n        clientNonce++;\n    }\n\n    // TODO: App Config Versioning\n    // TODO: What if receiver is not a contract / doesn't conform to interface?\n    /**\n     * @dev Retrieves the application configuration for a given receiver application.\n     * @param receiverApp The address of the receiver application.\n     * @return requiredResponses The number of required responses from the receiving modules.\n     * @return optimisticTimePeriod The time period within which responses are considered valid.\n     * @return approvedDstModules An array of addresses of the approved destination modules.\n     */\n    function _getAppConfig(address receiverApp)\n    internal\n    view\n    returns (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules)\n    {\n        requiredResponses = IInterchainApp(receiverApp).getRequiredResponses();\n        optimisticTimePeriod = IInterchainApp(receiverApp).getOptimisticTimePeriod();\n        approvedDstModules = IInterchainApp(receiverApp).getReceivingModules();\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata transaction) public view returns (bool) {\n        InterchainTransaction memory icTx = abi.decode(transaction, (InterchainTransaction));\n        require(executedTransactions[icTx.transactionId] == false, \"Transaction already executed\");\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            srcWriter: linkedClients[icTx.srcChainId],\n            writerNonce: icTx.dbWriterNonce,\n            dataHash: icTx.transactionId\n        });\n\n        bytes32 reconstructedID = _generateTransactionId(\n            icTx.srcSender, icTx.srcChainId, icTx.dstReceiver, icTx.dstChainId, icTx.message, icTx.nonce, icTx.options\n        );\n\n        require(icTx.transactionId == reconstructedID, \"Invalid transaction ID\");\n\n        (uint256 requiredResponses, uint256 optimisticTimePeriod, address[] memory approvedDstModules) =\n                        _getAppConfig(TypeCasts.bytes32ToAddress(icTx.dstReceiver));\n\n        uint256[] memory approvedResponses = _getApprovedResponses(approvedDstModules, icEntry);\n\n        uint256 finalizedResponses = _getFinalizedResponsesCount(approvedResponses, optimisticTimePeriod);\n        require(finalizedResponses \u003e= requiredResponses, \"Not enough valid responses to meet the threshold\");\n        return true;\n    }\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedResponses An array of timestamps when each approved response was recorded.\n     * @param optimisticTimePeriod The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses The count of responses that are finalized within the optimistic time period.\n     */\n\n    function _getFinalizedResponsesCount(\n        uint256[] memory approvedResponses,\n        uint256 optimisticTimePeriod\n    )\n    internal\n    view\n    returns (uint256)\n    {\n        uint256 finalizedResponses = 0;\n        for (uint256 i = 0; i \u003c approvedResponses.length; i++) {\n            if (approvedResponses[i] + optimisticTimePeriod \u003c= block.timestamp) {\n                finalizedResponses++;\n            }\n        }\n        return finalizedResponses;\n    }\n    /**\n     * @dev Retrieves the responses from approved modules for a given InterchainEntry.\n     * This function iterates over all approved modules, querying the InterchainDB for each module's response\n     * to the provided InterchainEntry. It compiles these responses into an array of uint256, where each\n     * element represents the timestamp of a module's response.\n     *\n     * @param approvedModules An array of addresses representing the approved modules that can write responses.\n     * @param icEntry The InterchainEntry for which responses are being retrieved.\n     * @return approvedResponses An array of uint256 representing the timestamps of responses from approved modules.\n     */\n\n    function _getApprovedResponses(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry\n    )\n    internal\n    view\n    returns (uint256[] memory)\n    {\n        uint256[] memory approvedResponses = new uint256[](approvedModules.length);\n        for (uint256 i = 0; i \u003c approvedModules.length; i++) {\n            approvedResponses[i] = IInterchainDB(interchainDB).readEntry(approvedModules[i], icEntry);\n        }\n        return approvedResponses;\n    }\n\n    function encodeTransaction(InterchainTransaction memory icTx) public view returns (bytes memory) {\n        return abi.encode(icTx);\n    }\n\n    // TODO: Gas Fee Consideration that is paid to executor\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(bytes calldata transaction) public {\n        require(isExecutable(transaction), \"Transaction is not executable\");\n        InterchainTransaction memory icTx = abi.decode(transaction, (InterchainTransaction));\n        executedTransactions[icTx.transactionId] = true;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: decodedOptions.gasLimit}();\n        emit InterchainTransactionExecuted(\n            icTx.srcSender,\n            icTx.srcChainId,\n            icTx.dstReceiver,\n            icTx.dstChainId,\n            icTx.message,\n            icTx.nonce,\n            icTx.options,\n            icTx.transactionId,\n            icTx.dbWriterNonce\n        );\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"3929:280:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;3929:280:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"3929:280:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"TypeCasts\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0x44c9e0bf0e33c29df6b63f8909747984d3ad8c376a763f57eaa613086c22bb2c\",\"urls\":[\"bzz-raw://f5ad81ebeb36f44c014dbf8fe28dc9747b29eea33cc2d37a5d245fdbb1ef06f8\",\"dweb:/ipfs/QmW4JUaEBdaochJpLMphHqqu1WUrYxjESNET4HciC2jXtX\"]}},\"version\":1}"},"hashes":{}}}