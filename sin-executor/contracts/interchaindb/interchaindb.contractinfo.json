{"solidity/InterchainDB.sol:IInterchainDB":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nabstract contract InterchainDBEvents {\n    // TODO: figure out indexing\n    event InterchainEntryWritten(uint256 srcChainId, bytes32 srcWriter, uint256 writerNonce, bytes32 dataHash);\n    event InterchainEntryVerified(\n        address module, uint256 srcChainId, bytes32 srcWriter, uint256 writerNonce, bytes32 dataHash\n    );\n\n    event InterchainVerificationRequested(\n        uint256 destChainId, bytes32 srcWriter, uint256 writerNonce, address[] srcModules\n    );\n}\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n/// @notice Struct representing an entry in the Interchain DataBase\n/// @param srcChainId   The chain id of the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param writerNonce  The nonce of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    bytes32 srcWriter;\n    uint256 writerNonce;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param srcWriter    The address of the writer on the local chain\n    /// @param writerNonce  The nonce of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        address srcWriter,\n        uint256 writerNonce,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            srcWriter: TypeCasts.addressToBytes32(srcWriter),\n            writerNonce: writerNonce,\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryId(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.srcWriter, entry.writerNonce));\n    }\n}\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param dataHash     The hash of the data written on the source chain\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 dataHash;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingDataHash, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(address writer, uint256 writerNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntry(bytes32 dataHash) external returns (uint256 writerNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param writer        The address of the writer on the source chain\n    /// @param writerNonce   The nonce of the writer on the source chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(\n        uint256 destChainId,\n        address writer,\n        uint256 writerNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 writerNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param writer       The address of the writer on this chain\n    /// @param writerNonce  The nonce of the writer's entry on this chain\n    function getEntry(address writer, uint256 writerNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the writer on this chain.\n    /// @param writer       The address of the writer on this chain\n    function getWriterNonce(address writer) external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB();\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId();\n\n    /// @notice Request the verification of an entry in the Interchain DataBase by the module.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyEntry(entry)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param entry        The entry to verify\n    function requestVerification(uint256 destChainId, InterchainEntry memory entry) external payable;\n\n    /// @notice Get the Module fee for verifying an entry on the specified destination chain\n    /// @param destChainId  The chain id of the destination chain\n    function getModuleFee(uint256 destChainId) external view returns (uint256);\n}\n\ncontract InterchainDB is InterchainDBEvents, IInterchainDB {\n    mapping(address writer =\u003e bytes32[] dataHashes) internal _entries;\n    mapping(bytes32 entryId =\u003e mapping(address module =\u003e RemoteEntry entry)) internal _remoteEntries;\n\n    modifier onlyRemoteChainId(uint256 chainId) {\n        if (chainId == block.chainid) {\n            revert InterchainDB__SameChainId();\n        }\n        _;\n    }\n\n    // ═══════════════════════════════════════════════ WRITER-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function writeEntry(bytes32 dataHash) external returns (uint256 writerNonce) {\n        return _writeEntry(dataHash);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function requestVerification(\n        uint256 destChainId,\n        address writer,\n        uint256 writerNonce,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(destChainId)\n    {\n        InterchainEntry memory entry = getEntry(writer, writerNonce);\n        _requestVerification(destChainId, entry, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(destChainId)\n        returns (uint256 writerNonce)\n    {\n        writerNonce = _writeEntry(dataHash);\n        InterchainEntry memory entry = InterchainEntryLib.constructLocalEntry(msg.sender, writerNonce, dataHash);\n        _requestVerification(destChainId, entry, srcModules);\n    }\n\n    // ═══════════════════════════════════════════════ MODULE-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function verifyEntry(InterchainEntry memory entry) external onlyRemoteChainId(entry.srcChainId) {\n        bytes32 entryId = InterchainEntryLib.entryId(entry);\n        RemoteEntry memory existingEntry = _remoteEntries[entryId][msg.sender];\n        // Check if that's the first time module verifies the entry\n        if (existingEntry.verifiedAt == 0) {\n            _remoteEntries[entryId][msg.sender] = RemoteEntry({verifiedAt: block.timestamp, dataHash: entry.dataHash});\n            emit InterchainEntryVerified(\n                msg.sender, entry.srcChainId, entry.srcWriter, entry.writerNonce, entry.dataHash\n            );\n        } else {\n            // If the module has already verified the entry, check that the data hash is the same\n            if (existingEntry.dataHash != entry.dataHash) {\n                revert InterchainDB__ConflictingEntries(existingEntry.dataHash, entry);\n            }\n            // No-op if the data hash is the same\n        }\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        onlyRemoteChainId(entry.srcChainId)\n        returns (uint256 moduleVerifiedAt)\n    {\n        RemoteEntry memory remoteEntry = _remoteEntries[InterchainEntryLib.entryId(entry)][dstModule];\n        // Check data against the one verified by the module\n        return remoteEntry.dataHash == entry.dataHash ? remoteEntry.verifiedAt : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getInterchainFee(uint256 destChainId, address[] calldata srcModules) external view returns (uint256 fee) {\n        (, fee) = _getModuleFees(destChainId, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntry(address writer, uint256 writerNonce) public view returns (InterchainEntry memory) {\n        if (getWriterNonce(writer) \u003c= writerNonce) {\n            revert InterchainDB__EntryDoesNotExist(writer, writerNonce);\n        }\n        return InterchainEntryLib.constructLocalEntry(writer, writerNonce, _entries[writer][writerNonce]);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getWriterNonce(address writer) public view returns (uint256) {\n        return _entries[writer].length;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Write the entry to the database and emit the event.\n    function _writeEntry(bytes32 dataHash) internal returns (uint256 writerNonce) {\n        writerNonce = _entries[msg.sender].length;\n        _entries[msg.sender].push(dataHash);\n        emit InterchainEntryWritten(block.chainid, TypeCasts.addressToBytes32(msg.sender), writerNonce, dataHash);\n    }\n\n    /// @dev Request the verification of the entry by the modules, and emit the event.\n    /// Note: the validity of the passed entry and chain id being remote is enforced in the calling function.\n    function _requestVerification(\n        uint256 destChainId,\n        InterchainEntry memory entry,\n        address[] calldata srcModules\n    )\n        internal\n    {\n        (uint256[] memory fees, uint256 totalFee) = _getModuleFees(destChainId, srcModules);\n        if (msg.value != totalFee) {\n            revert InterchainDB__IncorrectFeeAmount(msg.value, totalFee);\n        }\n        uint256 len = srcModules.length;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            IInterchainModule(srcModules[i]).requestVerification{value: fees[i]}(destChainId, entry);\n        }\n        emit InterchainVerificationRequested(destChainId, entry.srcWriter, entry.writerNonce, srcModules);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Get the verification fees for the modules\n    function _getModuleFees(\n        uint256 destChainId,\n        address[] calldata srcModules\n    )\n        internal\n        view\n        returns (uint256[] memory fees, uint256 totalFee)\n    {\n        uint256 len = srcModules.length;\n        if (len == 0) {\n            revert InterchainDB__NoModulesSpecified();\n        }\n        fees = new uint256[](len);\n        for (uint256 i = 0; i \u003c len; ++i) {\n            fees[i] = IInterchainModule(srcModules[i]).getModuleFee(destChainId);\n            totalFee += fees[i];\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"bytes32","name":"existingDataHash","type":"bytes32"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"uint256","name":"writerNonce","type":"uint256"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"newEntry","type":"tuple"}],"name":"InterchainDB__ConflictingEntries","type":"error"},{"inputs":[{"internalType":"address","name":"writer","type":"address"},{"internalType":"uint256","name":"writerNonce","type":"uint256"}],"name":"InterchainDB__EntryDoesNotExist","type":"error"},{"inputs":[{"internalType":"uint256","name":"actualFee","type":"uint256"},{"internalType":"uint256","name":"expectedFee","type":"uint256"}],"name":"InterchainDB__IncorrectFeeAmount","type":"error"},{"inputs":[],"name":"InterchainDB__NoModulesSpecified","type":"error"},{"inputs":[],"name":"InterchainDB__SameChainId","type":"error"},{"inputs":[{"internalType":"address","name":"writer","type":"address"},{"internalType":"uint256","name":"writerNonce","type":"uint256"}],"name":"getEntry","outputs":[{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"uint256","name":"writerNonce","type":"uint256"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"getInterchainFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"writer","type":"address"}],"name":"getWriterNonce","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"dstModule","type":"address"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"uint256","name":"writerNonce","type":"uint256"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"entry","type":"tuple"}],"name":"readEntry","outputs":[{"internalType":"uint256","name":"moduleVerifiedAt","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"internalType":"address","name":"writer","type":"address"},{"internalType":"uint256","name":"writerNonce","type":"uint256"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"requestVerification","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"uint256","name":"writerNonce","type":"uint256"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"entry","type":"tuple"}],"name":"verifyEntry","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"name":"writeEntry","outputs":[{"internalType":"uint256","name":"writerNonce","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"writeEntryWithVerification","outputs":[{"internalType":"uint256","name":"writerNonce","type":"uint256"}],"stateMutability":"payable","type":"function"}],"userDoc":{"kind":"user","methods":{"getEntry(address,uint256)":{"notice":"Get the Interchain Entry by the writer and the writer nonce."},"getInterchainFee(uint256,address[])":{"notice":"Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain using the provided Interchain Modules."},"getWriterNonce(address)":{"notice":"Get the nonce of the writer on this chain."},"readEntry(address,(uint256,bytes32,uint256,bytes32))":{"notice":"Read the data written on specific source chain by a specific writer, and verify it on the destination chain using the provided Interchain Module. Note: returned zero value indicates that the module has not verified the entry."},"requestVerification(uint256,address,uint256,address[])":{"notice":"Request the given Interchain Modules to verify the already written entry on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: this method is permissionless, and anyone can request verification for any entry."},"verifyEntry((uint256,bytes32,uint256,bytes32))":{"notice":"Allows the Interchain Module to verify the entry coming from a remote source chain."},"writeEntry(bytes32)":{"notice":"Write data to the Interchain DataBase as a new entry. Note: there are no guarantees that this entry will be available for reading on any of the remote chains. Use `verifyEntry` to ensure that the entry is available for reading on the destination chain."},"writeEntryWithVerification(uint256,bytes32,address[])":{"notice":"Write data to the Interchain DataBase, and request the given Interchain Modules to verify it on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: additional verification for the same entry could be later done using `requestVerification`."}},"version":1},"developerDoc":{"kind":"dev","methods":{"getEntry(address,uint256)":{"details":"Will revert if the entry with the given nonce does not exist.","params":{"writer":"The address of the writer on this chain","writerNonce":"The nonce of the writer's entry on this chain"}},"getInterchainFee(uint256,address[])":{"details":"Will revert if the empty array of modules is provided.","params":{"destChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"}},"getWriterNonce(address)":{"params":{"writer":"The address of the writer on this chain"}},"readEntry(address,(uint256,bytes32,uint256,bytes32))":{"params":{"dstModule":"The destination chain addresses of the Interchain Modules to use for verification","entry":"The Interchain Entry to read"},"returns":{"moduleVerifiedAt":"  The block timestamp at which the entry was verified by the module,                             or zero if the module has not verified the entry."}},"requestVerification(uint256,address,uint256,address[])":{"details":"Will revert if the entry with the given nonce does not exist.","params":{"destChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification","writer":"The address of the writer on the source chain","writerNonce":"The nonce of the writer on the source chain"}},"verifyEntry((uint256,bytes32,uint256,bytes32))":{"params":{"entry":"The Interchain Entry to confirm"}},"writeEntry(bytes32)":{"params":{"dataHash":"The hash of the data to be written to the Interchain DataBase as a new entry"},"returns":{"writerNonce":"The writer-specific nonce of the written entry"}},"writeEntryWithVerification(uint256,bytes32,address[])":{"details":"Will revert if the empty array of modules is provided.","params":{"dataHash":"The hash of the data to be written to the Interchain DataBase as a new entry","destChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"},"returns":{"writerNonce":"The writer-specific nonce of the written entry"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"existingDataHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"newEntry\",\"type\":\"tuple\"}],\"name\":\"InterchainDB__ConflictingEntries\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"writer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__EntryDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actualFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedFee\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__IncorrectFeeAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainDB__NoModulesSpecified\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainDB__SameChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"writer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"}],\"name\":\"getEntry\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"getInterchainFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"writer\",\"type\":\"address\"}],\"name\":\"getWriterNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dstModule\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"entry\",\"type\":\"tuple\"}],\"name\":\"readEntry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"moduleVerifiedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"writer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"requestVerification\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"entry\",\"type\":\"tuple\"}],\"name\":\"verifyEntry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"writeEntry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"writeEntryWithVerification\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getEntry(address,uint256)\":{\"details\":\"Will revert if the entry with the given nonce does not exist.\",\"params\":{\"writer\":\"The address of the writer on this chain\",\"writerNonce\":\"The nonce of the writer's entry on this chain\"}},\"getInterchainFee(uint256,address[])\":{\"details\":\"Will revert if the empty array of modules is provided.\",\"params\":{\"destChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"}},\"getWriterNonce(address)\":{\"params\":{\"writer\":\"The address of the writer on this chain\"}},\"readEntry(address,(uint256,bytes32,uint256,bytes32))\":{\"params\":{\"dstModule\":\"The destination chain addresses of the Interchain Modules to use for verification\",\"entry\":\"The Interchain Entry to read\"},\"returns\":{\"moduleVerifiedAt\":\"  The block timestamp at which the entry was verified by the module,                             or zero if the module has not verified the entry.\"}},\"requestVerification(uint256,address,uint256,address[])\":{\"details\":\"Will revert if the entry with the given nonce does not exist.\",\"params\":{\"destChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\",\"writer\":\"The address of the writer on the source chain\",\"writerNonce\":\"The nonce of the writer on the source chain\"}},\"verifyEntry((uint256,bytes32,uint256,bytes32))\":{\"params\":{\"entry\":\"The Interchain Entry to confirm\"}},\"writeEntry(bytes32)\":{\"params\":{\"dataHash\":\"The hash of the data to be written to the Interchain DataBase as a new entry\"},\"returns\":{\"writerNonce\":\"The writer-specific nonce of the written entry\"}},\"writeEntryWithVerification(uint256,bytes32,address[])\":{\"details\":\"Will revert if the empty array of modules is provided.\",\"params\":{\"dataHash\":\"The hash of the data to be written to the Interchain DataBase as a new entry\",\"destChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"},\"returns\":{\"writerNonce\":\"The writer-specific nonce of the written entry\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getEntry(address,uint256)\":{\"notice\":\"Get the Interchain Entry by the writer and the writer nonce.\"},\"getInterchainFee(uint256,address[])\":{\"notice\":\"Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain using the provided Interchain Modules.\"},\"getWriterNonce(address)\":{\"notice\":\"Get the nonce of the writer on this chain.\"},\"readEntry(address,(uint256,bytes32,uint256,bytes32))\":{\"notice\":\"Read the data written on specific source chain by a specific writer, and verify it on the destination chain using the provided Interchain Module. Note: returned zero value indicates that the module has not verified the entry.\"},\"requestVerification(uint256,address,uint256,address[])\":{\"notice\":\"Request the given Interchain Modules to verify the already written entry on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: this method is permissionless, and anyone can request verification for any entry.\"},\"verifyEntry((uint256,bytes32,uint256,bytes32))\":{\"notice\":\"Allows the Interchain Module to verify the entry coming from a remote source chain.\"},\"writeEntry(bytes32)\":{\"notice\":\"Write data to the Interchain DataBase as a new entry. Note: there are no guarantees that this entry will be available for reading on any of the remote chains. Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\"},\"writeEntryWithVerification(uint256,bytes32,address[])\":{\"notice\":\"Write data to the Interchain DataBase, and request the given Interchain Modules to verify it on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: additional verification for the same entry could be later done using `requestVerification`.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainDB.sol\":\"IInterchainDB\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainDB.sol\":{\"keccak256\":\"0x087d4318b29d40d2b45c6ef3909d5b1794c60b51291a13e3d4579914f656ab4c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://763c2e4e618842030e6ad710546ee1b7c77ac2780bdceabf64a18f0f3a253261\",\"dweb:/ipfs/QmbzwHDf9Y2WsSSKMMgGdU92cJCcD55CVi2GoDL7QTVfUL\"]}},\"version\":1}"},"hashes":{"getEntry(address,uint256)":"b8a740e0","getInterchainFee(uint256,address[])":"fc7686ec","getWriterNonce(address)":"4a30a686","readEntry(address,(uint256,bytes32,uint256,bytes32))":"d48588e0","requestVerification(uint256,address,uint256,address[])":"b4f16bae","verifyEntry((uint256,bytes32,uint256,bytes32))":"9cbc6dd5","writeEntry(bytes32)":"2ad8c706","writeEntryWithVerification(uint256,bytes32,address[])":"67c769af"}},"solidity/InterchainDB.sol:IInterchainModule":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nabstract contract InterchainDBEvents {\n    // TODO: figure out indexing\n    event InterchainEntryWritten(uint256 srcChainId, bytes32 srcWriter, uint256 writerNonce, bytes32 dataHash);\n    event InterchainEntryVerified(\n        address module, uint256 srcChainId, bytes32 srcWriter, uint256 writerNonce, bytes32 dataHash\n    );\n\n    event InterchainVerificationRequested(\n        uint256 destChainId, bytes32 srcWriter, uint256 writerNonce, address[] srcModules\n    );\n}\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n/// @notice Struct representing an entry in the Interchain DataBase\n/// @param srcChainId   The chain id of the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param writerNonce  The nonce of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    bytes32 srcWriter;\n    uint256 writerNonce;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param srcWriter    The address of the writer on the local chain\n    /// @param writerNonce  The nonce of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        address srcWriter,\n        uint256 writerNonce,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            srcWriter: TypeCasts.addressToBytes32(srcWriter),\n            writerNonce: writerNonce,\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryId(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.srcWriter, entry.writerNonce));\n    }\n}\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param dataHash     The hash of the data written on the source chain\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 dataHash;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingDataHash, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(address writer, uint256 writerNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntry(bytes32 dataHash) external returns (uint256 writerNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param writer        The address of the writer on the source chain\n    /// @param writerNonce   The nonce of the writer on the source chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(\n        uint256 destChainId,\n        address writer,\n        uint256 writerNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 writerNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param writer       The address of the writer on this chain\n    /// @param writerNonce  The nonce of the writer's entry on this chain\n    function getEntry(address writer, uint256 writerNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the writer on this chain.\n    /// @param writer       The address of the writer on this chain\n    function getWriterNonce(address writer) external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB();\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId();\n\n    /// @notice Request the verification of an entry in the Interchain DataBase by the module.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyEntry(entry)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param entry        The entry to verify\n    function requestVerification(uint256 destChainId, InterchainEntry memory entry) external payable;\n\n    /// @notice Get the Module fee for verifying an entry on the specified destination chain\n    /// @param destChainId  The chain id of the destination chain\n    function getModuleFee(uint256 destChainId) external view returns (uint256);\n}\n\ncontract InterchainDB is InterchainDBEvents, IInterchainDB {\n    mapping(address writer =\u003e bytes32[] dataHashes) internal _entries;\n    mapping(bytes32 entryId =\u003e mapping(address module =\u003e RemoteEntry entry)) internal _remoteEntries;\n\n    modifier onlyRemoteChainId(uint256 chainId) {\n        if (chainId == block.chainid) {\n            revert InterchainDB__SameChainId();\n        }\n        _;\n    }\n\n    // ═══════════════════════════════════════════════ WRITER-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function writeEntry(bytes32 dataHash) external returns (uint256 writerNonce) {\n        return _writeEntry(dataHash);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function requestVerification(\n        uint256 destChainId,\n        address writer,\n        uint256 writerNonce,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(destChainId)\n    {\n        InterchainEntry memory entry = getEntry(writer, writerNonce);\n        _requestVerification(destChainId, entry, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(destChainId)\n        returns (uint256 writerNonce)\n    {\n        writerNonce = _writeEntry(dataHash);\n        InterchainEntry memory entry = InterchainEntryLib.constructLocalEntry(msg.sender, writerNonce, dataHash);\n        _requestVerification(destChainId, entry, srcModules);\n    }\n\n    // ═══════════════════════════════════════════════ MODULE-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function verifyEntry(InterchainEntry memory entry) external onlyRemoteChainId(entry.srcChainId) {\n        bytes32 entryId = InterchainEntryLib.entryId(entry);\n        RemoteEntry memory existingEntry = _remoteEntries[entryId][msg.sender];\n        // Check if that's the first time module verifies the entry\n        if (existingEntry.verifiedAt == 0) {\n            _remoteEntries[entryId][msg.sender] = RemoteEntry({verifiedAt: block.timestamp, dataHash: entry.dataHash});\n            emit InterchainEntryVerified(\n                msg.sender, entry.srcChainId, entry.srcWriter, entry.writerNonce, entry.dataHash\n            );\n        } else {\n            // If the module has already verified the entry, check that the data hash is the same\n            if (existingEntry.dataHash != entry.dataHash) {\n                revert InterchainDB__ConflictingEntries(existingEntry.dataHash, entry);\n            }\n            // No-op if the data hash is the same\n        }\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        onlyRemoteChainId(entry.srcChainId)\n        returns (uint256 moduleVerifiedAt)\n    {\n        RemoteEntry memory remoteEntry = _remoteEntries[InterchainEntryLib.entryId(entry)][dstModule];\n        // Check data against the one verified by the module\n        return remoteEntry.dataHash == entry.dataHash ? remoteEntry.verifiedAt : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getInterchainFee(uint256 destChainId, address[] calldata srcModules) external view returns (uint256 fee) {\n        (, fee) = _getModuleFees(destChainId, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntry(address writer, uint256 writerNonce) public view returns (InterchainEntry memory) {\n        if (getWriterNonce(writer) \u003c= writerNonce) {\n            revert InterchainDB__EntryDoesNotExist(writer, writerNonce);\n        }\n        return InterchainEntryLib.constructLocalEntry(writer, writerNonce, _entries[writer][writerNonce]);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getWriterNonce(address writer) public view returns (uint256) {\n        return _entries[writer].length;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Write the entry to the database and emit the event.\n    function _writeEntry(bytes32 dataHash) internal returns (uint256 writerNonce) {\n        writerNonce = _entries[msg.sender].length;\n        _entries[msg.sender].push(dataHash);\n        emit InterchainEntryWritten(block.chainid, TypeCasts.addressToBytes32(msg.sender), writerNonce, dataHash);\n    }\n\n    /// @dev Request the verification of the entry by the modules, and emit the event.\n    /// Note: the validity of the passed entry and chain id being remote is enforced in the calling function.\n    function _requestVerification(\n        uint256 destChainId,\n        InterchainEntry memory entry,\n        address[] calldata srcModules\n    )\n        internal\n    {\n        (uint256[] memory fees, uint256 totalFee) = _getModuleFees(destChainId, srcModules);\n        if (msg.value != totalFee) {\n            revert InterchainDB__IncorrectFeeAmount(msg.value, totalFee);\n        }\n        uint256 len = srcModules.length;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            IInterchainModule(srcModules[i]).requestVerification{value: fees[i]}(destChainId, entry);\n        }\n        emit InterchainVerificationRequested(destChainId, entry.srcWriter, entry.writerNonce, srcModules);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Get the verification fees for the modules\n    function _getModuleFees(\n        uint256 destChainId,\n        address[] calldata srcModules\n    )\n        internal\n        view\n        returns (uint256[] memory fees, uint256 totalFee)\n    {\n        uint256 len = srcModules.length;\n        if (len == 0) {\n            revert InterchainDB__NoModulesSpecified();\n        }\n        fees = new uint256[](len);\n        for (uint256 i = 0; i \u003c len; ++i) {\n            fees[i] = IInterchainModule(srcModules[i]).getModuleFee(destChainId);\n            totalFee += fees[i];\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainModule__IncorrectSourceChainId","type":"error"},{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"required","type":"uint256"}],"name":"InterchainModule__InsufficientFee","type":"error"},{"inputs":[],"name":"InterchainModule__NotInterchainDB","type":"error"},{"inputs":[],"name":"InterchainModule__SameChainId","type":"error"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"}],"name":"getModuleFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"uint256","name":"writerNonce","type":"uint256"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"entry","type":"tuple"}],"name":"requestVerification","outputs":[],"stateMutability":"payable","type":"function"}],"userDoc":{"kind":"user","methods":{"getModuleFee(uint256)":{"notice":"Get the Module fee for verifying an entry on the specified destination chain"},"requestVerification(uint256,(uint256,bytes32,uint256,bytes32))":{"notice":"Request the verification of an entry in the Interchain DataBase by the module. Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`. Note: this will eventually trigger `InterchainDB.verifyEntry(entry)` function on destination chain, with no guarantee of ordering."}},"notice":"Every Module may opt a different method to confirm the verified entries on destination chain, therefore this is not a part of a common interface.","version":1},"developerDoc":{"kind":"dev","methods":{"getModuleFee(uint256)":{"params":{"destChainId":"The chain id of the destination chain"}},"requestVerification(uint256,(uint256,bytes32,uint256,bytes32))":{"details":"Could be only called by the Interchain DataBase contract.","params":{"destChainId":"The chain id of the destination chain","entry":"The entry to verify"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainModule__IncorrectSourceChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InterchainModule__InsufficientFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainModule__NotInterchainDB\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainModule__SameChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"}],\"name\":\"getModuleFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"entry\",\"type\":\"tuple\"}],\"name\":\"requestVerification\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getModuleFee(uint256)\":{\"params\":{\"destChainId\":\"The chain id of the destination chain\"}},\"requestVerification(uint256,(uint256,bytes32,uint256,bytes32))\":{\"details\":\"Could be only called by the Interchain DataBase contract.\",\"params\":{\"destChainId\":\"The chain id of the destination chain\",\"entry\":\"The entry to verify\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getModuleFee(uint256)\":{\"notice\":\"Get the Module fee for verifying an entry on the specified destination chain\"},\"requestVerification(uint256,(uint256,bytes32,uint256,bytes32))\":{\"notice\":\"Request the verification of an entry in the Interchain DataBase by the module. Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`. Note: this will eventually trigger `InterchainDB.verifyEntry(entry)` function on destination chain, with no guarantee of ordering.\"}},\"notice\":\"Every Module may opt a different method to confirm the verified entries on destination chain, therefore this is not a part of a common interface.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainDB.sol\":\"IInterchainModule\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainDB.sol\":{\"keccak256\":\"0x087d4318b29d40d2b45c6ef3909d5b1794c60b51291a13e3d4579914f656ab4c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://763c2e4e618842030e6ad710546ee1b7c77ac2780bdceabf64a18f0f3a253261\",\"dweb:/ipfs/QmbzwHDf9Y2WsSSKMMgGdU92cJCcD55CVi2GoDL7QTVfUL\"]}},\"version\":1}"},"hashes":{"getModuleFee(uint256)":"dc8e4f89","requestVerification(uint256,(uint256,bytes32,uint256,bytes32))":"e3777216"}},"solidity/InterchainDB.sol:InterchainDB":{"code":"0x608060405234801561001057600080fd5b50610ecc806100206000396000f3fe60806040526004361061007b5760003560e01c8063b4f16bae1161004e578063b4f16bae1461012b578063b8a740e01461013e578063d48588e01461016b578063fc7686ec1461018b57600080fd5b80632ad8c706146100805780634a30a686146100b357806367c769af146100f65780639cbc6dd514610109575b600080fd5b34801561008c57600080fd5b506100a061009b366004610a1a565b6101ab565b6040519081526020015b60405180910390f35b3480156100bf57600080fd5b506100a06100ce366004610a5c565b73ffffffffffffffffffffffffffffffffffffffff1660009081526020819052604090205490565b6100a0610104366004610ac3565b6101bc565b34801561011557600080fd5b50610129610124366004610bd2565b610228565b005b610129610139366004610bee565b6103da565b34801561014a57600080fd5b5061015e610159366004610c56565b610437565b6040516100aa9190610c80565b34801561017757600080fd5b506100a0610186366004610cab565b61053e565b34801561019757600080fd5b506100a06101a6366004610cdf565b610634565b60006101b682610641565b92915050565b6000844681036101f8576040517f0e4de95d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61020185610641565b915060006102103384886106b2565b905061021e8782878761071c565b5050949350505050565b8051468103610263576040517f0e4de95d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006102ae8380516020808301516040808501518151938401949094528201526060810191909152600090608001604051602081830303815290604052805190602001209050919050565b60008181526001602081815260408084203385528252808420815180830190925280548083529301549181019190915292935090036103825760408051808201825242815260608681018051602080850191825260008881526001808352878220338084529084529188902096518755925195909201949094558851848a01518a8701519351875193845295830191909152948101949094529083015260808201527f65fdc92d5fec4c98c387c9fda2326f1d593ce9e39eaafa681d655266d0ff227e9060a00160405180910390a16103d4565b83606001518160200151146103d4578060200151846040517f4ef4ee070000000000000000000000000000000000000000000000000000000081526004016103cb929190610d2b565b60405180910390fd5b50505050565b84468103610414576040517f0e4de95d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006104208686610437565b905061042e8782868661071c565b50505050505050565b60408051608081018252600080825260208083018290528284018290526060830182905273ffffffffffffffffffffffffffffffffffffffff86168252819052919091205482106104d3576040517f944ac2e600000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff84166004820152602481018390526044016103cb565b61053783836000808773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020858154811061052757610527610d60565b90600052602060002001546106b2565b9392505050565b805160009046810361057c576040517f0e4de95d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000600160006105cb8680516020808301516040808501518151938401949094528201526060810191909152600090608001604051602081830303815290604052805190602001209050919050565b81526020808201929092526040908101600090812073ffffffffffffffffffffffffffffffffffffffff8916825283528190208151808301909252805482526001015491810182905260608601519092501461062857600061062b565b80515b95945050505050565b600061062b84848461088b565b336000818152602081815260408220805460018101825590835291208101839055907f1c43e42d6323bd8b0f93b619bccf2a29b1559555f11483b8d56122c9b7a0189790469060408051928352602083019190915281018390526060810184905260800160405180910390a1919050565b60408051608081018252600080825260208201819052918101829052606081019190915260405180608001604052804681526020016107048673ffffffffffffffffffffffffffffffffffffffff1690565b81526020018481526020018381525090509392505050565b60008061072a86858561088b565b91509150803414610770576040517ffb7d6610000000000000000000000000000000000000000000000000000000008152346004820152602481018290526044016103cb565b8260005b8181101561083a5785858281811061078e5761078e610d60565b90506020020160208101906107a39190610a5c565b73ffffffffffffffffffffffffffffffffffffffff1663e37772168583815181106107d0576107d0610d60565b60200260200101518a8a6040518463ffffffff1660e01b81526004016107f7929190610d2b565b6000604051808303818588803b15801561081057600080fd5b505af1158015610824573d6000803e3d6000fd5b50505050508061083390610dbe565b9050610774565b507fd43d4445bcb9e1760e0925bb22762396dca6401144dbfbf7a52db914864480978787602001518860400151888860405161087a959493929190610df6565b60405180910390a150505050505050565b60606000828082036108c9576040517f98ca492a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8067ffffffffffffffff8111156108e2576108e2610b16565b60405190808252806020026020018201604052801561090b578160200160208202803683370190505b50925060005b81811015610a105785858281811061092b5761092b610d60565b90506020020160208101906109409190610a5c565b73ffffffffffffffffffffffffffffffffffffffff1663dc8e4f89886040518263ffffffff1660e01b815260040161097a91815260200190565b602060405180830381865afa158015610997573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109bb9190610e6a565b8482815181106109cd576109cd610d60565b6020026020010181815250508381815181106109eb576109eb610d60565b6020026020010151836109fe9190610e83565b9250610a0981610dbe565b9050610911565b5050935093915050565b600060208284031215610a2c57600080fd5b5035919050565b803573ffffffffffffffffffffffffffffffffffffffff81168114610a5757600080fd5b919050565b600060208284031215610a6e57600080fd5b61053782610a33565b60008083601f840112610a8957600080fd5b50813567ffffffffffffffff811115610aa157600080fd5b6020830191508360208260051b8501011115610abc57600080fd5b9250929050565b60008060008060608587031215610ad957600080fd5b8435935060208501359250604085013567ffffffffffffffff811115610afe57600080fd5b610b0a87828801610a77565b95989497509550505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600060808284031215610b5757600080fd5b6040516080810181811067ffffffffffffffff82111715610ba1577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b8060405250809150823581526020830135602082015260408301356040820152606083013560608201525092915050565b600060808284031215610be457600080fd5b6105378383610b45565b600080600080600060808688031215610c0657600080fd5b85359450610c1660208701610a33565b935060408601359250606086013567ffffffffffffffff811115610c3957600080fd5b610c4588828901610a77565b969995985093965092949392505050565b60008060408385031215610c6957600080fd5b610c7283610a33565b946020939093013593505050565b81518152602080830151908201526040808301519082015260608083015190820152608081016101b6565b60008060a08385031215610cbe57600080fd5b610cc783610a33565b9150610cd68460208501610b45565b90509250929050565b600080600060408486031215610cf457600080fd5b83359250602084013567ffffffffffffffff811115610d1257600080fd5b610d1e86828701610a77565b9497909650939450505050565b82815260a081016105376020830184805182526020810151602083015260408101516040830152606081015160608301525050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203610def57610def610d8f565b5060010190565b60006080820187835260208781850152866040850152608060608501528185835260a08501905086925060005b86811015610e5c5773ffffffffffffffffffffffffffffffffffffffff610e4985610a33565b1682529282019290820190600101610e23565b509998505050505050505050565b600060208284031215610e7c57600080fd5b5051919050565b808201808211156101b6576101b6610d8f56fea264697066735822122070242cf7d6f273a673e1c1e69358239a6f58a0eee98d8b9651aea6922e923e7064736f6c63430008140033","runtime-code":"0x60806040526004361061007b5760003560e01c8063b4f16bae1161004e578063b4f16bae1461012b578063b8a740e01461013e578063d48588e01461016b578063fc7686ec1461018b57600080fd5b80632ad8c706146100805780634a30a686146100b357806367c769af146100f65780639cbc6dd514610109575b600080fd5b34801561008c57600080fd5b506100a061009b366004610a1a565b6101ab565b6040519081526020015b60405180910390f35b3480156100bf57600080fd5b506100a06100ce366004610a5c565b73ffffffffffffffffffffffffffffffffffffffff1660009081526020819052604090205490565b6100a0610104366004610ac3565b6101bc565b34801561011557600080fd5b50610129610124366004610bd2565b610228565b005b610129610139366004610bee565b6103da565b34801561014a57600080fd5b5061015e610159366004610c56565b610437565b6040516100aa9190610c80565b34801561017757600080fd5b506100a0610186366004610cab565b61053e565b34801561019757600080fd5b506100a06101a6366004610cdf565b610634565b60006101b682610641565b92915050565b6000844681036101f8576040517f0e4de95d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61020185610641565b915060006102103384886106b2565b905061021e8782878761071c565b5050949350505050565b8051468103610263576040517f0e4de95d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006102ae8380516020808301516040808501518151938401949094528201526060810191909152600090608001604051602081830303815290604052805190602001209050919050565b60008181526001602081815260408084203385528252808420815180830190925280548083529301549181019190915292935090036103825760408051808201825242815260608681018051602080850191825260008881526001808352878220338084529084529188902096518755925195909201949094558851848a01518a8701519351875193845295830191909152948101949094529083015260808201527f65fdc92d5fec4c98c387c9fda2326f1d593ce9e39eaafa681d655266d0ff227e9060a00160405180910390a16103d4565b83606001518160200151146103d4578060200151846040517f4ef4ee070000000000000000000000000000000000000000000000000000000081526004016103cb929190610d2b565b60405180910390fd5b50505050565b84468103610414576040517f0e4de95d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006104208686610437565b905061042e8782868661071c565b50505050505050565b60408051608081018252600080825260208083018290528284018290526060830182905273ffffffffffffffffffffffffffffffffffffffff86168252819052919091205482106104d3576040517f944ac2e600000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff84166004820152602481018390526044016103cb565b61053783836000808773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020858154811061052757610527610d60565b90600052602060002001546106b2565b9392505050565b805160009046810361057c576040517f0e4de95d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000600160006105cb8680516020808301516040808501518151938401949094528201526060810191909152600090608001604051602081830303815290604052805190602001209050919050565b81526020808201929092526040908101600090812073ffffffffffffffffffffffffffffffffffffffff8916825283528190208151808301909252805482526001015491810182905260608601519092501461062857600061062b565b80515b95945050505050565b600061062b84848461088b565b336000818152602081815260408220805460018101825590835291208101839055907f1c43e42d6323bd8b0f93b619bccf2a29b1559555f11483b8d56122c9b7a0189790469060408051928352602083019190915281018390526060810184905260800160405180910390a1919050565b60408051608081018252600080825260208201819052918101829052606081019190915260405180608001604052804681526020016107048673ffffffffffffffffffffffffffffffffffffffff1690565b81526020018481526020018381525090509392505050565b60008061072a86858561088b565b91509150803414610770576040517ffb7d6610000000000000000000000000000000000000000000000000000000008152346004820152602481018290526044016103cb565b8260005b8181101561083a5785858281811061078e5761078e610d60565b90506020020160208101906107a39190610a5c565b73ffffffffffffffffffffffffffffffffffffffff1663e37772168583815181106107d0576107d0610d60565b60200260200101518a8a6040518463ffffffff1660e01b81526004016107f7929190610d2b565b6000604051808303818588803b15801561081057600080fd5b505af1158015610824573d6000803e3d6000fd5b50505050508061083390610dbe565b9050610774565b507fd43d4445bcb9e1760e0925bb22762396dca6401144dbfbf7a52db914864480978787602001518860400151888860405161087a959493929190610df6565b60405180910390a150505050505050565b60606000828082036108c9576040517f98ca492a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8067ffffffffffffffff8111156108e2576108e2610b16565b60405190808252806020026020018201604052801561090b578160200160208202803683370190505b50925060005b81811015610a105785858281811061092b5761092b610d60565b90506020020160208101906109409190610a5c565b73ffffffffffffffffffffffffffffffffffffffff1663dc8e4f89886040518263ffffffff1660e01b815260040161097a91815260200190565b602060405180830381865afa158015610997573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109bb9190610e6a565b8482815181106109cd576109cd610d60565b6020026020010181815250508381815181106109eb576109eb610d60565b6020026020010151836109fe9190610e83565b9250610a0981610dbe565b9050610911565b5050935093915050565b600060208284031215610a2c57600080fd5b5035919050565b803573ffffffffffffffffffffffffffffffffffffffff81168114610a5757600080fd5b919050565b600060208284031215610a6e57600080fd5b61053782610a33565b60008083601f840112610a8957600080fd5b50813567ffffffffffffffff811115610aa157600080fd5b6020830191508360208260051b8501011115610abc57600080fd5b9250929050565b60008060008060608587031215610ad957600080fd5b8435935060208501359250604085013567ffffffffffffffff811115610afe57600080fd5b610b0a87828801610a77565b95989497509550505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600060808284031215610b5757600080fd5b6040516080810181811067ffffffffffffffff82111715610ba1577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b8060405250809150823581526020830135602082015260408301356040820152606083013560608201525092915050565b600060808284031215610be457600080fd5b6105378383610b45565b600080600080600060808688031215610c0657600080fd5b85359450610c1660208701610a33565b935060408601359250606086013567ffffffffffffffff811115610c3957600080fd5b610c4588828901610a77565b969995985093965092949392505050565b60008060408385031215610c6957600080fd5b610c7283610a33565b946020939093013593505050565b81518152602080830151908201526040808301519082015260608083015190820152608081016101b6565b60008060a08385031215610cbe57600080fd5b610cc783610a33565b9150610cd68460208501610b45565b90509250929050565b600080600060408486031215610cf457600080fd5b83359250602084013567ffffffffffffffff811115610d1257600080fd5b610d1e86828701610a77565b9497909650939450505050565b82815260a081016105376020830184805182526020810151602083015260408101516040830152606081015160608301525050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203610def57610def610d8f565b5060010190565b60006080820187835260208781850152866040850152608060608501528185835260a08501905086925060005b86811015610e5c5773ffffffffffffffffffffffffffffffffffffffff610e4985610a33565b1682529282019290820190600101610e23565b509998505050505050505050565b600060208284031215610e7c57600080fd5b5051919050565b808201808211156101b6576101b6610d8f56fea264697066735822122070242cf7d6f273a673e1c1e69358239a6f58a0eee98d8b9651aea6922e923e7064736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nabstract contract InterchainDBEvents {\n    // TODO: figure out indexing\n    event InterchainEntryWritten(uint256 srcChainId, bytes32 srcWriter, uint256 writerNonce, bytes32 dataHash);\n    event InterchainEntryVerified(\n        address module, uint256 srcChainId, bytes32 srcWriter, uint256 writerNonce, bytes32 dataHash\n    );\n\n    event InterchainVerificationRequested(\n        uint256 destChainId, bytes32 srcWriter, uint256 writerNonce, address[] srcModules\n    );\n}\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n/// @notice Struct representing an entry in the Interchain DataBase\n/// @param srcChainId   The chain id of the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param writerNonce  The nonce of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    bytes32 srcWriter;\n    uint256 writerNonce;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param srcWriter    The address of the writer on the local chain\n    /// @param writerNonce  The nonce of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        address srcWriter,\n        uint256 writerNonce,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            srcWriter: TypeCasts.addressToBytes32(srcWriter),\n            writerNonce: writerNonce,\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryId(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.srcWriter, entry.writerNonce));\n    }\n}\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param dataHash     The hash of the data written on the source chain\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 dataHash;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingDataHash, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(address writer, uint256 writerNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntry(bytes32 dataHash) external returns (uint256 writerNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param writer        The address of the writer on the source chain\n    /// @param writerNonce   The nonce of the writer on the source chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(\n        uint256 destChainId,\n        address writer,\n        uint256 writerNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 writerNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param writer       The address of the writer on this chain\n    /// @param writerNonce  The nonce of the writer's entry on this chain\n    function getEntry(address writer, uint256 writerNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the writer on this chain.\n    /// @param writer       The address of the writer on this chain\n    function getWriterNonce(address writer) external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB();\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId();\n\n    /// @notice Request the verification of an entry in the Interchain DataBase by the module.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyEntry(entry)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param entry        The entry to verify\n    function requestVerification(uint256 destChainId, InterchainEntry memory entry) external payable;\n\n    /// @notice Get the Module fee for verifying an entry on the specified destination chain\n    /// @param destChainId  The chain id of the destination chain\n    function getModuleFee(uint256 destChainId) external view returns (uint256);\n}\n\ncontract InterchainDB is InterchainDBEvents, IInterchainDB {\n    mapping(address writer =\u003e bytes32[] dataHashes) internal _entries;\n    mapping(bytes32 entryId =\u003e mapping(address module =\u003e RemoteEntry entry)) internal _remoteEntries;\n\n    modifier onlyRemoteChainId(uint256 chainId) {\n        if (chainId == block.chainid) {\n            revert InterchainDB__SameChainId();\n        }\n        _;\n    }\n\n    // ═══════════════════════════════════════════════ WRITER-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function writeEntry(bytes32 dataHash) external returns (uint256 writerNonce) {\n        return _writeEntry(dataHash);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function requestVerification(\n        uint256 destChainId,\n        address writer,\n        uint256 writerNonce,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(destChainId)\n    {\n        InterchainEntry memory entry = getEntry(writer, writerNonce);\n        _requestVerification(destChainId, entry, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(destChainId)\n        returns (uint256 writerNonce)\n    {\n        writerNonce = _writeEntry(dataHash);\n        InterchainEntry memory entry = InterchainEntryLib.constructLocalEntry(msg.sender, writerNonce, dataHash);\n        _requestVerification(destChainId, entry, srcModules);\n    }\n\n    // ═══════════════════════════════════════════════ MODULE-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function verifyEntry(InterchainEntry memory entry) external onlyRemoteChainId(entry.srcChainId) {\n        bytes32 entryId = InterchainEntryLib.entryId(entry);\n        RemoteEntry memory existingEntry = _remoteEntries[entryId][msg.sender];\n        // Check if that's the first time module verifies the entry\n        if (existingEntry.verifiedAt == 0) {\n            _remoteEntries[entryId][msg.sender] = RemoteEntry({verifiedAt: block.timestamp, dataHash: entry.dataHash});\n            emit InterchainEntryVerified(\n                msg.sender, entry.srcChainId, entry.srcWriter, entry.writerNonce, entry.dataHash\n            );\n        } else {\n            // If the module has already verified the entry, check that the data hash is the same\n            if (existingEntry.dataHash != entry.dataHash) {\n                revert InterchainDB__ConflictingEntries(existingEntry.dataHash, entry);\n            }\n            // No-op if the data hash is the same\n        }\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        onlyRemoteChainId(entry.srcChainId)\n        returns (uint256 moduleVerifiedAt)\n    {\n        RemoteEntry memory remoteEntry = _remoteEntries[InterchainEntryLib.entryId(entry)][dstModule];\n        // Check data against the one verified by the module\n        return remoteEntry.dataHash == entry.dataHash ? remoteEntry.verifiedAt : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getInterchainFee(uint256 destChainId, address[] calldata srcModules) external view returns (uint256 fee) {\n        (, fee) = _getModuleFees(destChainId, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntry(address writer, uint256 writerNonce) public view returns (InterchainEntry memory) {\n        if (getWriterNonce(writer) \u003c= writerNonce) {\n            revert InterchainDB__EntryDoesNotExist(writer, writerNonce);\n        }\n        return InterchainEntryLib.constructLocalEntry(writer, writerNonce, _entries[writer][writerNonce]);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getWriterNonce(address writer) public view returns (uint256) {\n        return _entries[writer].length;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Write the entry to the database and emit the event.\n    function _writeEntry(bytes32 dataHash) internal returns (uint256 writerNonce) {\n        writerNonce = _entries[msg.sender].length;\n        _entries[msg.sender].push(dataHash);\n        emit InterchainEntryWritten(block.chainid, TypeCasts.addressToBytes32(msg.sender), writerNonce, dataHash);\n    }\n\n    /// @dev Request the verification of the entry by the modules, and emit the event.\n    /// Note: the validity of the passed entry and chain id being remote is enforced in the calling function.\n    function _requestVerification(\n        uint256 destChainId,\n        InterchainEntry memory entry,\n        address[] calldata srcModules\n    )\n        internal\n    {\n        (uint256[] memory fees, uint256 totalFee) = _getModuleFees(destChainId, srcModules);\n        if (msg.value != totalFee) {\n            revert InterchainDB__IncorrectFeeAmount(msg.value, totalFee);\n        }\n        uint256 len = srcModules.length;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            IInterchainModule(srcModules[i]).requestVerification{value: fees[i]}(destChainId, entry);\n        }\n        emit InterchainVerificationRequested(destChainId, entry.srcWriter, entry.writerNonce, srcModules);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Get the verification fees for the modules\n    function _getModuleFees(\n        uint256 destChainId,\n        address[] calldata srcModules\n    )\n        internal\n        view\n        returns (uint256[] memory fees, uint256 totalFee)\n    {\n        uint256 len = srcModules.length;\n        if (len == 0) {\n            revert InterchainDB__NoModulesSpecified();\n        }\n        fees = new uint256[](len);\n        for (uint256 i = 0; i \u003c len; ++i) {\n            fees[i] = IInterchainModule(srcModules[i]).getModuleFee(destChainId);\n            totalFee += fees[i];\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"9080:7225:0:-:0;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"9080:7225:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;9837:122;;;;;;;;;;-1:-1:-1;9837:122:0;;;;;:::i;:::-;;:::i;:::-;;;345:25:1;;;333:2;318:18;9837:122:0;;;;;;;;13704:117;;;;;;;;;;-1:-1:-1;13704:117:0;;;;;:::i;:::-;13791:16;;13765:7;13791:16;;;;;;;;;;:23;;13704:117;10410:478;;;;;;:::i;:::-;;:::i;11246:968::-;;;;;;;;;;-1:-1:-1;11246:968:0;;;;;:::i;:::-;;:::i;:::-;;9999:371;;;;;;:::i;:::-;;:::i;13314:350::-;;;;;;;;;;-1:-1:-1;13314:350:0;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;12588:466::-;;;;;;;;;;-1:-1:-1;12588:466:0;;;;;:::i;:::-;;:::i;13094:180::-;;;;;;;;;;-1:-1:-1;13094:180:0;;;;;:::i;:::-;;:::i;9837:122::-;9893:19;9931:21;9943:8;9931:11;:21::i;:::-;9924:28;9837:122;-1:-1:-1;;9837:122:0:o;10410:478::-;10635:19;10605:11;9388:13;9377:7;:24;9373:89;;9424:27;;;;;;;;;;;;;;9373:89;10684:21:::1;10696:8;10684:11;:21::i;:::-;10670:35;;10715:28;10746:73;10785:10;10797:11;10810:8;10746:38;:73::i;:::-;10715:104;;10829:52;10850:11;10863:5;10870:10;;10829:20;:52::i;:::-;10660:228;10410:478:::0;;;;;;;:::o;11246:968::-;11324:16;;9388:13;9377:24;;9373:89;;9424:27;;;;;;;;;;;;;;9373:89;11352:15:::1;11370:33;11397:5;2285:16:::0;;2303:15;;;;;2320:17;;;;;2274:64;;;;;9032:25:1;;;;9073:18;;9066:34;9116:18;;;9109:34;;;;2238:7:0;;9005:18:1;;2274:64:0;;;;;;;;;;;;2264:75;;;;;;2257:82;;2168:178;;;;11370:33:::1;11413:32;11448:23:::0;;;:14:::1;:23;::::0;;;;;;;11472:10:::1;11448:35:::0;;;;;;;11413:70;;;;::::1;::::0;;;;;;;;;::::1;::::0;;;::::1;::::0;;;;11352:51;;-1:-1:-1;11565:29:0;;11561:647:::1;;11648:68;::::0;;;;::::1;::::0;;11673:15:::1;11648:68:::0;;11700:14:::1;::::0;;::::1;::::0;;11648:68:::1;::::0;;::::1;::::0;;;-1:-1:-1;11610:23:0;;;:14:::1;:23:::0;;;;;;11634:10:::1;11610:35:::0;;;;;;;;;;:106;;;;;;;;;::::1;::::0;;;;11788:16;;11806:15;;::::1;::::0;11823:17;;::::1;::::0;11842:14;;11735:135;;5477:74:1;;;5567:18;;;5560:34;;;;5610:18;;;5603:34;;;;5653:18;;;5646:34;5711:3;5696:19;;5689:35;11735:135:0::1;::::0;5464:3:1;5449:19;11735:135:0::1;;;;;;;11561:647;;;12029:5;:14;;;12003:13;:22;;;:40;11999:149;;12103:13;:22;;;12127:5;12070:63;;;;;;;;;;;;:::i;:::-;;;;;;;;11999:149;11342:872;;11246:968:::0;;:::o;9999:371::-;10214:11;9388:13;9377:7;:24;9373:89;;9424:27;;;;;;;;;;;;;;9373:89;10241:28:::1;10272:29;10281:6;10289:11;10272:8;:29::i;:::-;10241:60;;10311:52;10332:11;10345:5;10352:10;;10311:20;:52::i;:::-;10231:139;9999:371:::0;;;;;;:::o;13314:350::-;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;13791:16:0;;;;;;;;;;;;:23;13454:11;-1:-1:-1;13424:127:0;;13488:52;;;;;6282:42:1;6270:55;;13488:52:0;;;6252:74:1;6342:18;;;6335:34;;;6225:18;;13488:52:0;6078:297:1;13424:127:0;13567:90;13606:6;13614:11;13627:8;:16;13636:6;13627:16;;;;;;;;;;;;;;;13644:11;13627:29;;;;;;;;:::i;:::-;;;;;;;;;13567:38;:90::i;:::-;13560:97;13314:350;-1:-1:-1;;;13314:350:0:o;12588:466::-;12734:16;;12769:24;;9388:13;9377:24;;9373:89;;9424:27;;;;;;;;;;;;;;9373:89;12809:30:::1;12842:14;:49;12857:33;12884:5;2285:16:::0;;2303:15;;;;;2320:17;;;;;2274:64;;;;;9032:25:1;;;;9073:18;;9066:34;9116:18;;;9109:34;;;;2238:7:0;;9005:18:1;;2274:64:0;;;;;;;;;;;;2264:75;;;;;;2257:82;;2168:178;;;;12857:33:::1;12842:49:::0;;::::1;::::0;;::::1;::::0;;;;;;;;-1:-1:-1;12842:49:0;;;:60:::1;::::0;::::1;::::0;;;;;;;12809:93;;;;::::1;::::0;;;;;;;::::1;;::::0;;;::::1;::::0;;;13004:14:::1;::::0;::::1;::::0;12809:93;;-1:-1:-1;12980:38:0::1;:67;;13046:1;12980:67;;;13021:22:::0;;12980:67:::1;12973:74:::0;12588:466;-1:-1:-1;;;;;12588:466:0:o;13094:180::-;13195:11;13228:39;13243:11;13256:10;;13228:14;:39::i;14208:296::-;14319:10;14265:19;14310:20;;;;;;;;;;:27;;14347:35;;;;;;;;;;;;;;;14310:27;14397:100;;14420:13;;14397:100;;;6800:25:1;;;6856:2;6841:18;;6834:34;;;;6884:18;;6877:34;;;6942:2;6927:18;;6920:34;;;6787:3;6772:19;14397:100:0;;;;;;;14208:296;;;:::o;1674:420::-;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1889:198:0;;;;;;;;1931:13;1889:198;;;;1969:37;1996:9;649:22;;;552:127;1969:37;1889:198;;;;2033:11;1889:198;;;;2068:8;1889:198;;;1882:205;;1674:420;;;;;:::o;14707:688::-;14881:21;14904:16;14924:39;14939:11;14952:10;;14924:14;:39::i;:::-;14880:83;;;;14990:8;14977:9;:21;14973:112;;15021:53;;;;;15054:9;15021:53;;;7139:25:1;7180:18;;;7173:34;;;7112:18;;15021:53:0;6965:248:1;14973:112:0;15108:10;15094:11;15135:147;15159:3;15155:1;:7;15135:147;;;15201:10;;15212:1;15201:13;;;;;;;:::i;:::-;;;;;;;;;;;;;;:::i;:::-;15183:52;;;15243:4;15248:1;15243:7;;;;;;;;:::i;:::-;;;;;;;15252:11;15265:5;15183:88;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;15164:3;;;;:::i;:::-;;;15135:147;;;;15296:92;15328:11;15341:5;:15;;;15358:5;:17;;;15377:10;;15296:92;;;;;;;;;;:::i;:::-;;;;;;;;14870:525;;;14707:688;;;;:::o;15772:531::-;15917:21;15940:16;15986:10;16017:8;;;16013:80;;16048:34;;;;;;;;;;;;;;16013:80;16123:3;16109:18;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;16109:18:0;;16102:25;;16142:9;16137:160;16161:3;16157:1;:7;16137:160;;;16213:10;;16224:1;16213:13;;;;;;;:::i;:::-;;;;;;;;;;;;;;:::i;:::-;16195:45;;;16241:11;16195:58;;;;;;;;;;;;;345:25:1;;333:2;318:18;;199:177;16195:58:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;16185:4;16190:1;16185:7;;;;;;;;:::i;:::-;;;;;;:68;;;;;16279:4;16284:1;16279:7;;;;;;;;:::i;:::-;;;;;;;16267:19;;;;;:::i;:::-;;-1:-1:-1;16166:3:0;;;:::i;:::-;;;16137:160;;;;15962:341;15772:531;;;;;;:::o;14:180:1:-;73:6;126:2;114:9;105:7;101:23;97:32;94:52;;;142:1;139;132:12;94:52;-1:-1:-1;165:23:1;;14:180;-1:-1:-1;14:180:1:o;381:196::-;449:20;;509:42;498:54;;488:65;;478:93;;567:1;564;557:12;478:93;381:196;;;:::o;582:186::-;641:6;694:2;682:9;673:7;669:23;665:32;662:52;;;710:1;707;700:12;662:52;733:29;752:9;733:29;:::i;773:367::-;836:8;846:6;900:3;893:4;885:6;881:17;877:27;867:55;;918:1;915;908:12;867:55;-1:-1:-1;941:20:1;;984:18;973:30;;970:50;;;1016:1;1013;1006:12;970:50;1053:4;1045:6;1041:17;1029:29;;1113:3;1106:4;1096:6;1093:1;1089:14;1081:6;1077:27;1073:38;1070:47;1067:67;;;1130:1;1127;1120:12;1067:67;773:367;;;;;:::o;1145:573::-;1249:6;1257;1265;1273;1326:2;1314:9;1305:7;1301:23;1297:32;1294:52;;;1342:1;1339;1332:12;1294:52;1378:9;1365:23;1355:33;;1435:2;1424:9;1420:18;1407:32;1397:42;;1490:2;1479:9;1475:18;1462:32;1517:18;1509:6;1506:30;1503:50;;;1549:1;1546;1539:12;1503:50;1588:70;1650:7;1641:6;1630:9;1626:22;1588:70;:::i;:::-;1145:573;;;;-1:-1:-1;1677:8:1;-1:-1:-1;;;;1145:573:1:o;1723:184::-;1775:77;1772:1;1765:88;1872:4;1869:1;1862:15;1896:4;1893:1;1886:15;1912:766;1974:5;2022:4;2010:9;2005:3;2001:19;1997:30;1994:50;;;2040:1;2037;2030:12;1994:50;2073:2;2067:9;2115:4;2107:6;2103:17;2186:6;2174:10;2171:22;2150:18;2138:10;2135:34;2132:62;2129:242;;;2227:77;2224:1;2217:88;2328:4;2325:1;2318:15;2356:4;2353:1;2346:15;2129:242;2391:10;2387:2;2380:22;;2420:6;2411:15;;2463:9;2450:23;2442:6;2435:39;2535:2;2524:9;2520:18;2507:32;2502:2;2494:6;2490:15;2483:57;2601:2;2590:9;2586:18;2573:32;2568:2;2560:6;2556:15;2549:57;2667:2;2656:9;2652:18;2639:32;2634:2;2626:6;2622:15;2615:57;;1912:766;;;;:::o;2683:242::-;2773:6;2826:3;2814:9;2805:7;2801:23;2797:33;2794:53;;;2843:1;2840;2833:12;2794:53;2866;2911:7;2900:9;2866:53;:::i;2930:648::-;3043:6;3051;3059;3067;3075;3128:3;3116:9;3107:7;3103:23;3099:33;3096:53;;;3145:1;3142;3135:12;3096:53;3181:9;3168:23;3158:33;;3210:38;3244:2;3233:9;3229:18;3210:38;:::i;:::-;3200:48;;3295:2;3284:9;3280:18;3267:32;3257:42;;3350:2;3339:9;3335:18;3322:32;3377:18;3369:6;3366:30;3363:50;;;3409:1;3406;3399:12;3363:50;3448:70;3510:7;3501:6;3490:9;3486:22;3448:70;:::i;:::-;2930:648;;;;-1:-1:-1;2930:648:1;;-1:-1:-1;3537:8:1;;3422:96;2930:648;-1:-1:-1;;;2930:648:1:o;3583:254::-;3651:6;3659;3712:2;3700:9;3691:7;3687:23;3683:32;3680:52;;;3728:1;3725;3718:12;3680:52;3751:29;3770:9;3751:29;:::i;:::-;3741:39;3827:2;3812:18;;;;3799:32;;-1:-1:-1;;;3583:254:1:o;4115:267::-;3923:12;;3911:25;;3985:4;3974:16;;;3968:23;3952:14;;;3945:47;4041:4;4030:16;;;4024:23;4008:14;;;4001:47;4097:4;4086:16;;;4080:23;4064:14;;;4057:47;4311:3;4296:19;;4324:52;3842:268;4387:316;4486:6;4494;4547:3;4535:9;4526:7;4522:23;4518:33;4515:53;;;4564:1;4561;4554:12;4515:53;4587:29;4606:9;4587:29;:::i;:::-;4577:39;;4635:62;4689:7;4684:2;4673:9;4669:18;4635:62;:::i;:::-;4625:72;;4387:316;;;;;:::o;4708:505::-;4803:6;4811;4819;4872:2;4860:9;4851:7;4847:23;4843:32;4840:52;;;4888:1;4885;4878:12;4840:52;4924:9;4911:23;4901:33;;4985:2;4974:9;4970:18;4957:32;5012:18;5004:6;5001:30;4998:50;;;5044:1;5041;5034:12;4998:50;5083:70;5145:7;5136:6;5125:9;5121:22;5083:70;:::i;:::-;4708:505;;5172:8;;-1:-1:-1;5057:96:1;;-1:-1:-1;;;;4708:505:1:o;5735:338::-;5972:25;;;5959:3;5944:19;;6006:61;6063:2;6048:18;;6040:6;3929:5;3923:12;3918:3;3911:25;3985:4;3978:5;3974:16;3968:23;3961:4;3956:3;3952:14;3945:47;4041:4;4034:5;4030:16;4024:23;4017:4;4012:3;4008:14;4001:47;4097:4;4090:5;4086:16;4080:23;4073:4;4068:3;4064:14;4057:47;;;3842:268;6380:184;6432:77;6429:1;6422:88;6529:4;6526:1;6519:15;6553:4;6550:1;6543:15;7561:184;7613:77;7610:1;7603:88;7710:4;7707:1;7700:15;7734:4;7731:1;7724:15;7750:195;7789:3;7820:66;7813:5;7810:77;7807:103;;7890:18;;:::i;:::-;-1:-1:-1;7937:1:1;7926:13;;7750:195::o;7950:875::-;8186:4;8234:3;8223:9;8219:19;8265:6;8254:9;8247:25;8291:2;8329:6;8324:2;8313:9;8309:18;8302:34;8372:6;8367:2;8356:9;8352:18;8345:34;8415:3;8410:2;8399:9;8395:18;8388:31;8439:6;8469;8461;8454:22;8507:3;8496:9;8492:19;8485:26;;8534:6;8520:20;;8558:1;8568:231;8582:6;8579:1;8576:13;8568:231;;;8675:42;8647:26;8666:6;8647:26;:::i;:::-;8643:75;8631:88;;8774:15;;;;8739:12;;;;8604:1;8597:9;8568:231;;;-1:-1:-1;8816:3:1;7950:875;-1:-1:-1;;;;;;;;;7950:875:1:o;9154:184::-;9224:6;9277:2;9265:9;9256:7;9252:23;9248:32;9245:52;;;9293:1;9290;9283:12;9245:52;-1:-1:-1;9316:16:1;;9154:184;-1:-1:-1;9154:184:1:o;9343:125::-;9408:9;;;9429:10;;;9426:36;;;9442:18;;:::i","abiDefinition":[{"inputs":[{"internalType":"bytes32","name":"existingDataHash","type":"bytes32"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"uint256","name":"writerNonce","type":"uint256"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"newEntry","type":"tuple"}],"name":"InterchainDB__ConflictingEntries","type":"error"},{"inputs":[{"internalType":"address","name":"writer","type":"address"},{"internalType":"uint256","name":"writerNonce","type":"uint256"}],"name":"InterchainDB__EntryDoesNotExist","type":"error"},{"inputs":[{"internalType":"uint256","name":"actualFee","type":"uint256"},{"internalType":"uint256","name":"expectedFee","type":"uint256"}],"name":"InterchainDB__IncorrectFeeAmount","type":"error"},{"inputs":[],"name":"InterchainDB__NoModulesSpecified","type":"error"},{"inputs":[],"name":"InterchainDB__SameChainId","type":"error"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"module","type":"address"},{"indexed":false,"internalType":"uint256","name":"srcChainId","type":"uint256"},{"indexed":false,"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"indexed":false,"internalType":"uint256","name":"writerNonce","type":"uint256"},{"indexed":false,"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"name":"InterchainEntryVerified","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"srcChainId","type":"uint256"},{"indexed":false,"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"indexed":false,"internalType":"uint256","name":"writerNonce","type":"uint256"},{"indexed":false,"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"name":"InterchainEntryWritten","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"destChainId","type":"uint256"},{"indexed":false,"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"indexed":false,"internalType":"uint256","name":"writerNonce","type":"uint256"},{"indexed":false,"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"InterchainVerificationRequested","type":"event"},{"inputs":[{"internalType":"address","name":"writer","type":"address"},{"internalType":"uint256","name":"writerNonce","type":"uint256"}],"name":"getEntry","outputs":[{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"uint256","name":"writerNonce","type":"uint256"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"getInterchainFee","outputs":[{"internalType":"uint256","name":"fee","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"writer","type":"address"}],"name":"getWriterNonce","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"dstModule","type":"address"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"uint256","name":"writerNonce","type":"uint256"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"entry","type":"tuple"}],"name":"readEntry","outputs":[{"internalType":"uint256","name":"moduleVerifiedAt","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"internalType":"address","name":"writer","type":"address"},{"internalType":"uint256","name":"writerNonce","type":"uint256"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"requestVerification","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"uint256","name":"writerNonce","type":"uint256"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"entry","type":"tuple"}],"name":"verifyEntry","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"name":"writeEntry","outputs":[{"internalType":"uint256","name":"writerNonce","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"writeEntryWithVerification","outputs":[{"internalType":"uint256","name":"writerNonce","type":"uint256"}],"stateMutability":"payable","type":"function"}],"userDoc":{"kind":"user","methods":{"getEntry(address,uint256)":{"notice":"Get the Interchain Entry by the writer and the writer nonce."},"getInterchainFee(uint256,address[])":{"notice":"Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain using the provided Interchain Modules."},"getWriterNonce(address)":{"notice":"Get the nonce of the writer on this chain."},"readEntry(address,(uint256,bytes32,uint256,bytes32))":{"notice":"Read the data written on specific source chain by a specific writer, and verify it on the destination chain using the provided Interchain Module. Note: returned zero value indicates that the module has not verified the entry."},"requestVerification(uint256,address,uint256,address[])":{"notice":"Request the given Interchain Modules to verify the already written entry on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: this method is permissionless, and anyone can request verification for any entry."},"verifyEntry((uint256,bytes32,uint256,bytes32))":{"notice":"Allows the Interchain Module to verify the entry coming from a remote source chain."},"writeEntry(bytes32)":{"notice":"Write data to the Interchain DataBase as a new entry. Note: there are no guarantees that this entry will be available for reading on any of the remote chains. Use `verifyEntry` to ensure that the entry is available for reading on the destination chain."},"writeEntryWithVerification(uint256,bytes32,address[])":{"notice":"Write data to the Interchain DataBase, and request the given Interchain Modules to verify it on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: additional verification for the same entry could be later done using `requestVerification`."}},"version":1},"developerDoc":{"kind":"dev","methods":{"getEntry(address,uint256)":{"details":"Will revert if the entry with the given nonce does not exist.","params":{"writer":"The address of the writer on this chain","writerNonce":"The nonce of the writer's entry on this chain"}},"getInterchainFee(uint256,address[])":{"details":"Will revert if the empty array of modules is provided.","params":{"destChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"}},"getWriterNonce(address)":{"params":{"writer":"The address of the writer on this chain"}},"readEntry(address,(uint256,bytes32,uint256,bytes32))":{"params":{"dstModule":"The destination chain addresses of the Interchain Modules to use for verification","entry":"The Interchain Entry to read"},"returns":{"moduleVerifiedAt":"  The block timestamp at which the entry was verified by the module,                             or zero if the module has not verified the entry."}},"requestVerification(uint256,address,uint256,address[])":{"details":"Will revert if the entry with the given nonce does not exist.","params":{"destChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification","writer":"The address of the writer on the source chain","writerNonce":"The nonce of the writer on the source chain"}},"verifyEntry((uint256,bytes32,uint256,bytes32))":{"params":{"entry":"The Interchain Entry to confirm"}},"writeEntry(bytes32)":{"params":{"dataHash":"The hash of the data to be written to the Interchain DataBase as a new entry"},"returns":{"writerNonce":"The writer-specific nonce of the written entry"}},"writeEntryWithVerification(uint256,bytes32,address[])":{"details":"Will revert if the empty array of modules is provided.","params":{"dataHash":"The hash of the data to be written to the Interchain DataBase as a new entry","destChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"},"returns":{"writerNonce":"The writer-specific nonce of the written entry"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"existingDataHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"newEntry\",\"type\":\"tuple\"}],\"name\":\"InterchainDB__ConflictingEntries\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"writer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__EntryDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actualFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedFee\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__IncorrectFeeAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainDB__NoModulesSpecified\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainDB__SameChainId\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"InterchainEntryVerified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"InterchainEntryWritten\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"InterchainVerificationRequested\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"writer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"}],\"name\":\"getEntry\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"getInterchainFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"writer\",\"type\":\"address\"}],\"name\":\"getWriterNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dstModule\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"entry\",\"type\":\"tuple\"}],\"name\":\"readEntry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"moduleVerifiedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"writer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"requestVerification\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"entry\",\"type\":\"tuple\"}],\"name\":\"verifyEntry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"writeEntry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"writeEntryWithVerification\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getEntry(address,uint256)\":{\"details\":\"Will revert if the entry with the given nonce does not exist.\",\"params\":{\"writer\":\"The address of the writer on this chain\",\"writerNonce\":\"The nonce of the writer's entry on this chain\"}},\"getInterchainFee(uint256,address[])\":{\"details\":\"Will revert if the empty array of modules is provided.\",\"params\":{\"destChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"}},\"getWriterNonce(address)\":{\"params\":{\"writer\":\"The address of the writer on this chain\"}},\"readEntry(address,(uint256,bytes32,uint256,bytes32))\":{\"params\":{\"dstModule\":\"The destination chain addresses of the Interchain Modules to use for verification\",\"entry\":\"The Interchain Entry to read\"},\"returns\":{\"moduleVerifiedAt\":\"  The block timestamp at which the entry was verified by the module,                             or zero if the module has not verified the entry.\"}},\"requestVerification(uint256,address,uint256,address[])\":{\"details\":\"Will revert if the entry with the given nonce does not exist.\",\"params\":{\"destChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\",\"writer\":\"The address of the writer on the source chain\",\"writerNonce\":\"The nonce of the writer on the source chain\"}},\"verifyEntry((uint256,bytes32,uint256,bytes32))\":{\"params\":{\"entry\":\"The Interchain Entry to confirm\"}},\"writeEntry(bytes32)\":{\"params\":{\"dataHash\":\"The hash of the data to be written to the Interchain DataBase as a new entry\"},\"returns\":{\"writerNonce\":\"The writer-specific nonce of the written entry\"}},\"writeEntryWithVerification(uint256,bytes32,address[])\":{\"details\":\"Will revert if the empty array of modules is provided.\",\"params\":{\"dataHash\":\"The hash of the data to be written to the Interchain DataBase as a new entry\",\"destChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"},\"returns\":{\"writerNonce\":\"The writer-specific nonce of the written entry\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getEntry(address,uint256)\":{\"notice\":\"Get the Interchain Entry by the writer and the writer nonce.\"},\"getInterchainFee(uint256,address[])\":{\"notice\":\"Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain using the provided Interchain Modules.\"},\"getWriterNonce(address)\":{\"notice\":\"Get the nonce of the writer on this chain.\"},\"readEntry(address,(uint256,bytes32,uint256,bytes32))\":{\"notice\":\"Read the data written on specific source chain by a specific writer, and verify it on the destination chain using the provided Interchain Module. Note: returned zero value indicates that the module has not verified the entry.\"},\"requestVerification(uint256,address,uint256,address[])\":{\"notice\":\"Request the given Interchain Modules to verify the already written entry on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: this method is permissionless, and anyone can request verification for any entry.\"},\"verifyEntry((uint256,bytes32,uint256,bytes32))\":{\"notice\":\"Allows the Interchain Module to verify the entry coming from a remote source chain.\"},\"writeEntry(bytes32)\":{\"notice\":\"Write data to the Interchain DataBase as a new entry. Note: there are no guarantees that this entry will be available for reading on any of the remote chains. Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\"},\"writeEntryWithVerification(uint256,bytes32,address[])\":{\"notice\":\"Write data to the Interchain DataBase, and request the given Interchain Modules to verify it on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: additional verification for the same entry could be later done using `requestVerification`.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainDB.sol\":\"InterchainDB\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainDB.sol\":{\"keccak256\":\"0x087d4318b29d40d2b45c6ef3909d5b1794c60b51291a13e3d4579914f656ab4c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://763c2e4e618842030e6ad710546ee1b7c77ac2780bdceabf64a18f0f3a253261\",\"dweb:/ipfs/QmbzwHDf9Y2WsSSKMMgGdU92cJCcD55CVi2GoDL7QTVfUL\"]}},\"version\":1}"},"hashes":{"getEntry(address,uint256)":"b8a740e0","getInterchainFee(uint256,address[])":"fc7686ec","getWriterNonce(address)":"4a30a686","readEntry(address,(uint256,bytes32,uint256,bytes32))":"d48588e0","requestVerification(uint256,address,uint256,address[])":"b4f16bae","verifyEntry((uint256,bytes32,uint256,bytes32))":"9cbc6dd5","writeEntry(bytes32)":"2ad8c706","writeEntryWithVerification(uint256,bytes32,address[])":"67c769af"}},"solidity/InterchainDB.sol:InterchainDBEvents":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nabstract contract InterchainDBEvents {\n    // TODO: figure out indexing\n    event InterchainEntryWritten(uint256 srcChainId, bytes32 srcWriter, uint256 writerNonce, bytes32 dataHash);\n    event InterchainEntryVerified(\n        address module, uint256 srcChainId, bytes32 srcWriter, uint256 writerNonce, bytes32 dataHash\n    );\n\n    event InterchainVerificationRequested(\n        uint256 destChainId, bytes32 srcWriter, uint256 writerNonce, address[] srcModules\n    );\n}\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n/// @notice Struct representing an entry in the Interchain DataBase\n/// @param srcChainId   The chain id of the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param writerNonce  The nonce of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    bytes32 srcWriter;\n    uint256 writerNonce;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param srcWriter    The address of the writer on the local chain\n    /// @param writerNonce  The nonce of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        address srcWriter,\n        uint256 writerNonce,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            srcWriter: TypeCasts.addressToBytes32(srcWriter),\n            writerNonce: writerNonce,\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryId(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.srcWriter, entry.writerNonce));\n    }\n}\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param dataHash     The hash of the data written on the source chain\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 dataHash;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingDataHash, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(address writer, uint256 writerNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntry(bytes32 dataHash) external returns (uint256 writerNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param writer        The address of the writer on the source chain\n    /// @param writerNonce   The nonce of the writer on the source chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(\n        uint256 destChainId,\n        address writer,\n        uint256 writerNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 writerNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param writer       The address of the writer on this chain\n    /// @param writerNonce  The nonce of the writer's entry on this chain\n    function getEntry(address writer, uint256 writerNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the writer on this chain.\n    /// @param writer       The address of the writer on this chain\n    function getWriterNonce(address writer) external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB();\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId();\n\n    /// @notice Request the verification of an entry in the Interchain DataBase by the module.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyEntry(entry)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param entry        The entry to verify\n    function requestVerification(uint256 destChainId, InterchainEntry memory entry) external payable;\n\n    /// @notice Get the Module fee for verifying an entry on the specified destination chain\n    /// @param destChainId  The chain id of the destination chain\n    function getModuleFee(uint256 destChainId) external view returns (uint256);\n}\n\ncontract InterchainDB is InterchainDBEvents, IInterchainDB {\n    mapping(address writer =\u003e bytes32[] dataHashes) internal _entries;\n    mapping(bytes32 entryId =\u003e mapping(address module =\u003e RemoteEntry entry)) internal _remoteEntries;\n\n    modifier onlyRemoteChainId(uint256 chainId) {\n        if (chainId == block.chainid) {\n            revert InterchainDB__SameChainId();\n        }\n        _;\n    }\n\n    // ═══════════════════════════════════════════════ WRITER-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function writeEntry(bytes32 dataHash) external returns (uint256 writerNonce) {\n        return _writeEntry(dataHash);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function requestVerification(\n        uint256 destChainId,\n        address writer,\n        uint256 writerNonce,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(destChainId)\n    {\n        InterchainEntry memory entry = getEntry(writer, writerNonce);\n        _requestVerification(destChainId, entry, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(destChainId)\n        returns (uint256 writerNonce)\n    {\n        writerNonce = _writeEntry(dataHash);\n        InterchainEntry memory entry = InterchainEntryLib.constructLocalEntry(msg.sender, writerNonce, dataHash);\n        _requestVerification(destChainId, entry, srcModules);\n    }\n\n    // ═══════════════════════════════════════════════ MODULE-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function verifyEntry(InterchainEntry memory entry) external onlyRemoteChainId(entry.srcChainId) {\n        bytes32 entryId = InterchainEntryLib.entryId(entry);\n        RemoteEntry memory existingEntry = _remoteEntries[entryId][msg.sender];\n        // Check if that's the first time module verifies the entry\n        if (existingEntry.verifiedAt == 0) {\n            _remoteEntries[entryId][msg.sender] = RemoteEntry({verifiedAt: block.timestamp, dataHash: entry.dataHash});\n            emit InterchainEntryVerified(\n                msg.sender, entry.srcChainId, entry.srcWriter, entry.writerNonce, entry.dataHash\n            );\n        } else {\n            // If the module has already verified the entry, check that the data hash is the same\n            if (existingEntry.dataHash != entry.dataHash) {\n                revert InterchainDB__ConflictingEntries(existingEntry.dataHash, entry);\n            }\n            // No-op if the data hash is the same\n        }\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        onlyRemoteChainId(entry.srcChainId)\n        returns (uint256 moduleVerifiedAt)\n    {\n        RemoteEntry memory remoteEntry = _remoteEntries[InterchainEntryLib.entryId(entry)][dstModule];\n        // Check data against the one verified by the module\n        return remoteEntry.dataHash == entry.dataHash ? remoteEntry.verifiedAt : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getInterchainFee(uint256 destChainId, address[] calldata srcModules) external view returns (uint256 fee) {\n        (, fee) = _getModuleFees(destChainId, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntry(address writer, uint256 writerNonce) public view returns (InterchainEntry memory) {\n        if (getWriterNonce(writer) \u003c= writerNonce) {\n            revert InterchainDB__EntryDoesNotExist(writer, writerNonce);\n        }\n        return InterchainEntryLib.constructLocalEntry(writer, writerNonce, _entries[writer][writerNonce]);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getWriterNonce(address writer) public view returns (uint256) {\n        return _entries[writer].length;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Write the entry to the database and emit the event.\n    function _writeEntry(bytes32 dataHash) internal returns (uint256 writerNonce) {\n        writerNonce = _entries[msg.sender].length;\n        _entries[msg.sender].push(dataHash);\n        emit InterchainEntryWritten(block.chainid, TypeCasts.addressToBytes32(msg.sender), writerNonce, dataHash);\n    }\n\n    /// @dev Request the verification of the entry by the modules, and emit the event.\n    /// Note: the validity of the passed entry and chain id being remote is enforced in the calling function.\n    function _requestVerification(\n        uint256 destChainId,\n        InterchainEntry memory entry,\n        address[] calldata srcModules\n    )\n        internal\n    {\n        (uint256[] memory fees, uint256 totalFee) = _getModuleFees(destChainId, srcModules);\n        if (msg.value != totalFee) {\n            revert InterchainDB__IncorrectFeeAmount(msg.value, totalFee);\n        }\n        uint256 len = srcModules.length;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            IInterchainModule(srcModules[i]).requestVerification{value: fees[i]}(destChainId, entry);\n        }\n        emit InterchainVerificationRequested(destChainId, entry.srcWriter, entry.writerNonce, srcModules);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Get the verification fees for the modules\n    function _getModuleFees(\n        uint256 destChainId,\n        address[] calldata srcModules\n    )\n        internal\n        view\n        returns (uint256[] memory fees, uint256 totalFee)\n    {\n        uint256 len = srcModules.length;\n        if (len == 0) {\n            revert InterchainDB__NoModulesSpecified();\n        }\n        fees = new uint256[](len);\n        for (uint256 i = 0; i \u003c len; ++i) {\n            fees[i] = IInterchainModule(srcModules[i]).getModuleFee(destChainId);\n            totalFee += fees[i];\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"module","type":"address"},{"indexed":false,"internalType":"uint256","name":"srcChainId","type":"uint256"},{"indexed":false,"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"indexed":false,"internalType":"uint256","name":"writerNonce","type":"uint256"},{"indexed":false,"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"name":"InterchainEntryVerified","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"srcChainId","type":"uint256"},{"indexed":false,"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"indexed":false,"internalType":"uint256","name":"writerNonce","type":"uint256"},{"indexed":false,"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"name":"InterchainEntryWritten","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"destChainId","type":"uint256"},{"indexed":false,"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"indexed":false,"internalType":"uint256","name":"writerNonce","type":"uint256"},{"indexed":false,"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"InterchainVerificationRequested","type":"event"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"InterchainEntryVerified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"InterchainEntryWritten\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"writerNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"InterchainVerificationRequested\",\"type\":\"event\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainDB.sol\":\"InterchainDBEvents\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainDB.sol\":{\"keccak256\":\"0x087d4318b29d40d2b45c6ef3909d5b1794c60b51291a13e3d4579914f656ab4c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://763c2e4e618842030e6ad710546ee1b7c77ac2780bdceabf64a18f0f3a253261\",\"dweb:/ipfs/QmbzwHDf9Y2WsSSKMMgGdU92cJCcD55CVi2GoDL7QTVfUL\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainDB.sol:InterchainEntryLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220357d0c6b731a30219fb47fa17feb57cf0583236662b519e2582eec44a62931b964736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220357d0c6b731a30219fb47fa17feb57cf0583236662b519e2582eec44a62931b964736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nabstract contract InterchainDBEvents {\n    // TODO: figure out indexing\n    event InterchainEntryWritten(uint256 srcChainId, bytes32 srcWriter, uint256 writerNonce, bytes32 dataHash);\n    event InterchainEntryVerified(\n        address module, uint256 srcChainId, bytes32 srcWriter, uint256 writerNonce, bytes32 dataHash\n    );\n\n    event InterchainVerificationRequested(\n        uint256 destChainId, bytes32 srcWriter, uint256 writerNonce, address[] srcModules\n    );\n}\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n/// @notice Struct representing an entry in the Interchain DataBase\n/// @param srcChainId   The chain id of the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param writerNonce  The nonce of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    bytes32 srcWriter;\n    uint256 writerNonce;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param srcWriter    The address of the writer on the local chain\n    /// @param writerNonce  The nonce of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        address srcWriter,\n        uint256 writerNonce,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            srcWriter: TypeCasts.addressToBytes32(srcWriter),\n            writerNonce: writerNonce,\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryId(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.srcWriter, entry.writerNonce));\n    }\n}\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param dataHash     The hash of the data written on the source chain\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 dataHash;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingDataHash, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(address writer, uint256 writerNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntry(bytes32 dataHash) external returns (uint256 writerNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param writer        The address of the writer on the source chain\n    /// @param writerNonce   The nonce of the writer on the source chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(\n        uint256 destChainId,\n        address writer,\n        uint256 writerNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 writerNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param writer       The address of the writer on this chain\n    /// @param writerNonce  The nonce of the writer's entry on this chain\n    function getEntry(address writer, uint256 writerNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the writer on this chain.\n    /// @param writer       The address of the writer on this chain\n    function getWriterNonce(address writer) external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB();\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId();\n\n    /// @notice Request the verification of an entry in the Interchain DataBase by the module.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyEntry(entry)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param entry        The entry to verify\n    function requestVerification(uint256 destChainId, InterchainEntry memory entry) external payable;\n\n    /// @notice Get the Module fee for verifying an entry on the specified destination chain\n    /// @param destChainId  The chain id of the destination chain\n    function getModuleFee(uint256 destChainId) external view returns (uint256);\n}\n\ncontract InterchainDB is InterchainDBEvents, IInterchainDB {\n    mapping(address writer =\u003e bytes32[] dataHashes) internal _entries;\n    mapping(bytes32 entryId =\u003e mapping(address module =\u003e RemoteEntry entry)) internal _remoteEntries;\n\n    modifier onlyRemoteChainId(uint256 chainId) {\n        if (chainId == block.chainid) {\n            revert InterchainDB__SameChainId();\n        }\n        _;\n    }\n\n    // ═══════════════════════════════════════════════ WRITER-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function writeEntry(bytes32 dataHash) external returns (uint256 writerNonce) {\n        return _writeEntry(dataHash);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function requestVerification(\n        uint256 destChainId,\n        address writer,\n        uint256 writerNonce,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(destChainId)\n    {\n        InterchainEntry memory entry = getEntry(writer, writerNonce);\n        _requestVerification(destChainId, entry, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(destChainId)\n        returns (uint256 writerNonce)\n    {\n        writerNonce = _writeEntry(dataHash);\n        InterchainEntry memory entry = InterchainEntryLib.constructLocalEntry(msg.sender, writerNonce, dataHash);\n        _requestVerification(destChainId, entry, srcModules);\n    }\n\n    // ═══════════════════════════════════════════════ MODULE-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function verifyEntry(InterchainEntry memory entry) external onlyRemoteChainId(entry.srcChainId) {\n        bytes32 entryId = InterchainEntryLib.entryId(entry);\n        RemoteEntry memory existingEntry = _remoteEntries[entryId][msg.sender];\n        // Check if that's the first time module verifies the entry\n        if (existingEntry.verifiedAt == 0) {\n            _remoteEntries[entryId][msg.sender] = RemoteEntry({verifiedAt: block.timestamp, dataHash: entry.dataHash});\n            emit InterchainEntryVerified(\n                msg.sender, entry.srcChainId, entry.srcWriter, entry.writerNonce, entry.dataHash\n            );\n        } else {\n            // If the module has already verified the entry, check that the data hash is the same\n            if (existingEntry.dataHash != entry.dataHash) {\n                revert InterchainDB__ConflictingEntries(existingEntry.dataHash, entry);\n            }\n            // No-op if the data hash is the same\n        }\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        onlyRemoteChainId(entry.srcChainId)\n        returns (uint256 moduleVerifiedAt)\n    {\n        RemoteEntry memory remoteEntry = _remoteEntries[InterchainEntryLib.entryId(entry)][dstModule];\n        // Check data against the one verified by the module\n        return remoteEntry.dataHash == entry.dataHash ? remoteEntry.verifiedAt : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getInterchainFee(uint256 destChainId, address[] calldata srcModules) external view returns (uint256 fee) {\n        (, fee) = _getModuleFees(destChainId, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntry(address writer, uint256 writerNonce) public view returns (InterchainEntry memory) {\n        if (getWriterNonce(writer) \u003c= writerNonce) {\n            revert InterchainDB__EntryDoesNotExist(writer, writerNonce);\n        }\n        return InterchainEntryLib.constructLocalEntry(writer, writerNonce, _entries[writer][writerNonce]);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getWriterNonce(address writer) public view returns (uint256) {\n        return _entries[writer].length;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Write the entry to the database and emit the event.\n    function _writeEntry(bytes32 dataHash) internal returns (uint256 writerNonce) {\n        writerNonce = _entries[msg.sender].length;\n        _entries[msg.sender].push(dataHash);\n        emit InterchainEntryWritten(block.chainid, TypeCasts.addressToBytes32(msg.sender), writerNonce, dataHash);\n    }\n\n    /// @dev Request the verification of the entry by the modules, and emit the event.\n    /// Note: the validity of the passed entry and chain id being remote is enforced in the calling function.\n    function _requestVerification(\n        uint256 destChainId,\n        InterchainEntry memory entry,\n        address[] calldata srcModules\n    )\n        internal\n    {\n        (uint256[] memory fees, uint256 totalFee) = _getModuleFees(destChainId, srcModules);\n        if (msg.value != totalFee) {\n            revert InterchainDB__IncorrectFeeAmount(msg.value, totalFee);\n        }\n        uint256 len = srcModules.length;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            IInterchainModule(srcModules[i]).requestVerification{value: fees[i]}(destChainId, entry);\n        }\n        emit InterchainVerificationRequested(destChainId, entry.srcWriter, entry.writerNonce, srcModules);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Get the verification fees for the modules\n    function _getModuleFees(\n        uint256 destChainId,\n        address[] calldata srcModules\n    )\n        internal\n        view\n        returns (uint256[] memory fees, uint256 totalFee)\n    {\n        uint256 len = srcModules.length;\n        if (len == 0) {\n            revert InterchainDB__NoModulesSpecified();\n        }\n        fees = new uint256[](len);\n        for (uint256 i = 0; i \u003c len; ++i) {\n            fees[i] = IInterchainModule(srcModules[i]).getModuleFee(destChainId);\n            totalFee += fees[i];\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"1268:1080:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;1268:1080:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"1268:1080:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainDB.sol\":\"InterchainEntryLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainDB.sol\":{\"keccak256\":\"0x087d4318b29d40d2b45c6ef3909d5b1794c60b51291a13e3d4579914f656ab4c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://763c2e4e618842030e6ad710546ee1b7c77ac2780bdceabf64a18f0f3a253261\",\"dweb:/ipfs/QmbzwHDf9Y2WsSSKMMgGdU92cJCcD55CVi2GoDL7QTVfUL\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainDB.sol:TypeCasts":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220ff9bf8869e3b490d9dcf641a2e78972a71592c7cec330e44220a49593cac568c64736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220ff9bf8869e3b490d9dcf641a2e78972a71592c7cec330e44220a49593cac568c64736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nabstract contract InterchainDBEvents {\n    // TODO: figure out indexing\n    event InterchainEntryWritten(uint256 srcChainId, bytes32 srcWriter, uint256 writerNonce, bytes32 dataHash);\n    event InterchainEntryVerified(\n        address module, uint256 srcChainId, bytes32 srcWriter, uint256 writerNonce, bytes32 dataHash\n    );\n\n    event InterchainVerificationRequested(\n        uint256 destChainId, bytes32 srcWriter, uint256 writerNonce, address[] srcModules\n    );\n}\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n/// @notice Struct representing an entry in the Interchain DataBase\n/// @param srcChainId   The chain id of the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param writerNonce  The nonce of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    bytes32 srcWriter;\n    uint256 writerNonce;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param srcWriter    The address of the writer on the local chain\n    /// @param writerNonce  The nonce of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        address srcWriter,\n        uint256 writerNonce,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            srcWriter: TypeCasts.addressToBytes32(srcWriter),\n            writerNonce: writerNonce,\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryId(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.srcWriter, entry.writerNonce));\n    }\n}\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param dataHash     The hash of the data written on the source chain\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 dataHash;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingDataHash, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(address writer, uint256 writerNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntry(bytes32 dataHash) external returns (uint256 writerNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param writer        The address of the writer on the source chain\n    /// @param writerNonce   The nonce of the writer on the source chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(\n        uint256 destChainId,\n        address writer,\n        uint256 writerNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return writerNonce The writer-specific nonce of the written entry\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 writerNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param writer       The address of the writer on this chain\n    /// @param writerNonce  The nonce of the writer's entry on this chain\n    function getEntry(address writer, uint256 writerNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the writer on this chain.\n    /// @param writer       The address of the writer on this chain\n    function getWriterNonce(address writer) external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB();\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId();\n\n    /// @notice Request the verification of an entry in the Interchain DataBase by the module.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyEntry(entry)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param entry        The entry to verify\n    function requestVerification(uint256 destChainId, InterchainEntry memory entry) external payable;\n\n    /// @notice Get the Module fee for verifying an entry on the specified destination chain\n    /// @param destChainId  The chain id of the destination chain\n    function getModuleFee(uint256 destChainId) external view returns (uint256);\n}\n\ncontract InterchainDB is InterchainDBEvents, IInterchainDB {\n    mapping(address writer =\u003e bytes32[] dataHashes) internal _entries;\n    mapping(bytes32 entryId =\u003e mapping(address module =\u003e RemoteEntry entry)) internal _remoteEntries;\n\n    modifier onlyRemoteChainId(uint256 chainId) {\n        if (chainId == block.chainid) {\n            revert InterchainDB__SameChainId();\n        }\n        _;\n    }\n\n    // ═══════════════════════════════════════════════ WRITER-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function writeEntry(bytes32 dataHash) external returns (uint256 writerNonce) {\n        return _writeEntry(dataHash);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function requestVerification(\n        uint256 destChainId,\n        address writer,\n        uint256 writerNonce,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(destChainId)\n    {\n        InterchainEntry memory entry = getEntry(writer, writerNonce);\n        _requestVerification(destChainId, entry, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(destChainId)\n        returns (uint256 writerNonce)\n    {\n        writerNonce = _writeEntry(dataHash);\n        InterchainEntry memory entry = InterchainEntryLib.constructLocalEntry(msg.sender, writerNonce, dataHash);\n        _requestVerification(destChainId, entry, srcModules);\n    }\n\n    // ═══════════════════════════════════════════════ MODULE-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function verifyEntry(InterchainEntry memory entry) external onlyRemoteChainId(entry.srcChainId) {\n        bytes32 entryId = InterchainEntryLib.entryId(entry);\n        RemoteEntry memory existingEntry = _remoteEntries[entryId][msg.sender];\n        // Check if that's the first time module verifies the entry\n        if (existingEntry.verifiedAt == 0) {\n            _remoteEntries[entryId][msg.sender] = RemoteEntry({verifiedAt: block.timestamp, dataHash: entry.dataHash});\n            emit InterchainEntryVerified(\n                msg.sender, entry.srcChainId, entry.srcWriter, entry.writerNonce, entry.dataHash\n            );\n        } else {\n            // If the module has already verified the entry, check that the data hash is the same\n            if (existingEntry.dataHash != entry.dataHash) {\n                revert InterchainDB__ConflictingEntries(existingEntry.dataHash, entry);\n            }\n            // No-op if the data hash is the same\n        }\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        onlyRemoteChainId(entry.srcChainId)\n        returns (uint256 moduleVerifiedAt)\n    {\n        RemoteEntry memory remoteEntry = _remoteEntries[InterchainEntryLib.entryId(entry)][dstModule];\n        // Check data against the one verified by the module\n        return remoteEntry.dataHash == entry.dataHash ? remoteEntry.verifiedAt : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getInterchainFee(uint256 destChainId, address[] calldata srcModules) external view returns (uint256 fee) {\n        (, fee) = _getModuleFees(destChainId, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntry(address writer, uint256 writerNonce) public view returns (InterchainEntry memory) {\n        if (getWriterNonce(writer) \u003c= writerNonce) {\n            revert InterchainDB__EntryDoesNotExist(writer, writerNonce);\n        }\n        return InterchainEntryLib.constructLocalEntry(writer, writerNonce, _entries[writer][writerNonce]);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getWriterNonce(address writer) public view returns (uint256) {\n        return _entries[writer].length;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Write the entry to the database and emit the event.\n    function _writeEntry(bytes32 dataHash) internal returns (uint256 writerNonce) {\n        writerNonce = _entries[msg.sender].length;\n        _entries[msg.sender].push(dataHash);\n        emit InterchainEntryWritten(block.chainid, TypeCasts.addressToBytes32(msg.sender), writerNonce, dataHash);\n    }\n\n    /// @dev Request the verification of the entry by the modules, and emit the event.\n    /// Note: the validity of the passed entry and chain id being remote is enforced in the calling function.\n    function _requestVerification(\n        uint256 destChainId,\n        InterchainEntry memory entry,\n        address[] calldata srcModules\n    )\n        internal\n    {\n        (uint256[] memory fees, uint256 totalFee) = _getModuleFees(destChainId, srcModules);\n        if (msg.value != totalFee) {\n            revert InterchainDB__IncorrectFeeAmount(msg.value, totalFee);\n        }\n        uint256 len = srcModules.length;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            IInterchainModule(srcModules[i]).requestVerification{value: fees[i]}(destChainId, entry);\n        }\n        emit InterchainVerificationRequested(destChainId, entry.srcWriter, entry.writerNonce, srcModules);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Get the verification fees for the modules\n    function _getModuleFees(\n        uint256 destChainId,\n        address[] calldata srcModules\n    )\n        internal\n        view\n        returns (uint256[] memory fees, uint256 totalFee)\n    {\n        uint256 len = srcModules.length;\n        if (len == 0) {\n            revert InterchainDB__NoModulesSpecified();\n        }\n        fees = new uint256[](len);\n        for (uint256 i = 0; i \u003c len; ++i) {\n            fees[i] = IInterchainModule(srcModules[i]).getModuleFee(destChainId);\n            totalFee += fees[i];\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"528:280:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;528:280:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"528:280:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainDB.sol\":\"TypeCasts\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainDB.sol\":{\"keccak256\":\"0x087d4318b29d40d2b45c6ef3909d5b1794c60b51291a13e3d4579914f656ab4c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://763c2e4e618842030e6ad710546ee1b7c77ac2780bdceabf64a18f0f3a253261\",\"dweb:/ipfs/QmbzwHDf9Y2WsSSKMMgGdU92cJCcD55CVi2GoDL7QTVfUL\"]}},\"version\":1}"},"hashes":{}}}